{
  "version": 3,
  "sources": ["src/model/hex/Edge.ts", "src/model/hex/Vertex.ts", "src/model/hex/HexDirection.ts", "src/model/hex/HexGrid.ts", "src/model/hex/Hex.ts", "src/model/hex/HexCoord.ts", "src/model/map/GameMap.ts", "src/controller/util/SeededRNG.ts", "src/controller/MapGenerator.ts", "src/model/map/CivilizationId.ts", "src/application/MainGame.ts", "src/view/HexMapRenderer.ts", "src/main.ts"],
  "sourcesContent": ["import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente une ar\u00EAte (edge) entre deux hexagones adjacents.\r\n *\r\n * Cette entit\u00E9 est purement g\u00E9om\u00E9trique et mod\u00E9lise une connexion\r\n * entre deux cellules voisines, quelle que soit la couche m\u00E9tier\r\n * (carte, arbre de technologies, etc.).\r\n *\r\n * Une ar\u00EAte est identifi\u00E9e de mani\u00E8re unique par deux hexagones adjacents.\r\n * L'ordre des hexagones est normalis\u00E9 pour garantir l'unicit\u00E9.\r\n */\r\nexport class Edge {\r\n  private constructor(\r\n    public readonly hex1: HexCoord,\r\n    public readonly hex2: HexCoord\r\n  ) {\r\n    // Validation: les hexagones doivent \u00EAtre adjacents\r\n    const distance = hex1.distanceTo(hex2);\r\n    if (distance !== 1) {\r\n      throw new Error(\r\n        `Les hexagones doivent \u00EAtre adjacents pour former une ar\u00EAte. Distance: ${distance}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e une ar\u00EAte entre deux hexagones adjacents.\r\n   * Normalise l'ordre pour garantir l'unicit\u00E9.\r\n   */\r\n  static create(hex1: HexCoord, hex2: HexCoord): Edge {\r\n    // Normaliser l'ordre pour garantir l'unicit\u00E9\r\n    const normalized = Edge.normalize(hex1, hex2);\r\n    return new Edge(normalized[0], normalized[1]);\r\n  }\r\n\r\n  /**\r\n   * Normalise l'ordre de deux coordonn\u00E9es pour garantir l'unicit\u00E9.\r\n   * Ordre: q d'abord, puis r si \u00E9galit\u00E9.\r\n   */\r\n  private static normalize(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord\r\n  ): [HexCoord, HexCoord] {\r\n    if (\r\n      hex1.q < hex2.q ||\r\n      (hex1.q === hex2.q && hex1.r < hex2.r)\r\n    ) {\r\n      return [hex1, hex2];\r\n    }\r\n    return [hex2, hex1];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cette ar\u00EAte est \u00E9gale \u00E0 une autre.\r\n   */\r\n  equals(other: Edge): boolean {\r\n    return (\r\n      (this.hex1.equals(other.hex1) && this.hex2.equals(other.hex2)) ||\r\n      (this.hex1.equals(other.hex2) && this.hex2.equals(other.hex1))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne les deux hexagones de cette ar\u00EAte.\r\n   */\r\n  getHexes(): [HexCoord, HexCoord] {\r\n    return [this.hex1, this.hex2];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cette ar\u00EAte est adjacente \u00E0 un hexagone donn\u00E9.\r\n   */\r\n  isAdjacentTo(hex: HexCoord): boolean {\r\n    return this.hex1.equals(hex) || this.hex2.equals(hex);\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Edge(${this.hex1.toString()} - ${this.hex2.toString()})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    const normalized = Edge.normalize(this.hex1, this.hex2);\r\n    return `${normalized[0].hashCode()}-${normalized[1].hashCode()}`;\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente un sommet (vertex) partag\u00E9 par plusieurs hexagones.\r\n *\r\n * Un sommet est un point d'intersection g\u00E9om\u00E9trique entre trois cellules\r\n * hexagonales mutuellement adjacentes. Cette abstraction est ind\u00E9pendante\r\n * de tout usage m\u00E9tier (b\u00E2timents, n\u0153uds de technologies, etc.).\r\n *\r\n * Un sommet est identifi\u00E9 de mani\u00E8re unique par trois hexagones adjacents\r\n * qui se rencontrent \u00E0 ce point. L'ordre des hexagones est normalis\u00E9 pour\r\n * garantir l'unicit\u00E9.\r\n */\r\nexport class Vertex {\r\n  private constructor(\r\n    public readonly hex1: HexCoord,\r\n    public readonly hex2: HexCoord,\r\n    public readonly hex3: HexCoord\r\n  ) {\r\n    // Validation: les hexagones doivent former un triangle valide\r\n    if (!Vertex.isValidTriangle(hex1, hex2, hex3)) {\r\n      throw new Error(\r\n        'Les trois hexagones doivent former un triangle valide pour cr\u00E9er un sommet.'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e un sommet \u00E0 partir de trois hexagones adjacents.\r\n   * Normalise l'ordre pour garantir l'unicit\u00E9.\r\n   */\r\n  static create(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): Vertex {\r\n    const normalized = Vertex.normalize(hex1, hex2, hex3);\r\n    return new Vertex(normalized[0], normalized[1], normalized[2]);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si trois hexagones forment un triangle valide (se rencontrent \u00E0 un sommet).\r\n   * Dans une grille hexagonale, trois hexagones se rencontrent \u00E0 un sommet si et seulement si\r\n   * ils sont tous mutuellement adjacents (distance 1 entre chaque paire).\r\n   */\r\n  private static isValidTriangle(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): boolean {\r\n    const d12 = hex1.distanceTo(hex2);\r\n    const d13 = hex1.distanceTo(hex3);\r\n    const d23 = hex2.distanceTo(hex3);\r\n\r\n    // Les trois hexagones doivent \u00EAtre mutuellement adjacents\r\n    return d12 === 1 && d13 === 1 && d23 === 1;\r\n  }\r\n\r\n  /**\r\n   * Normalise l'ordre de trois coordonn\u00E9es pour garantir l'unicit\u00E9.\r\n   * Trie par q puis r.\r\n   */\r\n  private static normalize(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): [HexCoord, HexCoord, HexCoord] {\r\n    const hexes = [hex1, hex2, hex3];\r\n    hexes.sort((a, b) => {\r\n      if (a.q !== b.q) return a.q - b.q;\r\n      return a.r - b.r;\r\n    });\r\n    return [hexes[0], hexes[1], hexes[2]];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si ce sommet est \u00E9gal \u00E0 un autre.\r\n   */\r\n  equals(other: Vertex): boolean {\r\n    const thisHexes = Vertex.normalize(this.hex1, this.hex2, this.hex3);\r\n    const otherHexes = Vertex.normalize(other.hex1, other.hex2, other.hex3);\r\n\r\n    return (\r\n      thisHexes[0].equals(otherHexes[0]) &&\r\n      thisHexes[1].equals(otherHexes[1]) &&\r\n      thisHexes[2].equals(otherHexes[2])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne les trois hexagones de ce sommet.\r\n   */\r\n  getHexes(): [HexCoord, HexCoord, HexCoord] {\r\n    return [this.hex1, this.hex2, this.hex3];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si ce sommet est adjacent \u00E0 un hexagone donn\u00E9.\r\n   */\r\n  isAdjacentTo(hex: HexCoord): boolean {\r\n    return (\r\n      this.hex1.equals(hex) ||\r\n      this.hex2.equals(hex) ||\r\n      this.hex3.equals(hex)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Vertex(${this.hex1.toString()}, ${this.hex2.toString()}, ${this.hex3.toString()})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    const normalized = Vertex.normalize(this.hex1, this.hex2, this.hex3);\r\n    return `${normalized[0].hashCode()}-${normalized[1].hashCode()}-${normalized[2].hashCode()}`;\r\n  }\r\n}\r\n", "/**\r\n * Repr\u00E9sente les six directions possibles dans une grille hexagonale.\r\n * Utilise le syst\u00E8me de coordonn\u00E9es axiales o\u00F9 chaque direction\r\n * correspond \u00E0 un d\u00E9placement dans le plan hexagonal.\r\n */\r\nexport enum HexDirection {\r\n  /** Nord */\r\n  N = 0,\r\n  /** Nord-Est */\r\n  NE = 1,\r\n  /** Sud-Est */\r\n  SE = 2,\r\n  /** Sud */\r\n  S = 3,\r\n  /** Sud-Ouest */\r\n  SW = 4,\r\n  /** Nord-Ouest */\r\n  NW = 5,\r\n}\r\n\r\n/**\r\n * Tableau de toutes les directions dans l'ordre.\r\n */\r\nexport const ALL_DIRECTIONS: readonly HexDirection[] = [\r\n  HexDirection.N,\r\n  HexDirection.NE,\r\n  HexDirection.SE,\r\n  HexDirection.S,\r\n  HexDirection.SW,\r\n  HexDirection.NW,\r\n] as const;\r\n", "import { HexCoord } from './HexCoord';\r\nimport { Hex } from './Hex';\r\nimport { Edge } from './Edge';\r\nimport { Vertex } from './Vertex';\r\nimport { HexDirection, ALL_DIRECTIONS } from './HexDirection';\r\n\r\n/**\r\n * Grille hexagonale g\u00E9n\u00E9rique bas\u00E9e sur des coordonn\u00E9es axiales.\r\n *\r\n * Cette grille ne conna\u00EEt que la topologie hexagonale (cellules, ar\u00EAtes,\r\n * sommets, voisinage). Elle peut \u00EAtre utilis\u00E9e aussi bien pour une carte\r\n * de jeu que pour un graphe abstrait (par exemple un arbre de technologies)\r\n * d\u00E8s lors que ces structures reposent sur une g\u00E9om\u00E9trie hexagonale.\r\n *\r\n * Dans ce syst\u00E8me, chaque hexagone est identifi\u00E9 par deux coordonn\u00E9es (q, r):\r\n * - q: coordonn\u00E9e colonne (axe horizontal)\r\n * - r: coordonn\u00E9e ligne (axe diagonal)\r\n *\r\n * Les voisins d'un hexagone sont obtenus en ajoutant des d\u00E9placements pr\u00E9d\u00E9finis\r\n * selon la direction choisie. Ce syst\u00E8me est plus simple que les coordonn\u00E9es\r\n * cubiques (q, r, s) car la troisi\u00E8me coordonn\u00E9e peut \u00EAtre d\u00E9riv\u00E9e: s = -q - r\r\n *\r\n *\r\n * Les ar\u00EAtes (edges) et sommets (vertices) sont calcul\u00E9s automatiquement\r\n * et partag\u00E9s entre les hexagones adjacents pour garantir l'unicit\u00E9.\r\n */\r\nexport class HexGrid {\r\n  private readonly hexMap: Map<string, Hex>;\r\n  private readonly edgeCache: Map<string, Edge>;\r\n  private readonly vertexCache: Map<string, Vertex>;\r\n\r\n  /**\r\n   * Cr\u00E9e une nouvelle grille hexagonale.\r\n   * @param hexes - Tableau d'hexagones \u00E0 ajouter \u00E0 la grille\r\n   */\r\n  constructor(hexes: Hex[] = []) {\r\n    this.hexMap = new Map();\r\n    this.edgeCache = new Map();\r\n    this.vertexCache = new Map();\r\n\r\n    // Ajouter tous les hexagones\r\n    for (const hex of hexes) {\r\n      this.hexMap.set(hex.coord.hashCode(), hex);\r\n    }\r\n\r\n    // Pr\u00E9-calculer les ar\u00EAtes et sommets pour tous les hexagones\r\n    this.precomputeEdgesAndVertices();\r\n  }\r\n\r\n  /**\r\n   * Retourne l'hexagone \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e, ou undefined s'il n'existe pas.\r\n   */\r\n  getHex(coord: HexCoord): Hex | undefined {\r\n    return this.hexMap.get(coord.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les hexagones de la grille.\r\n   */\r\n  getAllHexes(): Hex[] {\r\n    return Array.from(this.hexMap.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne les hexagones voisins de l'hexagone \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e.\r\n   * Ne retourne que les voisins qui existent dans la grille.\r\n   */\r\n  getNeighbors(coord: HexCoord): Hex[] {\r\n    const neighbors: Hex[] = [];\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const neighbor = this.getHex(neighborCoord);\r\n      if (neighbor) {\r\n        neighbors.push(neighbor);\r\n      }\r\n    }\r\n    return neighbors;\r\n  }\r\n\r\n  /**\r\n   * Retourne les coordonn\u00E9es des voisins (m\u00EAme s'ils n'existent pas dans la grille).\r\n   */\r\n  getNeighborCoords(coord: HexCoord): HexCoord[] {\r\n    return coord.neighbors();\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes adjacentes \u00E0 un hexagone donn\u00E9.\r\n   * Une ar\u00EAte est adjacente si elle connecte cet hexagone \u00E0 un voisin.\r\n   */\r\n  getEdges(coord: HexCoord): Edge[] {\r\n    const edges: Edge[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return edges;\r\n    }\r\n\r\n    // Pour chaque direction, cr\u00E9er une ar\u00EAte avec le voisin (s'il existe)\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const neighbor = this.getHex(neighborCoord);\r\n      if (neighbor) {\r\n        const edge = Edge.create(coord, neighborCoord);\r\n        edges.push(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes de la grille.\r\n   */\r\n  getAllEdges(): Edge[] {\r\n    return Array.from(this.edgeCache.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes adjacentes \u00E0 un hexagone donn\u00E9.\r\n   * Inclut toutes les ar\u00EAtes qui touchent cet hexagone, m\u00EAme celles\r\n   * qui ne connectent pas \u00E0 un autre hexagone de la grille.\r\n   */\r\n  getEdgesForHex(coord: HexCoord): Edge[] {\r\n    const edges: Edge[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return edges;\r\n    }\r\n\r\n    // Pour chaque direction, cr\u00E9er une ar\u00EAte avec le voisin\r\n    // M\u00EAme si le voisin n'existe pas dans la grille, l'ar\u00EAte existe\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const edge = Edge.create(coord, neighborCoord);\r\n      const edgeKey = edge.hashCode();\r\n      \r\n      // Utiliser le cache pour \u00E9viter les doublons\r\n      if (!this.edgeCache.has(edgeKey)) {\r\n        this.edgeCache.set(edgeKey, edge);\r\n      }\r\n      edges.push(this.edgeCache.get(edgeKey)!);\r\n    }\r\n\r\n    return edges;\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets adjacents \u00E0 un hexagone donn\u00E9.\r\n   * Un sommet est adjacent s'il est form\u00E9 par cet hexagone et deux de ses voisins.\r\n   */\r\n  getVertices(coord: HexCoord): Vertex[] {\r\n    const vertices: Vertex[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return vertices;\r\n    }\r\n\r\n    // Pour chaque paire de directions cons\u00E9cutives, cr\u00E9er un sommet\r\n    // Un sommet est form\u00E9 par trois hexagones qui se rencontrent\r\n    const directions = ALL_DIRECTIONS;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      const dir1 = directions[i];\r\n      const dir2 = directions[(i + 1) % directions.length];\r\n      \r\n      const neighbor1 = coord.neighbor(dir1);\r\n      const neighbor2 = coord.neighbor(dir2);\r\n      \r\n      // V\u00E9rifier si les deux voisins existent dans la grille\r\n      const hex1 = this.getHex(neighbor1);\r\n      const hex2 = this.getHex(neighbor2);\r\n      \r\n      if (hex1 && hex2) {\r\n        // Les trois hexagones forment un sommet\r\n        try {\r\n          const vertex = Vertex.create(coord, neighbor1, neighbor2);\r\n          const vertexKey = vertex.hashCode();\r\n          \r\n          if (!this.vertexCache.has(vertexKey)) {\r\n            this.vertexCache.set(vertexKey, vertex);\r\n          }\r\n          vertices.push(this.vertexCache.get(vertexKey)!);\r\n        } catch (e) {\r\n          // Ignorer si le sommet n'est pas valide\r\n        }\r\n      }\r\n    }\r\n\r\n    return vertices;\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets de la grille.\r\n   */\r\n  getAllVertices(): Vertex[] {\r\n    return Array.from(this.vertexCache.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets qui touchent un hexagone donn\u00E9.\r\n   * Inclut les sommets m\u00EAme si certains voisins n'existent pas dans la grille.\r\n   */\r\n  getVerticesForHex(coord: HexCoord): Vertex[] {\r\n    const vertices: Vertex[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return vertices;\r\n    }\r\n\r\n    // Pour chaque paire de directions cons\u00E9cutives, cr\u00E9er un sommet\r\n    const directions = ALL_DIRECTIONS;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      const dir1 = directions[i];\r\n      const dir2 = directions[(i + 1) % directions.length];\r\n      \r\n      const neighbor1 = coord.neighbor(dir1);\r\n      const neighbor2 = coord.neighbor(dir2);\r\n      \r\n      // Cr\u00E9er le sommet m\u00EAme si les voisins n'existent pas dans la grille\r\n      try {\r\n        const vertex = Vertex.create(coord, neighbor1, neighbor2);\r\n        const vertexKey = vertex.hashCode();\r\n        \r\n        if (!this.vertexCache.has(vertexKey)) {\r\n          this.vertexCache.set(vertexKey, vertex);\r\n        }\r\n        vertices.push(this.vertexCache.get(vertexKey)!);\r\n      } catch (e) {\r\n        // Ignorer si le sommet n'est pas valide\r\n      }\r\n    }\r\n\r\n    return vertices;\r\n  }\r\n\r\n  /**\r\n   * Pr\u00E9-calcule toutes les ar\u00EAtes et sommets pour optimiser les recherches.\r\n   */\r\n  private precomputeEdgesAndVertices(): void {\r\n    // Calculer toutes les ar\u00EAtes\r\n    for (const hex of this.hexMap.values()) {\r\n      this.getEdgesForHex(hex.coord);\r\n    }\r\n\r\n    // Calculer tous les sommets\r\n    for (const hex of this.hexMap.values()) {\r\n      this.getVerticesForHex(hex.coord);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne le nombre d'hexagones dans la grille.\r\n   */\r\n  size(): number {\r\n    return this.hexMap.size;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone existe \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e.\r\n   */\r\n  hasHex(coord: HexCoord): boolean {\r\n    return this.hexMap.has(coord.hashCode());\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente une cellule hexagonale dans une grille.\r\n *\r\n * Cette classe est volontairement g\u00E9n\u00E9rique et ne contient que des\r\n * informations g\u00E9om\u00E9triques (la coordonn\u00E9e). Toute donn\u00E9e m\u00E9tier\r\n * (ressource, technologie, biome, etc.) doit \u00EAtre port\u00E9e par des\r\n * structures de niveau sup\u00E9rieur qui r\u00E9f\u00E9rencent cette cellule.\r\n */\r\nexport class Hex {\r\n  constructor(public readonly coord: HexCoord) {}\r\n\r\n  /**\r\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec un autre Hex (\u00E9galit\u00E9 structurelle sur la coordonn\u00E9e).\r\n   */\r\n  equals(other: Hex): boolean {\r\n    return this.coord.equals(other.coord);\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Hex(${this.coord.toString()})`;\r\n  }\r\n}\r\n", "import { HexDirection, ALL_DIRECTIONS } from './HexDirection';\r\n\r\n/**\r\n * Syst\u00E8me de coordonn\u00E9es axiales pour les grilles hexagonales.\r\n * \r\n * Dans ce syst\u00E8me, chaque hexagone est identifi\u00E9 par deux coordonn\u00E9es (q, r):\r\n * - q: coordonn\u00E9e colonne (axe horizontal)\r\n * - r: coordonn\u00E9e ligne (axe diagonal)\r\n * \r\n * Les voisins d'un hexagone sont obtenus en ajoutant des d\u00E9placements pr\u00E9d\u00E9finis\r\n * selon la direction choisie. Ce syst\u00E8me est plus simple que les coordonn\u00E9es\r\n * cubiques (q, r, s) car la troisi\u00E8me coordonn\u00E9e peut \u00EAtre d\u00E9riv\u00E9e: s = -q - r\r\n *\r\n */\r\nexport class HexCoord {\r\n  constructor(\r\n    public readonly q: number,\r\n    public readonly r: number\r\n  ) {}\r\n\r\n  /**\r\n   * Retourne la coordonn\u00E9e s (d\u00E9riv\u00E9e) pour compatibilit\u00E9 avec syst\u00E8me cubique.\r\n   * Dans le syst\u00E8me axial, s = -q - r\r\n   */\r\n  get s(): number {\r\n    return -this.q - this.r;\r\n  }\r\n\r\n  /**\r\n   * Retourne les coordonn\u00E9es du voisin dans la direction sp\u00E9cifi\u00E9e.\r\n   * Les d\u00E9placements sont d\u00E9finis pour le syst\u00E8me de coordonn\u00E9es axiales.\r\n   */\r\n  neighbor(direction: HexDirection): HexCoord {\r\n    const deltas: Record<HexDirection, [number, number]> = {\r\n      [HexDirection.N]: [0, -1],\r\n      [HexDirection.NE]: [1, -1],\r\n      [HexDirection.SE]: [1, 0],\r\n      [HexDirection.S]: [0, 1],\r\n      [HexDirection.SW]: [-1, 1],\r\n      [HexDirection.NW]: [-1, 0],\r\n    };\r\n\r\n    const [dq, dr] = deltas[direction];\r\n    return new HexCoord(this.q + dq, this.r + dr);\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les voisins de cet hexagone.\r\n   */\r\n  neighbors(): HexCoord[] {\r\n    return ALL_DIRECTIONS.map((dir) => this.neighbor(dir));\r\n  }\r\n\r\n  /**\r\n   * Calcule la distance entre deux hexagones.\r\n   */\r\n  distanceTo(other: HexCoord): number {\r\n    return (\r\n      (Math.abs(this.q - other.q) +\r\n        Math.abs(this.q + this.r - other.q - other.r) +\r\n        Math.abs(this.r - other.r)) /\r\n      2\r\n    );\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec un autre HexCoord.\r\n   */\r\n  equals(other: HexCoord): boolean {\r\n    return this.q === other.q && this.r === other.r;\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `(${this.q}, ${this.r})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    return `${this.q},${this.r}`;\r\n  }\r\n}\r\n", "import { HexGrid } from '../hex/HexGrid';\r\nimport { Hex } from '../hex/Hex';\r\nimport { HexCoord } from '../hex/HexCoord';\r\nimport { Edge } from '../hex/Edge';\r\nimport { Vertex } from '../hex/Vertex';\r\nimport { ResourceType } from './ResourceType';\r\nimport { CivilizationId } from './CivilizationId';\r\n\r\n/**\r\n * Carte de jeu construite sur une grille hexagonale.\r\n * \r\n * G\u00E8re les ressources par hexagone, les villes sur les sommets,\r\n * et les routes sur les ar\u00EAtes. D\u00E9termine la visibilit\u00E9 des hexagones\r\n * en fonction de la pr\u00E9sence de routes adjacentes.\r\n * \r\n * G\u00E8re \u00E9galement la propri\u00E9t\u00E9 des villes et routes par diff\u00E9rentes civilisations.\r\n */\r\nexport class GameMap {\r\n  private readonly resourceMap: Map<string, ResourceType>;\r\n  private readonly cities: Set<string>;\r\n  private readonly roads: Set<string>;\r\n  private readonly registeredCivilizations: Set<string>;\r\n  private readonly cityOwner: Map<string, CivilizationId>;\r\n  private readonly roadOwner: Map<string, CivilizationId>;\r\n\r\n  /**\r\n   * Cr\u00E9e une nouvelle carte de jeu \u00E0 partir d'une grille hexagonale.\r\n   * @param grid - La grille hexagonale sous-jacente\r\n   */\r\n  constructor(private readonly grid: HexGrid) {\r\n    this.resourceMap = new Map();\r\n    this.cities = new Set();\r\n    this.roads = new Set();\r\n    this.registeredCivilizations = new Set();\r\n    this.cityOwner = new Map();\r\n    this.roadOwner = new Map();\r\n\r\n    // Initialiser toutes les ressources \u00E0 Desert par d\u00E9faut\r\n    for (const hex of grid.getAllHexes()) {\r\n      this.resourceMap.set(hex.coord.hashCode(), ResourceType.Desert);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne la grille hexagonale sous-jacente.\r\n   */\r\n  getGrid(): HexGrid {\r\n    return this.grid;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit le type de ressource pour un hexagone.\r\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\r\n   * @param resource - Le type de ressource\r\n   * @throws Error si l'hexagone n'existe pas dans la grille\r\n   */\r\n  setResource(hex: Hex | HexCoord, resource: ResourceType): void {\r\n    const coord = hex instanceof Hex ? hex.coord : hex;\r\n    if (!this.grid.hasHex(coord)) {\r\n      throw new Error(`L'hexagone \u00E0 la coordonn\u00E9e ${coord.toString()} n'existe pas dans la grille.`);\r\n    }\r\n    this.resourceMap.set(coord.hashCode(), resource);\r\n  }\r\n\r\n  /**\r\n   * Retourne le type de ressource d'un hexagone.\r\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\r\n   * @returns Le type de ressource, ou undefined si l'hexagone n'existe pas\r\n   */\r\n  getResource(hex: Hex | HexCoord): ResourceType | undefined {\r\n    const coord = hex instanceof Hex ? hex.coord : hex;\r\n    if (!this.grid.hasHex(coord)) {\r\n      return undefined;\r\n    }\r\n    return this.resourceMap.get(coord.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Enregistre une civilisation dans la carte.\r\n   * @param civId - L'identifiant de la civilisation\r\n   */\r\n  registerCivilization(civId: CivilizationId): void {\r\n    this.registeredCivilizations.add(civId.hashCode());\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une civilisation est enregistr\u00E9e.\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @returns true si la civilisation est enregistr\u00E9e\r\n   */\r\n  isCivilizationRegistered(civId: CivilizationId): boolean {\r\n    return this.registeredCivilizations.has(civId.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Ajoute une ville sur un sommet pour une civilisation donn\u00E9e.\r\n   * @param vertex - Le sommet o\u00F9 placer la ville\r\n   * @param civId - L'identifiant de la civilisation propri\u00E9taire\r\n   * @throws Error si le sommet n'est pas valide dans la grille\r\n   * @throws Error si une ville existe d\u00E9j\u00E0 sur ce sommet\r\n   * @throws Error si la civilisation n'est pas enregistr\u00E9e\r\n   */\r\n  addCity(vertex: Vertex, civId: CivilizationId): void {\r\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\r\n    if (!this.isCivilizationRegistered(civId)) {\r\n      throw new Error(`La civilisation ${civId.toString()} n'est pas enregistr\u00E9e.`);\r\n    }\r\n\r\n    const vertexKey = vertex.hashCode();\r\n\r\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une ville sur ce sommet\r\n    if (this.cities.has(vertexKey)) {\r\n      throw new Error(`Une ville existe d\u00E9j\u00E0 sur le sommet ${vertex.toString()}.`);\r\n    }\r\n\r\n    // V\u00E9rifier que le sommet est valide (au moins un hexagone doit exister)\r\n    const hexes = vertex.getHexes();\r\n    const hasValidHex = hexes.some(coord => this.grid.hasHex(coord));\r\n    \r\n    if (!hasValidHex) {\r\n      throw new Error(`Le sommet ${vertex.toString()} n'est pas valide dans la grille.`);\r\n    }\r\n    \r\n    this.cities.add(vertexKey);\r\n    this.cityOwner.set(vertexKey, civId);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une ville existe sur un sommet.\r\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\r\n   * @returns true si une ville existe sur ce sommet\r\n   */\r\n  hasCity(vertex: Vertex): boolean {\r\n    return this.cities.has(vertex.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Ajoute une route sur une ar\u00EAte pour une civilisation donn\u00E9e.\r\n   * @param edge - L'ar\u00EAte o\u00F9 placer la route\r\n   * @param civId - L'identifiant de la civilisation propri\u00E9taire\r\n   * @throws Error si l'ar\u00EAte n'est pas valide dans la grille\r\n   * @throws Error si une route existe d\u00E9j\u00E0 sur cette ar\u00EAte\r\n   * @throws Error si la civilisation n'est pas enregistr\u00E9e\r\n   */\r\n  addRoad(edge: Edge, civId: CivilizationId): void {\r\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\r\n    if (!this.isCivilizationRegistered(civId)) {\r\n      throw new Error(`La civilisation ${civId.toString()} n'est pas enregistr\u00E9e.`);\r\n    }\r\n\r\n    const edgeKey = edge.hashCode();\r\n\r\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une route sur cette ar\u00EAte\r\n    if (this.roads.has(edgeKey)) {\r\n      throw new Error(`Une route existe d\u00E9j\u00E0 sur l'ar\u00EAte ${edge.toString()}.`);\r\n    }\r\n\r\n    // V\u00E9rifier que l'ar\u00EAte est valide (au moins un hexagone doit exister)\r\n    const [hex1, hex2] = edge.getHexes();\r\n    const hasValidHex = this.grid.hasHex(hex1) || this.grid.hasHex(hex2);\r\n    \r\n    if (!hasValidHex) {\r\n      throw new Error(`L'ar\u00EAte ${edge.toString()} n'est pas valide dans la grille.`);\r\n    }\r\n    \r\n    this.roads.add(edgeKey);\r\n    this.roadOwner.set(edgeKey, civId);\r\n  }\r\n\r\n  /**\r\n   * Retourne le propri\u00E9taire d'une ville sur un sommet.\r\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\r\n   * @returns L'identifiant de la civilisation propri\u00E9taire, ou undefined s'il n'y a pas de ville\r\n   */\r\n  getCityOwner(vertex: Vertex): CivilizationId | undefined {\r\n    return this.cityOwner.get(vertex.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne le propri\u00E9taire d'une route sur une ar\u00EAte.\r\n   * @param edge - L'ar\u00EAte \u00E0 v\u00E9rifier\r\n   * @returns L'identifiant de la civilisation propri\u00E9taire, ou undefined s'il n'y a pas de route\r\n   */\r\n  getRoadOwner(edge: Edge): CivilizationId | undefined {\r\n    return this.roadOwner.get(edge.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les villes appartenant \u00E0 une civilisation donn\u00E9e.\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @returns Un tableau des sommets contenant des villes de cette civilisation\r\n   */\r\n  getCitiesForCivilization(civId: CivilizationId): Vertex[] {\r\n    const cities: Vertex[] = [];\r\n    const civKey = civId.hashCode();\r\n\r\n    // Parcourir tous les sommets de la grille pour trouver ceux poss\u00E9d\u00E9s par cette civilisation\r\n    for (const vertex of this.grid.getAllVertices()) {\r\n      const owner = this.cityOwner.get(vertex.hashCode());\r\n      if (owner && owner.hashCode() === civKey) {\r\n        cities.push(vertex);\r\n      }\r\n    }\r\n\r\n    return cities;\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les routes appartenant \u00E0 une civilisation donn\u00E9e.\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @returns Un tableau des ar\u00EAtes contenant des routes de cette civilisation\r\n   */\r\n  getRoadsForCivilization(civId: CivilizationId): Edge[] {\r\n    const roads: Edge[] = [];\r\n    const civKey = civId.hashCode();\r\n\r\n    // Parcourir tous les hexagones pour obtenir leurs ar\u00EAtes\r\n    for (const hex of this.grid.getAllHexes()) {\r\n      const edges = this.grid.getEdgesForHex(hex.coord);\r\n      for (const edge of edges) {\r\n        const owner = this.roadOwner.get(edge.hashCode());\r\n        if (owner && owner.hashCode() === civKey && !roads.some(e => e.equals(edge))) {\r\n          roads.push(edge);\r\n        }\r\n      }\r\n    }\r\n\r\n    return roads;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une route existe sur une ar\u00EAte.\r\n   * @param edge - L'ar\u00EAte \u00E0 v\u00E9rifier\r\n   * @returns true si une route existe sur cette ar\u00EAte\r\n   */\r\n  hasRoad(edge: Edge): boolean {\r\n    return this.roads.has(edge.hashCode());\r\n  }\r\n\r\n  /**\r\n   * D\u00E9termine si un hexagone est visible.\r\n   * \r\n   * Un hexagone est visible si au moins un de ses sommets a une ville ou une route connect\u00E9e.\r\n   * Un hexagone sans ville ni route adjacente n'est pas visible.\r\n   * \r\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\r\n   * @returns true si l'hexagone est visible, false sinon\r\n   */\r\n  isHexVisible(hex: Hex | HexCoord): boolean {\r\n    const coord = hex instanceof Hex ? hex.coord : hex;\r\n    \r\n    // Si l'hexagone n'existe pas, il n'est pas visible\r\n    if (!this.grid.hasHex(coord)) {\r\n      return false;\r\n    }\r\n\r\n    // Obtenir tous les sommets de cet hexagone\r\n    const vertices = this.grid.getVerticesForHex(coord);\r\n    \r\n    // V\u00E9rifier si au moins un sommet a une ville ou une route connect\u00E9e\r\n    for (const vertex of vertices) {\r\n      // V\u00E9rifier si ce vertex a une ville\r\n      if (this.hasCity(vertex)) {\r\n        return true;\r\n      }\r\n      \r\n      // V\u00E9rifier si ce vertex a une route connect\u00E9e\r\n      // Un sommet est form\u00E9 par 3 hexagones, donc il y a 3 ar\u00EAtes qui se rencontrent \u00E0 ce sommet\r\n      const hexes = vertex.getHexes();\r\n      \r\n      // V\u00E9rifier chaque paire d'hexagones pour former une ar\u00EAte\r\n      // Les 3 ar\u00EAtes possibles: (hex1,hex2), (hex2,hex3), (hex1,hex3)\r\n      for (let i = 0; i < hexes.length; i++) {\r\n        for (let j = i + 1; j < hexes.length; j++) {\r\n          try {\r\n            const edge = Edge.create(hexes[i], hexes[j]);\r\n            if (this.hasRoad(edge)) {\r\n              return true;\r\n            }\r\n          } catch (e) {\r\n            // Ignorer les ar\u00EAtes invalides (non adjacentes)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n}", "/**\r\n * G\u00E9n\u00E9rateur de nombres al\u00E9atoires seed\u00E9 simple.\r\n * \r\n * Impl\u00E9mentation d'un Linear Congruential Generator (LCG)\r\n * pour une g\u00E9n\u00E9ration al\u00E9atoire d\u00E9terministe et reproductible.\r\n * \r\n * Formule: next = (a * current + c) mod m\r\n * Param\u00E8tres: a = 1664525, c = 1013904223, m = 2^32\r\n */\r\nexport class SeededRNG {\r\n  private state: number;\r\n\r\n  /**\r\n   * Cr\u00E9e un nouveau g\u00E9n\u00E9rateur avec une seed initiale.\r\n   * @param seed - La seed initiale\r\n   */\r\n  constructor(seed: number) {\r\n    // Convertir en entier non sign\u00E9 32 bits\r\n    this.state = seed >>> 0;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re le prochain nombre al\u00E9atoire entre 0 (inclus) et 1 (exclus).\r\n   * @returns Un nombre al\u00E9atoire entre 0 et 1\r\n   */\r\n  next(): number {\r\n    // LCG: (a * state + c) mod m\r\n    // Param\u00E8tres de Borland C/C++ (utilis\u00E9s pour leur simplicit\u00E9 et qualit\u00E9)\r\n    this.state = (this.state * 1664525 + 1013904223) >>> 0;\r\n    // Normaliser \u00E0 [0, 1)\r\n    return (this.state >>> 0) / 0x100000000;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un nombre entier al\u00E9atoire entre min (inclus) et max (exclus).\r\n   * @param min - Borne inf\u00E9rieure (inclus)\r\n   * @param max - Borne sup\u00E9rieure (exclus)\r\n   * @returns Un entier al\u00E9atoire dans l'intervalle [min, max)\r\n   */\r\n  nextInt(min: number, max: number): number {\r\n    if (min >= max) {\r\n      throw new Error(`min (${min}) doit \u00EAtre strictement inf\u00E9rieur \u00E0 max (${max})`);\r\n    }\r\n    const range = max - min;\r\n    return min + Math.floor(this.next() * range);\r\n  }\r\n\r\n  /**\r\n   * S\u00E9lectionne un \u00E9l\u00E9ment al\u00E9atoire dans un tableau.\r\n   * @param array - Le tableau source\r\n   * @returns Un \u00E9l\u00E9ment du tableau, ou undefined si le tableau est vide\r\n   */\r\n  pick<T>(array: T[]): T | undefined {\r\n    if (array.length === 0) {\r\n      return undefined;\r\n    }\r\n    const index = this.nextInt(0, array.length);\r\n    return array[index];\r\n  }\r\n\r\n  /**\r\n   * M\u00E9lange un tableau de mani\u00E8re al\u00E9atoire (algorithme de Fisher-Yates).\r\n   * Modifie le tableau en place.\r\n   * @param array - Le tableau \u00E0 m\u00E9langer\r\n   */\r\n  shuffle<T>(array: T[]): void {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = this.nextInt(0, i + 1);\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne l'\u00E9tat actuel du g\u00E9n\u00E9rateur (utile pour les tests).\r\n   */\r\n  getState(): number {\r\n    return this.state;\r\n  }\r\n}\r\n", "import { HexGrid } from '../model/hex/HexGrid';\r\nimport { Hex } from '../model/hex/Hex';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { HexDirection, ALL_DIRECTIONS } from '../model/hex/HexDirection';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { SeededRNG } from './util/SeededRNG';\r\n\r\n/**\r\n * Configuration pour la g\u00E9n\u00E9ration d'une carte.\r\n */\r\nexport interface MapGeneratorConfig {\r\n  /** Distribution des ressources : nombre d'hexagones par type de ressource */\r\n  resourceDistribution: Map<ResourceType, number>;\r\n  /** Liste des civilisations (au moins une requise) */\r\n  civilizations: CivilizationId[];\r\n  /** Seed pour la g\u00E9n\u00E9ration d\u00E9terministe */\r\n  seed: number;\r\n}\r\n\r\n/**\r\n * G\u00E9n\u00E8re une GameMap selon des r\u00E8gles configurables.\r\n * \r\n * Cette classe appartient \u00E0 la couche Controller et agit comme une factory\r\n * pour cr\u00E9er des GameMap avec une structure et des ressources pr\u00E9d\u00E9termin\u00E9es.\r\n */\r\nexport class MapGenerator {\r\n  /**\r\n   * G\u00E9n\u00E8re une nouvelle GameMap selon la configuration fournie.\r\n   * \r\n   * @param config - Configuration de g\u00E9n\u00E9ration\r\n   * @returns Une GameMap compl\u00E8tement initialis\u00E9e avec ressources assign\u00E9es\r\n   * @throws Error si la configuration est invalide\r\n   */\r\n  generate(config: MapGeneratorConfig): GameMap {\r\n    this.validateConfig(config);\r\n\r\n    const rng = new SeededRNG(config.seed);\r\n    \r\n    // G\u00E9n\u00E9rer d'abord les hexagones terrestres (avec identification de Bois et Argile)\r\n    const { hexes: terrestrialHexes, woodCoord, brickCoord } = this.generateTerrestrialHexes(config, rng);\r\n    \r\n    // Ajouter la couche d'eau autour des hexagones terrestres\r\n    const allHexes = this.addWaterLayer(terrestrialHexes);\r\n    \r\n    // Cr\u00E9er la grille compl\u00E8te avec tous les hexagones (terrestres + eau)\r\n    const hexGrid = new HexGrid(allHexes);\r\n    const gameMap = new GameMap(hexGrid);\r\n\r\n    // Enregistrer les civilisations\r\n    for (const civId of config.civilizations) {\r\n      gameMap.registerCivilization(civId);\r\n    }\r\n\r\n    // Assigner les ressources aux hexagones terrestres\r\n    // Les deux premiers (Bois et Argile) doivent \u00EAtre assign\u00E9s en premier\r\n    this.assignResources(gameMap, terrestrialHexes, config, rng, woodCoord, brickCoord);\r\n\r\n    // Assigner Water \u00E0 tous les hexagones d'eau\r\n    this.assignWaterResources(gameMap, terrestrialHexes);\r\n\r\n    // Ajouter la ville initiale sur le vertex bois-argile-eau pour la premi\u00E8re civilisation\r\n    if (config.civilizations.length > 0) {\r\n      this.addInitialCity(gameMap, woodCoord, brickCoord, config.civilizations[0]);\r\n    }\r\n\r\n    return gameMap;\r\n  }\r\n\r\n  /**\r\n   * Valide la configuration de g\u00E9n\u00E9ration.\r\n   * @throws Error si la configuration est invalide\r\n   */\r\n  private validateConfig(config: MapGeneratorConfig): void {\r\n    if (!config.civilizations || config.civilizations.length === 0) {\r\n      throw new Error('Au moins une civilisation est requise.');\r\n    }\r\n\r\n    // Calculer le nombre total d'hexagones requis\r\n    let totalHexes = 0;\r\n    for (const count of config.resourceDistribution.values()) {\r\n      if (count < 0) {\r\n        throw new Error('La distribution de ressources ne peut pas contenir de valeurs n\u00E9gatives.');\r\n      }\r\n      totalHexes += count;\r\n    }\r\n\r\n    if (totalHexes === 0) {\r\n      throw new Error('Au moins un hexagone est requis (distribution de ressources vide).');\r\n    }\r\n\r\n    // V\u00E9rifier que le seed est valide (n'importe quel nombre est valide)\r\n    if (typeof config.seed !== 'number' || !isFinite(config.seed)) {\r\n      throw new Error('Le seed doit \u00EAtre un nombre fini.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re uniquement les hexagones terrestres selon les r\u00E8gles de placement.\r\n   * - Les 2 premiers hexagones sont plac\u00E9s adjacents (Bois et Argile)\r\n   * - Chaque hexagone suivant doit \u00EAtre adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n   */\r\n  private generateTerrestrialHexes(config: MapGeneratorConfig, rng: SeededRNG): { hexes: Hex[], woodCoord: HexCoord, brickCoord: HexCoord } {\r\n    const totalHexes = this.calculateTotalHexes(config.resourceDistribution);\r\n    const placedCoords = new Set<string>();\r\n    const hexes: Hex[] = [];\r\n\r\n    // \u00C9tape 1: Placer les 2 premiers hexagones adjacents (Bois et Argile)\r\n    // Le premier sera Bois, le second Argile\r\n    const woodCoord = new HexCoord(0, 0);\r\n    const brickCoord = woodCoord.neighbor(HexDirection.N);\r\n\r\n    hexes.push(new Hex(woodCoord));\r\n    hexes.push(new Hex(brickCoord));\r\n    placedCoords.add(woodCoord.hashCode());\r\n    placedCoords.add(brickCoord.hashCode());\r\n\r\n    // Retourner aussi les coordonn\u00E9es pour pouvoir les identifier plus tard\r\n    const result = { hexes, woodCoord, brickCoord };\r\n\r\n    // \u00C9tape 2: Placer les hexagones restants\r\n    while (hexes.length < totalHexes) {\r\n      const candidateCoord = this.findValidPlacement(placedCoords, rng);\r\n\r\n      if (!candidateCoord) {\r\n        // Si aucun placement valide n'est trouv\u00E9, cela peut arriver si la distribution\r\n        // demande plus d'hexagones que possible avec les r\u00E8gles donn\u00E9es\r\n        throw new Error(\r\n          `Impossible de placer tous les hexagones requis. ` +\r\n          `Plac\u00E9s: ${hexes.length}/${totalHexes}. ` +\r\n          `V\u00E9rifiez que la distribution de ressources est raisonnable.`\r\n        );\r\n      }\r\n\r\n      hexes.push(new Hex(candidateCoord));\r\n      placedCoords.add(candidateCoord.hashCode());\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Trouve une coordonn\u00E9e valide pour le prochain hexagone.\r\n   * Un placement est valide si le nouvel hexagone est adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s.\r\n   */\r\n  private findValidPlacement(placedCoords: Set<string>, rng: SeededRNG): HexCoord | null {\r\n    // Collecter tous les candidats (voisins des hexagones plac\u00E9s)\r\n    const candidateMap = new Map<string, HexCoord>();\r\n\r\n    // Pour chaque hexagone d\u00E9j\u00E0 plac\u00E9, examiner ses voisins\r\n    for (const coordHash of placedCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const coord = new HexCoord(q, r);\r\n\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const neighbor = coord.neighbor(direction);\r\n        const neighborHash = neighbor.hashCode();\r\n\r\n        // Si ce voisin n'est pas d\u00E9j\u00E0 plac\u00E9, l'ajouter aux candidats\r\n        if (!placedCoords.has(neighborHash)) {\r\n          candidateMap.set(neighborHash, neighbor);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Filtrer les candidats qui sont adjacents \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n    const validCandidates: HexCoord[] = [];\r\n    for (const candidate of candidateMap.values()) {\r\n      // Compter combien de voisins de ce candidat sont d\u00E9j\u00E0 plac\u00E9s\r\n      let adjacentCount = 0;\r\n      for (const dir of ALL_DIRECTIONS) {\r\n        const neighbor = candidate.neighbor(dir);\r\n        if (placedCoords.has(neighbor.hashCode())) {\r\n          adjacentCount++;\r\n        }\r\n      }\r\n\r\n      // Un hexagone doit \u00EAtre adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n      if (adjacentCount >= 2) {\r\n        validCandidates.push(candidate);\r\n      }\r\n    }\r\n\r\n    // Choisir un candidat al\u00E9atoire\r\n    return rng.pick(validCandidates) || null;\r\n  }\r\n\r\n  /**\r\n   * Calcule le nombre total d'hexagones requis.\r\n   */\r\n  private calculateTotalHexes(resourceDistribution: Map<ResourceType, number>): number {\r\n    let total = 0;\r\n    for (const count of resourceDistribution.values()) {\r\n      total += count;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Ajoute une couche d'hexagones d'eau autour des hexagones terrestres.\r\n   * Retourne tous les hexagones (terrestres + eau).\r\n   */\r\n  private addWaterLayer(terrestrialHexes: Hex[]): Hex[] {\r\n    const terrestrialCoords = new Set<string>();\r\n    const waterCoords = new Set<string>();\r\n\r\n    // Marquer tous les hexagones terrestres\r\n    for (const hex of terrestrialHexes) {\r\n      terrestrialCoords.add(hex.coord.hashCode());\r\n    }\r\n\r\n    // Trouver tous les hexagones d'eau n\u00E9cessaires (voisins des hexagones terrestres)\r\n    for (const hex of terrestrialHexes) {\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const neighborCoord = hex.coord.neighbor(direction);\r\n        const neighborHash = neighborCoord.hashCode();\r\n\r\n        // Si ce voisin n'est pas terrestre, c'est un hexagone d'eau\r\n        if (!terrestrialCoords.has(neighborHash) && !waterCoords.has(neighborHash)) {\r\n          waterCoords.add(neighborHash);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Cr\u00E9er tous les hexagones (terrestres + eau)\r\n    const allHexes: Hex[] = [...terrestrialHexes];\r\n\r\n    // Ajouter tous les hexagones d'eau\r\n    for (const coordHash of waterCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const waterCoord = new HexCoord(q, r);\r\n      allHexes.push(new Hex(waterCoord));\r\n    }\r\n\r\n    return allHexes;\r\n  }\r\n\r\n  /**\r\n   * Assign\u00EB les ressources aux hexagones terrestres selon la distribution.\r\n   * Exclut les hexagones d'eau.\r\n   * Les deux premiers hexagones (Bois et Argile) sont assign\u00E9s en premier.\r\n   */\r\n  private assignResources(\r\n    gameMap: GameMap,\r\n    terrestrialHexes: Hex[],\r\n    config: MapGeneratorConfig,\r\n    rng: SeededRNG,\r\n    woodCoord: HexCoord,\r\n    brickCoord: HexCoord\r\n  ): void {\r\n    // Cr\u00E9er une liste de tous les types de ressources \u00E0 assigner (sans l'eau)\r\n    const resourcesToAssign: ResourceType[] = [];\r\n    for (const [resourceType, count] of config.resourceDistribution.entries()) {\r\n      // Ignorer l'eau dans la distribution (elle sera ajout\u00E9e s\u00E9par\u00E9ment)\r\n      if (resourceType === ResourceType.Water) {\r\n        continue;\r\n      }\r\n      for (let i = 0; i < count; i++) {\r\n        resourcesToAssign.push(resourceType);\r\n      }\r\n    }\r\n\r\n    // S\u00E9parer les ressources Bois et Argile pour les placer en premier\r\n    const woodIndex = resourcesToAssign.indexOf(ResourceType.Wood);\r\n    const brickIndex = resourcesToAssign.indexOf(ResourceType.Brick);\r\n    \r\n    // Retirer Bois et Argile de la liste (un exemplaire de chaque)\r\n    if (woodIndex !== -1) {\r\n      resourcesToAssign.splice(woodIndex, 1);\r\n    }\r\n    if (brickIndex !== -1 && brickIndex !== woodIndex) {\r\n      // Ajuster l'index si Wood a \u00E9t\u00E9 retir\u00E9 avant\r\n      const adjustedBrickIndex = resourcesToAssign.indexOf(ResourceType.Brick);\r\n      if (adjustedBrickIndex !== -1) {\r\n        resourcesToAssign.splice(adjustedBrickIndex, 1);\r\n      }\r\n    }\r\n\r\n    // M\u00E9langer la liste pour un placement al\u00E9atoire\r\n    rng.shuffle(resourcesToAssign);\r\n\r\n    // Assigner Bois et Argile aux deux premiers hexagones\r\n    gameMap.setResource(woodCoord, ResourceType.Wood);\r\n    gameMap.setResource(brickCoord, ResourceType.Brick);\r\n\r\n    // Filtrer les hexagones terrestres (exclure Bois et Argile)\r\n    const remainingHexes = terrestrialHexes.filter(\r\n      hex => !hex.coord.equals(woodCoord) && !hex.coord.equals(brickCoord)\r\n    );\r\n\r\n    // M\u00E9langer les hexagones restants\r\n    const shuffledHexes = [...remainingHexes];\r\n    rng.shuffle(shuffledHexes);\r\n\r\n    // Assigner chaque ressource restante \u00E0 un hexagone\r\n    for (let i = 0; i < resourcesToAssign.length && i < shuffledHexes.length; i++) {\r\n      const hex = shuffledHexes[i];\r\n      const resource = resourcesToAssign[i];\r\n      gameMap.setResource(hex.coord, resource);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign\u00EB Water \u00E0 tous les hexagones d'eau de la carte.\r\n   */\r\n  private assignWaterResources(gameMap: GameMap, terrestrialHexes: Hex[]): void {\r\n    const grid = gameMap.getGrid();\r\n    const terrestrialCoords = new Set<string>();\r\n\r\n    // Marquer tous les hexagones terrestres\r\n    for (const hex of terrestrialHexes) {\r\n      terrestrialCoords.add(hex.coord.hashCode());\r\n    }\r\n\r\n    // Parcourir tous les hexagones de la grille et assigner Water \u00E0 ceux qui ne sont pas terrestres\r\n    for (const hex of grid.getAllHexes()) {\r\n      if (!terrestrialCoords.has(hex.coord.hashCode())) {\r\n        gameMap.setResource(hex.coord, ResourceType.Water);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ajoute la ville initiale sur le vertex bois-argile-eau.\r\n   */\r\n  private addInitialCity(\r\n    gameMap: GameMap,\r\n    woodCoord: HexCoord,\r\n    brickCoord: HexCoord,\r\n    civId: CivilizationId\r\n  ): void {\r\n    const grid = gameMap.getGrid();\r\n\r\n    // Trouver l'hexagone d'eau qui forme un vertex avec Bois et Argile\r\n    // Un vertex est form\u00E9 par trois hexagones mutuellement adjacents\r\n    // Nous devons trouver un hexagone d'eau adjacent \u00E0 la fois \u00E0 Bois et Argile\r\n    \r\n    // Les deux hexagones sont adjacents (brickCoord est en N de woodCoord)\r\n    // Pour former un vertex, il faut un troisi\u00E8me hexagone adjacent aux deux\r\n    \r\n    // M\u00E9thode 1: Chercher parmi tous les vertices du hexagone Bois\r\n    // Cela garantit que le vertex retourn\u00E9 correspond \u00E0 celui utilis\u00E9 dans la grille\r\n    const woodVertices = grid.getVerticesForHex(woodCoord);\r\n    for (const vertex of woodVertices) {\r\n      const hexes = vertex.getHexes();\r\n      // V\u00E9rifier si ce vertex contient woodCoord, brickCoord et un hexagone d'eau\r\n      const hasWood = hexes.some(h => h.equals(woodCoord));\r\n      const hasBrick = hexes.some(h => h.equals(brickCoord));\r\n      \r\n      if (hasWood && hasBrick) {\r\n        // Trouver l'hexagone qui n'est ni wood ni brick (c'est l'eau)\r\n        const waterHex = hexes.find(h => !h.equals(woodCoord) && !h.equals(brickCoord));\r\n        if (waterHex) {\r\n          const resource = gameMap.getResource(waterHex);\r\n          if (resource === ResourceType.Water) {\r\n            // Ajouter la ville sur ce vertex (utiliser le vertex retourn\u00E9 par la grille)\r\n            try {\r\n              gameMap.addCity(vertex, civId);\r\n              return;\r\n            } catch (e) {\r\n              // Ignorer les erreurs (ville d\u00E9j\u00E0 pr\u00E9sente ou civilisation non enregistr\u00E9e)\r\n              // mais continuer la recherche\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // M\u00E9thode 2: Si la m\u00E9thode 1 \u00E9choue, chercher les voisins communs\r\n    // Trouver tous les voisins communs de woodCoord et brickCoord\r\n    const woodNeighbors = woodCoord.neighbors();\r\n    const brickNeighbors = brickCoord.neighbors();\r\n    \r\n    for (const neighborCoord of woodNeighbors) {\r\n      // V\u00E9rifier si ce voisin est aussi voisin de brickCoord\r\n      const isNeighborOfBrick = brickNeighbors.some(n => n.equals(neighborCoord));\r\n      \r\n      if (isNeighborOfBrick) {\r\n        // V\u00E9rifier si cet hexagone existe dans la grille et est de l'eau\r\n        const neighborHex = grid.getHex(neighborCoord);\r\n        if (neighborHex) {\r\n          const resource = gameMap.getResource(neighborCoord);\r\n          if (resource === ResourceType.Water) {\r\n            // Trouver le vertex correspondant dans la grille (pour utiliser le m\u00EAme instance)\r\n            const vertices = grid.getVerticesForHex(woodCoord);\r\n            for (const vertex of vertices) {\r\n              const hexes = vertex.getHexes();\r\n              if (hexes.some(h => h.equals(woodCoord)) &&\r\n                  hexes.some(h => h.equals(brickCoord)) &&\r\n                  hexes.some(h => h.equals(neighborCoord))) {\r\n                try {\r\n                  gameMap.addCity(vertex, civId);\r\n                  return;\r\n                } catch (e) {\r\n                  // Ignorer les erreurs\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n", "/**\r\n * Identifiant unique d'une civilisation.\r\n * \r\n * Value object immuable qui garantit l'unicit\u00E9 d'une civilisation.\r\n */\r\nexport class CivilizationId {\r\n  private constructor(private readonly value: string) {\r\n    if (!value || value.trim().length === 0) {\r\n      throw new Error('L\\'identifiant de civilisation ne peut pas \u00EAtre vide.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e un identifiant de civilisation.\r\n   * @param value - La valeur unique de l'identifiant\r\n   */\r\n  static create(value: string): CivilizationId {\r\n    return new CivilizationId(value.trim());\r\n  }\r\n\r\n  /**\r\n   * Retourne la valeur de l'identifiant.\r\n   */\r\n  getValue(): string {\r\n    return this.value;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cet identifiant est \u00E9gal \u00E0 un autre.\r\n   */\r\n  equals(other: CivilizationId): boolean {\r\n    return this.value === other.value;\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `CivilizationId(${this.value})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    return this.value;\r\n  }\r\n}\r\n", "import { MapGenerator, MapGeneratorConfig } from '../controller/MapGenerator';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\n\r\n/**\r\n * Classe principale de l'application de jeu.\r\n * \r\n * Orchestre la g\u00E9n\u00E9ration de la carte et la gestion du jeu.\r\n * Cette classe se situe au-dessus de la couche MVC.\r\n */\r\nexport class MainGame {\r\n  private gameMap: GameMap | null = null;\r\n  private readonly mapGenerator: MapGenerator;\r\n\r\n  constructor() {\r\n    this.mapGenerator = new MapGenerator();\r\n  }\r\n\r\n  /**\r\n   * Initialise une nouvelle partie en g\u00E9n\u00E9rant une carte.\r\n   * @param seed - Seed optionnel pour la g\u00E9n\u00E9ration (par d\u00E9faut: timestamp)\r\n   */\r\n  initialize(seed?: number): void {\r\n    const actualSeed = seed ?? Date.now();\r\n\r\n    // Configuration : 5 ressources de chaque type (sauf Water qui est g\u00E9n\u00E9r\u00E9 automatiquement)\r\n    const resourceDistribution = new Map<ResourceType, number>([\r\n      [ResourceType.Wood, 5],\r\n      [ResourceType.Brick, 5],\r\n      [ResourceType.Wheat, 5],\r\n      [ResourceType.Sheep, 5],\r\n      [ResourceType.Ore, 5],\r\n      [ResourceType.Desert, 5],\r\n    ]);\r\n\r\n    // Cr\u00E9er une civilisation par d\u00E9faut\r\n    const civilizations = [CivilizationId.create('player1')];\r\n\r\n    const config: MapGeneratorConfig = {\r\n      resourceDistribution,\r\n      civilizations,\r\n      seed: actualSeed,\r\n    };\r\n\r\n    this.gameMap = this.mapGenerator.generate(config);\r\n  }\r\n\r\n  /**\r\n   * Retourne la carte de jeu actuelle.\r\n   * @returns La GameMap, ou null si non initialis\u00E9e\r\n   */\r\n  getGameMap(): GameMap | null {\r\n    return this.gameMap;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re une nouvelle carte avec un nouveau seed.\r\n   */\r\n  regenerate(): void {\r\n    this.initialize();\r\n  }\r\n}\r\n", "import { GameMap } from '../model/map/GameMap';\r\nimport { Hex } from '../model/hex/Hex';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\n\r\n/**\r\n * Configuration pour le rendu des hexagones.\r\n */\r\ninterface RenderConfig {\r\n  /** Taille d'un hexagone (rayon) en pixels */\r\n  hexSize: number;\r\n  /** Offset X pour centrer la carte */\r\n  offsetX: number;\r\n  /** Offset Y pour centrer la carte */\r\n  offsetY: number;\r\n}\r\n\r\n/**\r\n * Couleur associ\u00E9e \u00E0 chaque type de ressource.\r\n */\r\nconst RESOURCE_COLORS: Record<ResourceType, string> = {\r\n  [ResourceType.Wood]: '#8B4513',      // Marron (bois)\r\n  [ResourceType.Brick]: '#CD5C5C',     // Rouge brique\r\n  [ResourceType.Wheat]: '#FFD700',     // Or (bl\u00E9)\r\n  [ResourceType.Sheep]: '#90EE90',     // Vert clair (mouton)\r\n  [ResourceType.Ore]: '#708090',       // Gris ardoise (minerai)\r\n  [ResourceType.Desert]: '#F4A460',   // Sable (d\u00E9sert)\r\n  [ResourceType.Water]: '#4169E1',     // Bleu royal (eau)\r\n};\r\n\r\n/**\r\n * Renderer pour afficher une GameMap sur un canvas HTML5.\r\n */\r\nexport class HexMapRenderer {\r\n  private canvas: HTMLCanvasElement;\r\n  private ctx: CanvasRenderingContext2D;\r\n\r\n  constructor(canvas: HTMLCanvasElement) {\r\n    this.canvas = canvas;\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new Error('Impossible d\\'obtenir le contexte 2D du canvas');\r\n    }\r\n    this.ctx = context;\r\n  }\r\n\r\n  /**\r\n   * Dessine la carte compl\u00E8te sur le canvas.\r\n   * @param gameMap - La carte \u00E0 dessiner\r\n   */\r\n  render(gameMap: GameMap): void {\r\n    // Effacer le canvas\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    // Calculer les dimensions de la carte\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n\r\n    if (allHexes.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Trouver les limites de la carte\r\n    let minQ = Infinity;\r\n    let maxQ = -Infinity;\r\n    let minR = Infinity;\r\n    let maxR = -Infinity;\r\n\r\n    for (const hex of allHexes) {\r\n      minQ = Math.min(minQ, hex.coord.q);\r\n      maxQ = Math.max(maxQ, hex.coord.q);\r\n      minR = Math.min(minR, hex.coord.r);\r\n      maxR = Math.max(maxR, hex.coord.r);\r\n    }\r\n\r\n    // Calculer la taille des hexagones pour que la carte tienne dans le canvas\r\n    const hexSize = this.calculateHexSize(minQ, maxQ, minR, maxR);\r\n    \r\n    // Calculer le centre de la carte en coordonn\u00E9es hexagonales\r\n    const centerQ = (minQ + maxQ) / 2;\r\n    const centerR = (minR + maxR) / 2;\r\n    \r\n    // Calculer les offsets pour centrer la carte\r\n    const offsetX = this.canvas.width / 2 - Math.sqrt(3) * (centerQ + centerR / 2) * hexSize;\r\n    const offsetY = this.canvas.height / 2 - (3 / 2) * centerR * hexSize;\r\n\r\n    const config: RenderConfig = {\r\n      hexSize,\r\n      offsetX,\r\n      offsetY,\r\n    };\r\n\r\n    // Dessiner tous les hexagones\r\n    for (const hex of allHexes) {\r\n      this.drawHex(hex, gameMap, config);\r\n    }\r\n\r\n    // Dessiner les villes sur leurs sommets\r\n    this.drawCities(gameMap, config);\r\n  }\r\n\r\n  /**\r\n   * Calcule la taille optimale des hexagones pour que la carte tienne dans le canvas.\r\n   */\r\n  private calculateHexSize(minQ: number, maxQ: number, minR: number, maxR: number): number {\r\n    const width = maxQ - minQ + 1;\r\n    const height = maxR - minR + 1;\r\n\r\n    // Dimensions approximatives d'un hexagone en coordonn\u00E9es axiales\r\n    // Largeur: sqrt(3) * size, Hauteur: 2 * size\r\n    const hexWidth = Math.sqrt(3);\r\n    const hexHeight = 2;\r\n\r\n    // Calculer la taille maximale possible\r\n    const maxWidth = (this.canvas.width * 0.9) / (width * hexWidth);\r\n    const maxHeight = (this.canvas.height * 0.9) / (height * hexHeight);\r\n\r\n    return Math.min(maxWidth, maxHeight, 40); // Limiter \u00E0 40px max\r\n  }\r\n\r\n  /**\r\n   * Dessine un hexagone sur le canvas.\r\n   */\r\n  private drawHex(hex: Hex, gameMap: GameMap, config: RenderConfig): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const coord = hex.coord;\r\n\r\n    // Convertir les coordonn\u00E9es axiales en coordonn\u00E9es pixel\r\n    // Formule: x = sqrt(3) * (q + r/2) * size\r\n    //          y = 3/2 * r * size\r\n    const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n    const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n\r\n    // Obtenir la ressource de cet hexagone\r\n    const resource = gameMap.getResource(coord) || ResourceType.Desert;\r\n    const color = RESOURCE_COLORS[resource] || '#CCCCCC';\r\n\r\n    // Dessiner l'hexagone avec une rotation de 30\u00B0 (pointy-top)\r\n    // Rotation de 30\u00B0 = \u03C0/6 radians pour passer de flat-top \u00E0 pointy-top\r\n    this.ctx.beginPath();\r\n    for (let i = 0; i < 6; i++) {\r\n      const angle = (Math.PI / 3) * i + Math.PI / 6;\r\n      const hx = x + hexSize * Math.cos(angle) * 0.9;\r\n      const hy = y + hexSize * Math.sin(angle) * 0.9;\r\n      if (i === 0) {\r\n        this.ctx.moveTo(hx, hy);\r\n      } else {\r\n        this.ctx.lineTo(hx, hy);\r\n      }\r\n    }\r\n    this.ctx.closePath();\r\n\r\n    // Remplir avec la couleur de la ressource\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.fill();\r\n\r\n    // Dessiner le contour\r\n    this.ctx.strokeStyle = '#000000';\r\n    this.ctx.lineWidth = 1;\r\n    this.ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Dessine les villes sur leurs sommets.\r\n   */\r\n  private drawCities(gameMap: GameMap, config: RenderConfig): void {\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n\r\n    // Parcourir tous les hexagones pour trouver leurs vertices\r\n    // Utiliser un Set pour \u00E9viter les doublons\r\n    const processedVertices = new Set<string>();\r\n\r\n    for (const hex of allHexes) {\r\n      const vertices = grid.getVerticesForHex(hex.coord);\r\n      for (const vertex of vertices) {\r\n        const vertexKey = vertex.hashCode();\r\n        if (!processedVertices.has(vertexKey)) {\r\n          processedVertices.add(vertexKey);\r\n          \r\n          // V\u00E9rifier si ce vertex a une ville en utilisant le m\u00EAme vertex retourn\u00E9 par la grille\r\n          // Cela garantit que le hashCode correspond\r\n          if (gameMap.hasCity(vertex)) {\r\n            this.drawCity(vertex, config);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Debug: V\u00E9rifier tous les vertices pour s'assurer qu'on ne manque rien\r\n    // Cela peut aider \u00E0 identifier les villes non trouv\u00E9es\r\n    const allVertices = grid.getAllVertices();\r\n    for (const vertex of allVertices) {\r\n      const vertexKey = vertex.hashCode();\r\n      if (gameMap.hasCity(vertex)) {\r\n        // Si on trouve une ville dans getAllVertices mais pas dans drawCities,\r\n        // on la dessine quand m\u00EAme\r\n        if (!processedVertices.has(vertexKey)) {\r\n          this.drawCity(vertex, config);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine une ville sur un sommet (petit carr\u00E9 noir).\r\n   */\r\n  private drawCity(vertex: Vertex, config: RenderConfig): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const hexes = vertex.getHexes();\r\n\r\n    // Calculer la position du sommet (centre du triangle form\u00E9 par les 3 hexagones)\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n\r\n    for (const coord of hexes) {\r\n      const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n      const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n      sumX += x;\r\n      sumY += y;\r\n    }\r\n\r\n    const centerX = sumX / 3;\r\n    const centerY = sumY / 3;\r\n\r\n    // Dessiner un petit carr\u00E9 noir (taille 6x6 pixels)\r\n    const citySize = 6;\r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.fillRect(\r\n      centerX - citySize / 2,\r\n      centerY - citySize / 2,\r\n      citySize,\r\n      citySize\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Redimensionne le canvas pour qu'il s'adapte \u00E0 la fen\u00EAtre.\r\n   */\r\n  resize(): void {\r\n    // Ajuster la taille du canvas en tenant compte du header et footer\r\n    // Le canvas doit prendre tout l'espace disponible dans main\r\n    const header = document.querySelector('header');\r\n    const footer = document.querySelector('footer');\r\n    const headerHeight = header ? header.offsetHeight : 0;\r\n    const footerHeight = footer ? footer.offsetHeight : 0;\r\n    \r\n    this.canvas.width = window.innerWidth;\r\n    this.canvas.height = window.innerHeight - headerHeight - footerHeight;\r\n  }\r\n}\r\n", "import { MainGame } from './application/MainGame';\r\nimport { HexMapRenderer } from './view/HexMapRenderer';\r\n\r\n/**\r\n * Point d'entr\u00E9e principal de l'application web.\r\n */\r\nfunction main(): void {\r\n  // R\u00E9cup\u00E9rer les \u00E9l\u00E9ments DOM\r\n  const canvas = document.getElementById('map-canvas') as HTMLCanvasElement;\r\n  const regenerateBtn = document.getElementById('regenerate-btn') as HTMLButtonElement;\r\n\r\n  if (!canvas) {\r\n    throw new Error('Canvas introuvable');\r\n  }\r\n\r\n  if (!regenerateBtn) {\r\n    throw new Error('Bouton de r\u00E9g\u00E9n\u00E9ration introuvable');\r\n  }\r\n\r\n  // Cr\u00E9er le jeu principal\r\n  const game = new MainGame();\r\n\r\n  // Cr\u00E9er le renderer\r\n  const renderer = new HexMapRenderer(canvas);\r\n  \r\n  // Redimensionner le canvas au chargement et au redimensionnement\r\n  renderer.resize();\r\n  window.addEventListener('resize', () => {\r\n    renderer.resize();\r\n    const gameMap = game.getGameMap();\r\n    if (gameMap) {\r\n      renderer.render(gameMap);\r\n    }\r\n  });\r\n  \r\n  // Initialiser et afficher la premi\u00E8re carte\r\n  game.initialize();\r\n  const gameMap = game.getGameMap();\r\n  if (gameMap) {\r\n    renderer.render(gameMap);\r\n  }\r\n\r\n  // G\u00E9rer le bouton de r\u00E9g\u00E9n\u00E9ration\r\n  regenerateBtn.addEventListener('click', () => {\r\n    game.regenerate();\r\n    const newGameMap = game.getGameMap();\r\n    if (newGameMap) {\r\n      renderer.render(newGameMap);\r\n    }\r\n  });\r\n}\r\n\r\n// Lancer l'application quand le DOM est pr\u00EAt\r\nif (document.readyState === 'loading') {\r\n  document.addEventListener('DOMContentLoaded', main);\r\n} else {\r\n  main();\r\n}\r\n"],
  "mappings": "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",
  "names": ["gameMap"]
}
