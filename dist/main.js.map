{
  "version": 3,
  "sources": ["../src/model/hex/HexDirection.ts", "../src/model/hex/HexCoord.ts", "../src/model/hex/Hex.ts", "../src/model/hex/Edge.ts", "../src/model/hex/Vertex.ts", "../src/model/hex/HexGrid.ts", "../src/model/map/CivilizationId.ts", "../src/model/city/CityLevel.ts", "../src/model/map/ResourceType.ts", "../src/model/city/BuildingType.ts", "../src/model/city/City.ts", "../src/model/map/GameMap.ts", "../src/controller/util/SeededRNG.ts", "../src/controller/MapGenerator.ts", "../src/controller/MainGameController.ts", "../src/model/game/PlayerResources.ts", "../src/model/game/GameClock.ts", "../src/model/game/GameState.ts", "../src/application/MainGame.ts", "../src/model/game/ResourceHarvest.ts", "../src/controller/ResourceHarvestController.ts", "../src/controller/BuildingProductionController.ts", "../src/model/game/RoadConstruction.ts", "../src/controller/OutpostController.ts", "../src/view/HexMapRenderer.ts", "../src/controller/BuildingController.ts", "../src/view/CityPanelView.ts", "../src/controller/TradeController.ts", "../src/view/TradePanelView.ts", "../src/view/ResourceSprites.ts", "../src/controller/RoadController.ts", "../src/config/version.ts", "../src/main.ts"],
  "sourcesContent": ["/**\r\n * Repr\u00E9sente les six directions possibles dans une grille hexagonale.\r\n * Utilise le syst\u00E8me de coordonn\u00E9es axiales o\u00F9 chaque direction\r\n * correspond \u00E0 un d\u00E9placement dans le plan hexagonal.\r\n */\r\nexport enum HexDirection {\r\n  /** Nord */\r\n  N = 0,\r\n  /** Nord-Est */\r\n  NE = 1,\r\n  /** Sud-Est */\r\n  SE = 2,\r\n  /** Sud */\r\n  S = 3,\r\n  /** Sud-Ouest */\r\n  SW = 4,\r\n  /** Nord-Ouest */\r\n  NW = 5,\r\n}\r\n\r\n/**\r\n * Tableau de toutes les directions dans l'ordre.\r\n */\r\nexport const ALL_DIRECTIONS: readonly HexDirection[] = [\r\n  HexDirection.N,\r\n  HexDirection.NE,\r\n  HexDirection.SE,\r\n  HexDirection.S,\r\n  HexDirection.SW,\r\n  HexDirection.NW,\r\n] as const;\r\n", "import { HexDirection, ALL_DIRECTIONS } from './HexDirection';\r\n\r\n/**\r\n * Syst\u00E8me de coordonn\u00E9es axiales pour les grilles hexagonales.\r\n * \r\n * Dans ce syst\u00E8me, chaque hexagone est identifi\u00E9 par deux coordonn\u00E9es (q, r):\r\n * - q: coordonn\u00E9e colonne (axe horizontal)\r\n * - r: coordonn\u00E9e ligne (axe diagonal)\r\n * \r\n * Les voisins d'un hexagone sont obtenus en ajoutant des d\u00E9placements pr\u00E9d\u00E9finis\r\n * selon la direction choisie. Ce syst\u00E8me est plus simple que les coordonn\u00E9es\r\n * cubiques (q, r, s) car la troisi\u00E8me coordonn\u00E9e peut \u00EAtre d\u00E9riv\u00E9e: s = -q - r\r\n *\r\n */\r\nexport class HexCoord {\r\n  constructor(\r\n    public readonly q: number,\r\n    public readonly r: number\r\n  ) {}\r\n\r\n  /**\r\n   * Retourne la coordonn\u00E9e s (d\u00E9riv\u00E9e) pour compatibilit\u00E9 avec syst\u00E8me cubique.\r\n   * Dans le syst\u00E8me axial, s = -q - r\r\n   */\r\n  get s(): number {\r\n    return -this.q - this.r;\r\n  }\r\n\r\n  /**\r\n   * Retourne les coordonn\u00E9es du voisin dans la direction sp\u00E9cifi\u00E9e.\r\n   * Les d\u00E9placements sont d\u00E9finis pour le syst\u00E8me de coordonn\u00E9es axiales.\r\n   */\r\n  neighbor(direction: HexDirection): HexCoord {\r\n    const deltas: Record<HexDirection, [number, number]> = {\r\n      [HexDirection.N]: [0, -1],\r\n      [HexDirection.NE]: [1, -1],\r\n      [HexDirection.SE]: [1, 0],\r\n      [HexDirection.S]: [0, 1],\r\n      [HexDirection.SW]: [-1, 1],\r\n      [HexDirection.NW]: [-1, 0],\r\n    };\r\n\r\n    const [dq, dr] = deltas[direction];\r\n    return new HexCoord(this.q + dq, this.r + dr);\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les voisins de cet hexagone.\r\n   */\r\n  neighbors(): HexCoord[] {\r\n    return ALL_DIRECTIONS.map((dir) => this.neighbor(dir));\r\n  }\r\n\r\n  /**\r\n   * Calcule la distance entre deux hexagones.\r\n   */\r\n  distanceTo(other: HexCoord): number {\r\n    return (\r\n      (Math.abs(this.q - other.q) +\r\n        Math.abs(this.q + this.r - other.q - other.r) +\r\n        Math.abs(this.r - other.r)) /\r\n      2\r\n    );\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec un autre HexCoord.\r\n   */\r\n  equals(other: HexCoord): boolean {\r\n    return this.q === other.q && this.r === other.r;\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `(${this.q}, ${this.r})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    return `${this.q},${this.r}`;\r\n  }\r\n\r\n  /** S\u00E9rialise la coordonn\u00E9e en [q, r]. */\r\n  serialize(): [number, number] {\r\n    return [this.q, this.r];\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis [q, r]. */\r\n  static deserialize(data: [number, number]): HexCoord {\r\n    return new HexCoord(data[0], data[1]);\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente une cellule hexagonale dans une grille.\r\n *\r\n * Cette classe est volontairement g\u00E9n\u00E9rique et ne contient que des\r\n * informations g\u00E9om\u00E9triques (la coordonn\u00E9e). Toute donn\u00E9e m\u00E9tier\r\n * (ressource, technologie, biome, etc.) doit \u00EAtre port\u00E9e par des\r\n * structures de niveau sup\u00E9rieur qui r\u00E9f\u00E9rencent cette cellule.\r\n */\r\nexport class Hex {\r\n  constructor(public readonly coord: HexCoord) {}\r\n\r\n  /**\r\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec un autre Hex (\u00E9galit\u00E9 structurelle sur la coordonn\u00E9e).\r\n   */\r\n  equals(other: Hex): boolean {\r\n    return this.coord.equals(other.coord);\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Hex(${this.coord.toString()})`;\r\n  }\r\n\r\n  /** S\u00E9rialise l'hexagone (d\u00E9l\u00E8gue \u00E0 la coordonn\u00E9e). */\r\n  serialize(): [number, number] {\r\n    return this.coord.serialize();\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis [q, r]. */\r\n  static deserialize(data: [number, number]): Hex {\r\n    return new Hex(HexCoord.deserialize(data));\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente une ar\u00EAte (edge) entre deux hexagones adjacents.\r\n *\r\n * Cette entit\u00E9 est purement g\u00E9om\u00E9trique et mod\u00E9lise une connexion\r\n * entre deux cellules voisines, quelle que soit la couche m\u00E9tier\r\n * (carte, arbre de technologies, etc.).\r\n *\r\n * Une ar\u00EAte est identifi\u00E9e de mani\u00E8re unique par deux hexagones adjacents.\r\n * L'ordre des hexagones est normalis\u00E9 pour garantir l'unicit\u00E9.\r\n */\r\nexport class Edge {\r\n  private constructor(\r\n    public readonly hex1: HexCoord,\r\n    public readonly hex2: HexCoord\r\n  ) {\r\n    // Validation: les hexagones doivent \u00EAtre adjacents\r\n    const distance = hex1.distanceTo(hex2);\r\n    if (distance !== 1) {\r\n      throw new Error(\r\n        `Les hexagones doivent \u00EAtre adjacents pour former une ar\u00EAte. Distance: ${distance}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e une ar\u00EAte entre deux hexagones adjacents.\r\n   * Normalise l'ordre pour garantir l'unicit\u00E9.\r\n   */\r\n  static create(hex1: HexCoord, hex2: HexCoord): Edge {\r\n    // Normaliser l'ordre pour garantir l'unicit\u00E9\r\n    const normalized = Edge.normalize(hex1, hex2);\r\n    return new Edge(normalized[0], normalized[1]);\r\n  }\r\n\r\n  /**\r\n   * Normalise l'ordre de deux coordonn\u00E9es pour garantir l'unicit\u00E9.\r\n   * Ordre: q d'abord, puis r si \u00E9galit\u00E9.\r\n   */\r\n  private static normalize(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord\r\n  ): [HexCoord, HexCoord] {\r\n    if (\r\n      hex1.q < hex2.q ||\r\n      (hex1.q === hex2.q && hex1.r < hex2.r)\r\n    ) {\r\n      return [hex1, hex2];\r\n    }\r\n    return [hex2, hex1];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cette ar\u00EAte est \u00E9gale \u00E0 une autre.\r\n   */\r\n  equals(other: Edge): boolean {\r\n    return (\r\n      (this.hex1.equals(other.hex1) && this.hex2.equals(other.hex2)) ||\r\n      (this.hex1.equals(other.hex2) && this.hex2.equals(other.hex1))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne les deux hexagones de cette ar\u00EAte.\r\n   */\r\n  getHexes(): [HexCoord, HexCoord] {\r\n    return [this.hex1, this.hex2];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cette ar\u00EAte est adjacente \u00E0 un hexagone donn\u00E9.\r\n   */\r\n  isAdjacentTo(hex: HexCoord): boolean {\r\n    return this.hex1.equals(hex) || this.hex2.equals(hex);\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Edge(${this.hex1.toString()} - ${this.hex2.toString()})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    const normalized = Edge.normalize(this.hex1, this.hex2);\r\n    return `${normalized[0].hashCode()}-${normalized[1].hashCode()}`;\r\n  }\r\n\r\n  /** S\u00E9rialise l'ar\u00EAte en [h1, h2] (chaque hi = [q, r]). */\r\n  serialize(): [[number, number], [number, number]] {\r\n    const [a, b] = this.getHexes();\r\n    return [a.serialize(), b.serialize()];\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis [[q1,r1],[q2,r2]]. */\r\n  static deserialize(data: [[number, number], [number, number]]): Edge {\r\n    return Edge.create(HexCoord.deserialize(data[0]), HexCoord.deserialize(data[1]));\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente un sommet (vertex) partag\u00E9 par plusieurs hexagones.\r\n *\r\n * Un sommet est un point d'intersection g\u00E9om\u00E9trique entre trois cellules\r\n * hexagonales mutuellement adjacentes. Cette abstraction est ind\u00E9pendante\r\n * de tout usage m\u00E9tier (b\u00E2timents, n\u0153uds de technologies, etc.).\r\n *\r\n * Un sommet est identifi\u00E9 de mani\u00E8re unique par trois hexagones adjacents\r\n * qui se rencontrent \u00E0 ce point. L'ordre des hexagones est normalis\u00E9 pour\r\n * garantir l'unicit\u00E9.\r\n */\r\nexport class Vertex {\r\n  private constructor(\r\n    public readonly hex1: HexCoord,\r\n    public readonly hex2: HexCoord,\r\n    public readonly hex3: HexCoord\r\n  ) {\r\n    // Validation: les hexagones doivent former un triangle valide\r\n    if (!Vertex.isValidTriangle(hex1, hex2, hex3)) {\r\n      throw new Error(\r\n        'Les trois hexagones doivent former un triangle valide pour cr\u00E9er un sommet.'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e un sommet \u00E0 partir de trois hexagones adjacents.\r\n   * Normalise l'ordre pour garantir l'unicit\u00E9.\r\n   */\r\n  static create(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): Vertex {\r\n    const normalized = Vertex.normalize(hex1, hex2, hex3);\r\n    return new Vertex(normalized[0], normalized[1], normalized[2]);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si trois hexagones forment un triangle valide (se rencontrent \u00E0 un sommet).\r\n   * Dans une grille hexagonale, trois hexagones se rencontrent \u00E0 un sommet si et seulement si\r\n   * ils sont tous mutuellement adjacents (distance 1 entre chaque paire).\r\n   */\r\n  private static isValidTriangle(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): boolean {\r\n    const d12 = hex1.distanceTo(hex2);\r\n    const d13 = hex1.distanceTo(hex3);\r\n    const d23 = hex2.distanceTo(hex3);\r\n\r\n    // Les trois hexagones doivent \u00EAtre mutuellement adjacents\r\n    return d12 === 1 && d13 === 1 && d23 === 1;\r\n  }\r\n\r\n  /**\r\n   * Normalise l'ordre de trois coordonn\u00E9es pour garantir l'unicit\u00E9.\r\n   * Trie par q puis r.\r\n   */\r\n  private static normalize(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): [HexCoord, HexCoord, HexCoord] {\r\n    const hexes = [hex1, hex2, hex3];\r\n    hexes.sort((a, b) => {\r\n      if (a.q !== b.q) return a.q - b.q;\r\n      return a.r - b.r;\r\n    });\r\n    return [hexes[0], hexes[1], hexes[2]];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si ce sommet est \u00E9gal \u00E0 un autre.\r\n   */\r\n  equals(other: Vertex): boolean {\r\n    const thisHexes = Vertex.normalize(this.hex1, this.hex2, this.hex3);\r\n    const otherHexes = Vertex.normalize(other.hex1, other.hex2, other.hex3);\r\n\r\n    return (\r\n      thisHexes[0].equals(otherHexes[0]) &&\r\n      thisHexes[1].equals(otherHexes[1]) &&\r\n      thisHexes[2].equals(otherHexes[2])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne les trois hexagones de ce sommet.\r\n   */\r\n  getHexes(): [HexCoord, HexCoord, HexCoord] {\r\n    return [this.hex1, this.hex2, this.hex3];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si ce sommet est adjacent \u00E0 un hexagone donn\u00E9.\r\n   */\r\n  isAdjacentTo(hex: HexCoord): boolean {\r\n    return (\r\n      this.hex1.equals(hex) ||\r\n      this.hex2.equals(hex) ||\r\n      this.hex3.equals(hex)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Vertex(${this.hex1.toString()}, ${this.hex2.toString()}, ${this.hex3.toString()})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    const normalized = Vertex.normalize(this.hex1, this.hex2, this.hex3);\r\n    return `${normalized[0].hashCode()}-${normalized[1].hashCode()}-${normalized[2].hashCode()}`;\r\n  }\r\n\r\n  /** S\u00E9rialise le sommet en [h1, h2, h3] (chaque hi = [q, r]). */\r\n  serialize(): [number, number][] {\r\n    return this.getHexes().map((h) => h.serialize());\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis [[q1,r1],[q2,r2],[q3,r3]]. */\r\n  static deserialize(data: [number, number][]): Vertex {\r\n    return Vertex.create(\r\n      HexCoord.deserialize(data[0] as [number, number]),\r\n      HexCoord.deserialize(data[1] as [number, number]),\r\n      HexCoord.deserialize(data[2] as [number, number])\r\n    );\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\nimport { Hex } from './Hex';\r\nimport { Edge } from './Edge';\r\nimport { Vertex } from './Vertex';\r\nimport { HexDirection, ALL_DIRECTIONS } from './HexDirection';\r\n\r\n/**\r\n * Grille hexagonale g\u00E9n\u00E9rique bas\u00E9e sur des coordonn\u00E9es axiales.\r\n *\r\n * Cette grille ne conna\u00EEt que la topologie hexagonale (cellules, ar\u00EAtes,\r\n * sommets, voisinage). Elle peut \u00EAtre utilis\u00E9e aussi bien pour une carte\r\n * de jeu que pour un graphe abstrait (par exemple un arbre de technologies)\r\n * d\u00E8s lors que ces structures reposent sur une g\u00E9om\u00E9trie hexagonale.\r\n *\r\n * Dans ce syst\u00E8me, chaque hexagone est identifi\u00E9 par deux coordonn\u00E9es (q, r):\r\n * - q: coordonn\u00E9e colonne (axe horizontal)\r\n * - r: coordonn\u00E9e ligne (axe diagonal)\r\n *\r\n * Les voisins d'un hexagone sont obtenus en ajoutant des d\u00E9placements pr\u00E9d\u00E9finis\r\n * selon la direction choisie. Ce syst\u00E8me est plus simple que les coordonn\u00E9es\r\n * cubiques (q, r, s) car la troisi\u00E8me coordonn\u00E9e peut \u00EAtre d\u00E9riv\u00E9e: s = -q - r\r\n *\r\n *\r\n * Les ar\u00EAtes (edges) et sommets (vertices) sont calcul\u00E9s automatiquement\r\n * et partag\u00E9s entre les hexagones adjacents pour garantir l'unicit\u00E9.\r\n */\r\nexport class HexGrid {\r\n  private readonly hexMap: Map<string, Hex>;\r\n  private readonly edgeCache: Map<string, Edge>;\r\n  private readonly vertexCache: Map<string, Vertex>;\r\n\r\n  /**\r\n   * Cr\u00E9e une nouvelle grille hexagonale.\r\n   * @param hexes - Tableau d'hexagones \u00E0 ajouter \u00E0 la grille\r\n   */\r\n  constructor(hexes: Hex[] = []) {\r\n    this.hexMap = new Map();\r\n    this.edgeCache = new Map();\r\n    this.vertexCache = new Map();\r\n\r\n    // Ajouter tous les hexagones\r\n    for (const hex of hexes) {\r\n      this.hexMap.set(hex.coord.hashCode(), hex);\r\n    }\r\n\r\n    // Pr\u00E9-calculer les ar\u00EAtes et sommets pour tous les hexagones\r\n    this.precomputeEdgesAndVertices();\r\n  }\r\n\r\n  /**\r\n   * Retourne l'hexagone \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e, ou undefined s'il n'existe pas.\r\n   */\r\n  getHex(coord: HexCoord): Hex | undefined {\r\n    return this.hexMap.get(coord.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les hexagones de la grille.\r\n   */\r\n  getAllHexes(): Hex[] {\r\n    return Array.from(this.hexMap.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne les hexagones voisins de l'hexagone \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e.\r\n   * Ne retourne que les voisins qui existent dans la grille.\r\n   */\r\n  getNeighbors(coord: HexCoord): Hex[] {\r\n    const neighbors: Hex[] = [];\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const neighbor = this.getHex(neighborCoord);\r\n      if (neighbor) {\r\n        neighbors.push(neighbor);\r\n      }\r\n    }\r\n    return neighbors;\r\n  }\r\n\r\n  /**\r\n   * Retourne les coordonn\u00E9es des voisins (m\u00EAme s'ils n'existent pas dans la grille).\r\n   */\r\n  getNeighborCoords(coord: HexCoord): HexCoord[] {\r\n    return coord.neighbors();\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes adjacentes \u00E0 un hexagone donn\u00E9.\r\n   * Une ar\u00EAte est adjacente si elle connecte cet hexagone \u00E0 un voisin.\r\n   */\r\n  getEdges(coord: HexCoord): Edge[] {\r\n    const edges: Edge[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return edges;\r\n    }\r\n\r\n    // Pour chaque direction, cr\u00E9er une ar\u00EAte avec le voisin (s'il existe)\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const neighbor = this.getHex(neighborCoord);\r\n      if (neighbor) {\r\n        const edge = Edge.create(coord, neighborCoord);\r\n        edges.push(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes de la grille.\r\n   */\r\n  getAllEdges(): Edge[] {\r\n    return Array.from(this.edgeCache.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes adjacentes \u00E0 un hexagone donn\u00E9.\r\n   * Inclut toutes les ar\u00EAtes qui touchent cet hexagone, m\u00EAme celles\r\n   * qui ne connectent pas \u00E0 un autre hexagone de la grille.\r\n   */\r\n  getEdgesForHex(coord: HexCoord): Edge[] {\r\n    const edges: Edge[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return edges;\r\n    }\r\n\r\n    // Pour chaque direction, cr\u00E9er une ar\u00EAte avec le voisin\r\n    // M\u00EAme si le voisin n'existe pas dans la grille, l'ar\u00EAte existe\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const edge = Edge.create(coord, neighborCoord);\r\n      const edgeKey = edge.hashCode();\r\n      \r\n      // Utiliser le cache pour \u00E9viter les doublons\r\n      if (!this.edgeCache.has(edgeKey)) {\r\n        this.edgeCache.set(edgeKey, edge);\r\n      }\r\n      edges.push(this.edgeCache.get(edgeKey)!);\r\n    }\r\n\r\n    return edges;\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets adjacents \u00E0 un hexagone donn\u00E9.\r\n   * Un sommet est adjacent s'il est form\u00E9 par cet hexagone et deux de ses voisins.\r\n   */\r\n  getVertices(coord: HexCoord): Vertex[] {\r\n    const vertices: Vertex[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return vertices;\r\n    }\r\n\r\n    // Pour chaque paire de directions cons\u00E9cutives, cr\u00E9er un sommet\r\n    // Un sommet est form\u00E9 par trois hexagones qui se rencontrent\r\n    const directions = ALL_DIRECTIONS;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      const dir1 = directions[i];\r\n      const dir2 = directions[(i + 1) % directions.length];\r\n      \r\n      const neighbor1 = coord.neighbor(dir1);\r\n      const neighbor2 = coord.neighbor(dir2);\r\n      \r\n      // V\u00E9rifier si les deux voisins existent dans la grille\r\n      const hex1 = this.getHex(neighbor1);\r\n      const hex2 = this.getHex(neighbor2);\r\n      \r\n      if (hex1 && hex2) {\r\n        // Les trois hexagones forment un sommet\r\n        try {\r\n          const vertex = Vertex.create(coord, neighbor1, neighbor2);\r\n          const vertexKey = vertex.hashCode();\r\n          \r\n          if (!this.vertexCache.has(vertexKey)) {\r\n            this.vertexCache.set(vertexKey, vertex);\r\n          }\r\n          vertices.push(this.vertexCache.get(vertexKey)!);\r\n        } catch (e) {\r\n          // Ignorer si le sommet n'est pas valide\r\n        }\r\n      }\r\n    }\r\n\r\n    return vertices;\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets de la grille.\r\n   */\r\n  getAllVertices(): Vertex[] {\r\n    return Array.from(this.vertexCache.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets qui touchent un hexagone donn\u00E9.\r\n   * Inclut les sommets m\u00EAme si certains voisins n'existent pas dans la grille.\r\n   */\r\n  getVerticesForHex(coord: HexCoord): Vertex[] {\r\n    const vertices: Vertex[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return vertices;\r\n    }\r\n\r\n    // Pour chaque paire de directions cons\u00E9cutives, cr\u00E9er un sommet\r\n    const directions = ALL_DIRECTIONS;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      const dir1 = directions[i];\r\n      const dir2 = directions[(i + 1) % directions.length];\r\n      \r\n      const neighbor1 = coord.neighbor(dir1);\r\n      const neighbor2 = coord.neighbor(dir2);\r\n      \r\n      // Cr\u00E9er le sommet m\u00EAme si les voisins n'existent pas dans la grille\r\n      try {\r\n        const vertex = Vertex.create(coord, neighbor1, neighbor2);\r\n        const vertexKey = vertex.hashCode();\r\n        \r\n        if (!this.vertexCache.has(vertexKey)) {\r\n          this.vertexCache.set(vertexKey, vertex);\r\n        }\r\n        vertices.push(this.vertexCache.get(vertexKey)!);\r\n      } catch (e) {\r\n        // Ignorer si le sommet n'est pas valide\r\n      }\r\n    }\r\n\r\n    return vertices;\r\n  }\r\n\r\n  /**\r\n   * Pr\u00E9-calcule toutes les ar\u00EAtes et sommets pour optimiser les recherches.\r\n   */\r\n  private precomputeEdgesAndVertices(): void {\r\n    // Calculer toutes les ar\u00EAtes\r\n    for (const hex of this.hexMap.values()) {\r\n      this.getEdgesForHex(hex.coord);\r\n    }\r\n\r\n    // Calculer tous les sommets\r\n    for (const hex of this.hexMap.values()) {\r\n      this.getVerticesForHex(hex.coord);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne le nombre d'hexagones dans la grille.\r\n   */\r\n  size(): number {\r\n    return this.hexMap.size;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone existe \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e.\r\n   */\r\n  hasHex(coord: HexCoord): boolean {\r\n    return this.hexMap.has(coord.hashCode());\r\n  }\r\n\r\n  /** S\u00E9rialise la grille en { hexes: [coord, ...] }. */\r\n  serialize(): { hexes: [number, number][] } {\r\n    return { hexes: this.getAllHexes().map((h) => h.serialize()) };\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis { hexes }. */\r\n  static deserialize(data: { hexes: [number, number][] }): HexGrid {\r\n    return new HexGrid(data.hexes.map((h) => Hex.deserialize(h)));\r\n  }\r\n}\r\n", "/**\r\n * Identifiant unique d'une civilisation.\r\n * \r\n * Value object immuable qui garantit l'unicit\u00E9 d'une civilisation.\r\n */\r\nexport class CivilizationId {\r\n  private constructor(private readonly value: string) {\r\n    if (!value || value.trim().length === 0) {\r\n      throw new Error('L\\'identifiant de civilisation ne peut pas \u00EAtre vide.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e un identifiant de civilisation.\r\n   * @param value - La valeur unique de l'identifiant\r\n   */\r\n  static create(value: string): CivilizationId {\r\n    return new CivilizationId(value.trim());\r\n  }\r\n\r\n  /**\r\n   * Retourne la valeur de l'identifiant.\r\n   */\r\n  getValue(): string {\r\n    return this.value;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cet identifiant est \u00E9gal \u00E0 un autre.\r\n   */\r\n  equals(other: CivilizationId): boolean {\r\n    return this.value === other.value;\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `CivilizationId(${this.value})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    return this.value;\r\n  }\r\n\r\n  /** S\u00E9rialise l'identifiant (valeur string). */\r\n  serialize(): string {\r\n    return this.value;\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis une cha\u00EEne. */\r\n  static deserialize(data: string): CivilizationId {\r\n    return CivilizationId.create(data);\r\n  }\r\n}\r\n", "/**\r\n * Niveaux de ville disponibles dans le jeu.\r\n * \r\n * Les villes progressent du niveau 0 (avant-poste) au niveau 4 (capitale).\r\n * Une seule capitale est autoris\u00E9e par \u00EEle.\r\n */\r\nexport enum CityLevel {\r\n  /** Avant-poste - Niveau 0 (ville initiale) */\r\n  Outpost = 0,\r\n  /** Colonie - Niveau 1 */\r\n  Colony = 1,\r\n  /** Ville - Niveau 2 */\r\n  Town = 2,\r\n  /** M\u00E9tropole - Niveau 3 */\r\n  Metropolis = 3,\r\n  /** Capitale - Niveau 4 (une seule par \u00EEle) */\r\n  Capital = 4,\r\n}\r\n\r\n/**\r\n * Noms des niveaux de ville en fran\u00E7ais.\r\n */\r\nexport const CITY_LEVEL_NAMES: Record<CityLevel, string> = {\r\n  [CityLevel.Outpost]: 'Avant-poste',\r\n  [CityLevel.Colony]: 'Colonie',\r\n  [CityLevel.Town]: 'Ville',\r\n  [CityLevel.Metropolis]: 'M\u00E9tropole',\r\n  [CityLevel.Capital]: 'Capitale',\r\n};\r\n\r\n/**\r\n * Retourne le nom d'un niveau de ville en fran\u00E7ais.\r\n * @param level - Le niveau de ville\r\n * @returns Le nom en fran\u00E7ais\r\n */\r\nexport function getCityLevelName(level: CityLevel): string {\r\n  return CITY_LEVEL_NAMES[level];\r\n}\r\n\r\n/**\r\n * Retourne le niveau de ville suivant, ou undefined si c'est le niveau maximum.\r\n * @param level - Le niveau actuel\r\n * @returns Le niveau suivant, ou undefined si d\u00E9j\u00E0 au maximum\r\n */\r\nexport function getNextCityLevel(level: CityLevel): CityLevel | undefined {\r\n  if (level === CityLevel.Capital) {\r\n    return undefined;\r\n  }\r\n  return level + 1;\r\n}\r\n\r\n/**\r\n * V\u00E9rifie si un niveau de ville est valide.\r\n * @param level - Le niveau \u00E0 v\u00E9rifier\r\n * @returns true si le niveau est valide (0-4)\r\n */\r\nexport function isValidCityLevel(level: number): level is CityLevel {\r\n  return level >= CityLevel.Outpost && level <= CityLevel.Capital;\r\n}\r\n", "/**\r\n * Types de ressources r\u00E9coltables par les joueurs.\r\n * Note: Les types d'hexagones (comme Desert et Water) sont d\u00E9finis dans HexType.\r\n */\r\nexport enum ResourceType {\r\n  /** Bois */\r\n  Wood = 'Wood',\r\n  /** Brique */\r\n  Brick = 'Brick',\r\n  /** Bl\u00E9 */\r\n  Wheat = 'Wheat',\r\n  /** Mouton */\r\n  Sheep = 'Sheep',\r\n  /** Minerai */\r\n  Ore = 'Ore',\r\n}", "import { ResourceType } from '../map/ResourceType';\nimport { HexType } from '../map/HexType';\n\n/**\n * Types de b\u00E2timents constructibles dans les villes.\n */\nexport enum BuildingType {\n  /** Port maritime - Permet le commerce maritime (3:1), n\u00E9cessite de l'eau. Disponible au niveau Ville (2). */\n  Seaport = 'Seaport',\n  /** March\u00E9 - Permet le commerce (4:1) */\n  Market = 'Market',\n  /** H\u00F4tel de ville - Permet l'am\u00E9lioration de la ville */\n  TownHall = 'TownHall',\n  /** Scierie - Produit du bois */\n  Sawmill = 'Sawmill',\n  /** Briqueterie - Produit de la brique */\n  Brickworks = 'Brickworks',\n  /** Moulin - Produit du bl\u00E9 */\n  Mill = 'Mill',\n  /** Bergerie - Produit du mouton */\n  Sheepfold = 'Sheepfold',\n  /** Mine - Produit du minerai */\n  Mine = 'Mine',\n}\n\n/**\n * Noms des b\u00E2timents en fran\u00E7ais.\n */\nexport const BUILDING_TYPE_NAMES: Record<BuildingType, string> = {\n  [BuildingType.Seaport]: 'Port maritime',\n  [BuildingType.Market]: 'March\u00E9',\n  [BuildingType.TownHall]: 'H\u00F4tel de ville',\n  [BuildingType.Sawmill]: 'Scierie',\n  [BuildingType.Brickworks]: 'Briqueterie',\n  [BuildingType.Mill]: 'Moulin',\n  [BuildingType.Sheepfold]: 'Bergerie',\n  [BuildingType.Mine]: 'Mine',\n};\n\n/**\n * Co\u00FBts de construction des b\u00E2timents.\n */\nexport const BUILDING_COSTS: Record<BuildingType, Map<ResourceType, number>> = {\n  [BuildingType.Seaport]: new Map([\n    [ResourceType.Wood, 5],\n  ]),\n  [BuildingType.Market]: new Map([\n    [ResourceType.Wood, 5],\n  ]),\n  [BuildingType.TownHall]: new Map([\n    [ResourceType.Wood, 5],\n    [ResourceType.Brick, 5],\n    [ResourceType.Ore, 1],\n  ]),\n  [BuildingType.Sawmill]: new Map([\n    [ResourceType.Wood, 3],\n    [ResourceType.Brick, 2],\n  ]),\n  [BuildingType.Brickworks]: new Map([\n    [ResourceType.Wood, 3],\n    [ResourceType.Brick, 2],\n  ]),\n  [BuildingType.Mill]: new Map([\n    [ResourceType.Wood, 3],\n    [ResourceType.Brick, 2],\n  ]),\n  [BuildingType.Sheepfold]: new Map([\n    [ResourceType.Wood, 3],\n    [ResourceType.Brick, 2],\n  ]),\n  [BuildingType.Mine]: new Map([\n    [ResourceType.Wood, 3],\n    [ResourceType.Brick, 2],\n  ]),\n};\n\n/**\n * Retourne le co\u00FBt de construction d'un b\u00E2timent.\n * @param buildingType - Le type de b\u00E2timent\n * @returns Le co\u00FBt sous forme de Map\n */\nexport function getBuildingCost(buildingType: BuildingType): Map<ResourceType, number> {\n  return new Map(BUILDING_COSTS[buildingType]);\n}\n\n/**\n * Retourne le nom d'un type de b\u00E2timent en fran\u00E7ais.\n * @param buildingType - Le type de b\u00E2timent\n * @returns Le nom en fran\u00E7ais\n */\nexport function getBuildingTypeName(buildingType: BuildingType): string {\n  return BUILDING_TYPE_NAMES[buildingType];\n}\n\n/**\n * Retourne tous les types de b\u00E2timents disponibles.\n * @returns Un tableau de tous les types de b\u00E2timents\n */\nexport function getAllBuildingTypes(): BuildingType[] {\n  return Object.values(BuildingType);\n}\n\n/**\n * Retourne les b\u00E2timents de production de ressources (niveau 1).\n * @returns Un tableau des types de b\u00E2timents de production\n */\nexport function getResourceProductionBuildings(): BuildingType[] {\n  return [\n    BuildingType.Sawmill,\n    BuildingType.Brickworks,\n    BuildingType.Mill,\n    BuildingType.Sheepfold,\n    BuildingType.Mine,\n  ];\n}\n\n/**\n * Mapping des b\u00E2timents de production de ressources vers le type d'hex requis.\n * Un b\u00E2timent ne peut \u00EAtre construit que si la ville a au moins un hex adjacent du type requis.\n */\nexport const BUILDING_REQUIRED_HEX_TYPE: Record<BuildingType, HexType | null> = {\n  [BuildingType.Sawmill]: HexType.Wood,\n  [BuildingType.Brickworks]: HexType.Brick,\n  [BuildingType.Mill]: HexType.Wheat,\n  [BuildingType.Sheepfold]: HexType.Sheep,\n  [BuildingType.Mine]: HexType.Ore,\n  [BuildingType.Seaport]: HexType.Water, // N\u00E9cessite de l'eau adjacente\n  [BuildingType.Market]: null, // Pas de contrainte d'hex\n  [BuildingType.TownHall]: null, // Pas de contrainte d'hex\n};\n\n/**\n * Retourne le type d'hex requis pour construire un b\u00E2timent, ou null si aucun requis.\n * @param buildingType - Le type de b\u00E2timent\n * @returns Le type d'hex requis, ou null si aucun\n */\nexport function getRequiredHexType(buildingType: BuildingType): HexType | null {\n  return BUILDING_REQUIRED_HEX_TYPE[buildingType] ?? null;\n}\n\n/**\n * Actions associ\u00E9es aux b\u00E2timents.\n */\nexport enum BuildingAction {\n  /** Commerce - D\u00E9bloqu\u00E9 par le port maritime */\n  Trade = 'Trade',\n  /** Am\u00E9liorer - D\u00E9bloqu\u00E9 par l'h\u00F4tel de ville */\n  Upgrade = 'Upgrade',\n}\n\n/**\n * Retourne l'action associ\u00E9e \u00E0 un b\u00E2timent, ou null si aucune action.\n * @param buildingType - Le type de b\u00E2timent\n * @returns L'action associ\u00E9e, ou null\n */\nexport function getBuildingAction(buildingType: BuildingType): BuildingAction | null {\n  switch (buildingType) {\n    case BuildingType.Seaport:\n    case BuildingType.Market:\n      return BuildingAction.Trade;\n    case BuildingType.TownHall:\n      return BuildingAction.Upgrade;\n    default:\n      return null;\n  }\n}\n\n/**\n * Noms des actions en fran\u00E7ais.\n */\nexport const BUILDING_ACTION_NAMES: Record<BuildingAction, string> = {\n  [BuildingAction.Trade]: 'Commerce',\n  [BuildingAction.Upgrade]: 'Am\u00E9liorer',\n};\n", "import { Vertex } from '../hex/Vertex';\nimport { CivilizationId } from '../map/CivilizationId';\nimport { CityLevel, isValidCityLevel } from './CityLevel';\nimport { BuildingType, getAllBuildingTypes, getResourceProductionBuildings } from './BuildingType';\n\n/** Format s\u00E9rialis\u00E9 d'une ville. */\nexport interface CitySerialized {\n  vertex: [number, number][];\n  owner: string;\n  level: number;\n  buildings: string[];\n  buildingProductionTimes: Record<string, number>;\n}\n\n/**\n * Repr\u00E9sente une ville sur la carte de jeu.\n * \n * Une ville est situ\u00E9e sur un sommet (vertex) et appartient \u00E0 une civilisation.\n * Elle a un niveau qui d\u00E9termine ses capacit\u00E9s et le nombre de b\u00E2timents qu'elle peut construire.\n */\nexport class City {\n  private readonly buildings: BuildingType[] = [];\n  /** Temps de derni\u00E8re production pour chaque b\u00E2timent de ressource (en secondes depuis le d\u00E9but) */\n  private readonly buildingProductionTimes: Map<BuildingType, number> = new Map();\n\n  /**\n   * Cr\u00E9e une nouvelle ville.\n   * @param vertex - Le sommet o\u00F9 se trouve la ville\n   * @param owner - L'identifiant de la civilisation propri\u00E9taire\n   * @param level - Le niveau de la ville (par d\u00E9faut: Outpost)\n   */\n  constructor(\n    public readonly vertex: Vertex,\n    public readonly owner: CivilizationId,\n    public level: CityLevel = CityLevel.Outpost\n  ) {\n    if (!isValidCityLevel(level)) {\n      throw new Error(`Niveau de ville invalide: ${level}. Doit \u00EAtre entre ${CityLevel.Outpost} et ${CityLevel.Capital}.`);\n    }\n  }\n\n  /**\n   * Retourne le nombre maximum de b\u00E2timents qu'une ville de ce niveau peut construire.\n   * @returns Le nombre maximum de b\u00E2timents\n   */\n  getMaxBuildings(): number {\n    // Limite de b\u00E2timents par niveau :\n    // Outpost (0): 1 b\u00E2timent\n    // Colony (1): 2 b\u00E2timents\n    // Town (2): 3 b\u00E2timents\n    // Metropolis (3): 4 b\u00E2timents\n    // Capital (4): 5 b\u00E2timents\n    return (this.level + 1) * 2;\n  }\n\n  /**\n   * Retourne le nombre de b\u00E2timents actuellement construits.\n   * @returns Le nombre de b\u00E2timents construits\n   */\n  getBuildingCount(): number {\n    return this.buildings.length;\n  }\n\n  /**\n   * V\u00E9rifie si la ville peut construire un b\u00E2timent suppl\u00E9mentaire.\n   * @returns true si la ville peut construire un nouveau b\u00E2timent\n   */\n  canBuildBuilding(): boolean {\n    return this.getBuildingCount() < this.getMaxBuildings();\n  }\n\n  /**\n   * Ajoute un b\u00E2timent \u00E0 la ville.\n   * @param buildingType - Le type de b\u00E2timent \u00E0 ajouter\n   * @throws Error si la ville ne peut pas construire de b\u00E2timent suppl\u00E9mentaire\n   * @throws Error si le b\u00E2timent n'est pas constructible dans cette ville\n   * @throws Error si le b\u00E2timent est d\u00E9j\u00E0 construit\n   */\n  addBuilding(buildingType: BuildingType): void {\n    if (!this.canBuildBuilding()) {\n      throw new Error(\n        `La ville ne peut pas construire plus de ${this.getMaxBuildings()} b\u00E2timents (niveau ${this.level}).`\n      );\n    }\n\n    if (!this.canBuildBuildingType(buildingType)) {\n      throw new Error(\n        `Le b\u00E2timent ${buildingType} n'est pas constructible dans cette ville (niveau ${this.level}).`\n      );\n    }\n\n    if (this.hasBuilding(buildingType)) {\n      throw new Error(`Le b\u00E2timent ${buildingType} est d\u00E9j\u00E0 construit dans cette ville.`);\n    }\n\n    this.buildings.push(buildingType);\n    \n    // Si c'est un b\u00E2timent de ressource, initialiser son temps de production\n    // Le temps initial sera d\u00E9fini lors de la construction via setBuildingProductionTime\n  }\n\n  /**\n   * Retourne la liste des b\u00E2timents construits.\n   * @returns Un tableau des types de b\u00E2timents construits\n   */\n  getBuildings(): readonly BuildingType[] {\n    return [...this.buildings];\n  }\n\n  /**\n   * V\u00E9rifie si un type de b\u00E2timent est construit dans la ville.\n   * @param buildingType - Le type de b\u00E2timent \u00E0 v\u00E9rifier\n   * @returns true si le b\u00E2timent est construit\n   */\n  hasBuilding(buildingType: BuildingType): boolean {\n    return this.buildings.includes(buildingType);\n  }\n\n  /**\n   * Retourne la liste des b\u00E2timents constructibles pour cette ville.\n   * Les b\u00E2timents constructibles d\u00E9pendent du niveau de la ville.\n   * @returns Un tableau des types de b\u00E2timents constructibles\n   */\n  getBuildableBuildings(): BuildingType[] {\n    const allBuildings = getAllBuildingTypes();\n    const buildableBuildings: BuildingType[] = [];\n\n    for (const buildingType of allBuildings) {\n      if (this.canBuildBuildingType(buildingType)) {\n        buildableBuildings.push(buildingType);\n      }\n    }\n\n    return buildableBuildings;\n  }\n\n  /**\n   * V\u00E9rifie si un type de b\u00E2timent peut \u00EAtre construit dans cette ville.\n   * @param buildingType - Le type de b\u00E2timent \u00E0 v\u00E9rifier\n   * @returns true si le b\u00E2timent peut \u00EAtre construit\n   */\n  canBuildBuildingType(buildingType: BuildingType): boolean {\n    // V\u00E9rifier si le b\u00E2timent est d\u00E9j\u00E0 construit\n    if (this.hasBuilding(buildingType)) {\n      return false;\n    }\n\n    // V\u00E9rifier si on a encore de la place\n    if (!this.canBuildBuilding()) {\n      return false;\n    }\n\n    // R\u00E8gles de disponibilit\u00E9 selon le niveau de la ville\n    switch (buildingType) {\n      case BuildingType.Seaport:\n        return this.level >= CityLevel.Town; // Niveau 2 (Ville)\n      case BuildingType.Market:\n      case BuildingType.TownHall:\n        return this.level >= CityLevel.Outpost;\n\n      case BuildingType.Sawmill:\n      case BuildingType.Brickworks:\n      case BuildingType.Mill:\n      case BuildingType.Sheepfold:\n      case BuildingType.Mine:\n        // B\u00E2timents de production de ressources disponibles \u00E0 partir du niveau Colony (1)\n        return this.level >= CityLevel.Colony;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * V\u00E9rifie si la ville peut \u00EAtre am\u00E9lior\u00E9e au niveau suivant.\n   * @returns true si la ville peut \u00EAtre am\u00E9lior\u00E9e\n   */\n  canUpgrade(): boolean {\n    return this.level < CityLevel.Capital;\n  }\n\n  /**\n   * Am\u00E9liore la ville au niveau suivant.\n   * @throws Error si la ville ne peut pas \u00EAtre am\u00E9lior\u00E9e (d\u00E9j\u00E0 au niveau maximum)\n   */\n  upgrade(): void {\n    if (!this.canUpgrade()) {\n      throw new Error(`La ville ne peut pas \u00EAtre am\u00E9lior\u00E9e au-del\u00E0 du niveau ${CityLevel.Capital} (Capitale).`);\n    }\n    this.level = this.level + 1;\n  }\n\n  /**\n   * V\u00E9rifie si la ville a un h\u00F4tel de ville (requis pour l'am\u00E9lioration).\n   * @returns true si la ville a un h\u00F4tel de ville\n   */\n  hasCityHall(): boolean {\n    return this.hasBuilding(BuildingType.TownHall);\n  }\n\n  /**\n   * Enregistre le temps de derni\u00E8re production pour un b\u00E2timent de ressource.\n   * @param buildingType - Le type de b\u00E2timent\n   * @param timeSeconds - Le temps en secondes\n   */\n  setBuildingProductionTime(buildingType: BuildingType, timeSeconds: number): void {\n    // V\u00E9rifier que c'est un b\u00E2timent de ressource\n    const resourceBuildings = getResourceProductionBuildings();\n    if (!resourceBuildings.includes(buildingType)) {\n      throw new Error(`Le b\u00E2timent ${buildingType} n'est pas un b\u00E2timent de production de ressources.`);\n    }\n    \n    // V\u00E9rifier que le b\u00E2timent est construit\n    if (!this.hasBuilding(buildingType)) {\n      throw new Error(`Le b\u00E2timent ${buildingType} n'est pas construit dans cette ville.`);\n    }\n    \n    this.buildingProductionTimes.set(buildingType, timeSeconds);\n  }\n\n  /**\n   * Retourne le temps de derni\u00E8re production d'un b\u00E2timent de ressource.\n   * @param buildingType - Le type de b\u00E2timent\n   * @returns Le temps de derni\u00E8re production en secondes, ou undefined si jamais produit\n   */\n  getBuildingProductionTime(buildingType: BuildingType): number | undefined {\n    return this.buildingProductionTimes.get(buildingType);\n  }\n\n  /**\n   * Met \u00E0 jour le temps de derni\u00E8re production apr\u00E8s une production r\u00E9ussie.\n   * Le nouveau temps est calcul\u00E9 comme : ancien temps + intervalle de production.\n   * @param buildingType - Le type de b\u00E2timent\n   * @param newTimeSeconds - Le nouveau temps (ancien temps + intervalle)\n   */\n  updateBuildingProductionTime(buildingType: BuildingType, newTimeSeconds: number): void {\n    this.setBuildingProductionTime(buildingType, newTimeSeconds);\n  }\n\n  /**\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec une autre ville (bas\u00E9 sur le vertex).\n   */\n  equals(other: City): boolean {\n    return this.vertex.equals(other.vertex);\n  }\n\n  /**\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\n   */\n  toString(): string {\n    return `City(vertex=${this.vertex.toString()}, level=${this.level}, owner=${this.owner.toString()})`;\n  }\n\n  /** S\u00E9rialise la ville (vertex, owner, level, buildings, buildingProductionTimes). */\n  serialize(): CitySerialized {\n    const bpt: Record<string, number> = {};\n    for (const bt of getResourceProductionBuildings()) {\n      if (this.hasBuilding(bt)) {\n        const t = this.getBuildingProductionTime(bt);\n        if (t !== undefined) bpt[bt] = t;\n      }\n    }\n    return {\n      vertex: this.vertex.serialize(),\n      owner: this.owner.serialize(),\n      level: this.level,\n      buildings: [...this.getBuildings()],\n      buildingProductionTimes: bpt,\n    };\n  }\n}\n", "import { HexGrid } from '../hex/HexGrid';\nimport { Hex } from '../hex/Hex';\nimport { HexCoord } from '../hex/HexCoord';\nimport { Edge } from '../hex/Edge';\nimport { Vertex } from '../hex/Vertex';\nimport { HexType } from './HexType';\nimport { CivilizationId } from './CivilizationId';\nimport { City, CitySerialized } from '../city/City';\nimport { CityLevel } from '../city/CityLevel';\nimport { BuildingType } from '../city/BuildingType';\n\n/**\n * Carte de jeu construite sur une grille hexagonale.\n * \n * G\u00E8re les types d'hexagones, les villes sur les sommets,\n * et les routes sur les ar\u00EAtes. D\u00E9termine la visibilit\u00E9 des hexagones\n * en fonction de la pr\u00E9sence de routes adjacentes.\n * \n * G\u00E8re \u00E9galement la propri\u00E9t\u00E9 des villes et routes par diff\u00E9rentes civilisations.\n */\nexport class GameMap {\n  private readonly hexTypeMap: Map<string, HexType>;\n  private readonly cityMap: Map<string, City>;\n  private readonly roads: Set<string>;\n  private readonly registeredCivilizations: Set<string>;\n  private readonly roadOwner: Map<string, CivilizationId>;\n  private readonly roadDistanceToCity: Map<string, number>; // Map<edgeKey, distance>\n\n  /**\n   * Cr\u00E9e une nouvelle carte de jeu \u00E0 partir d'une grille hexagonale.\n   * @param grid - La grille hexagonale sous-jacente\n   */\n  constructor(private readonly grid: HexGrid) {\n    this.hexTypeMap = new Map();\n    this.cityMap = new Map();\n    this.roads = new Set();\n    this.registeredCivilizations = new Set();\n    this.roadOwner = new Map();\n    this.roadDistanceToCity = new Map();\n\n    // Initialiser tous les hexagones \u00E0 Desert par d\u00E9faut\n    for (const hex of grid.getAllHexes()) {\n      this.hexTypeMap.set(hex.coord.hashCode(), HexType.Desert);\n    }\n  }\n\n  /**\n   * Retourne la grille hexagonale sous-jacente.\n   */\n  getGrid(): HexGrid {\n    return this.grid;\n  }\n\n  /**\n   * D\u00E9finit le type d'hexagone pour un hexagone.\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\n   * @param hexType - Le type d'hexagone\n   * @throws Error si l'hexagone n'existe pas dans la grille\n   */\n  setHexType(hex: Hex | HexCoord, hexType: HexType): void {\n    const coord = hex instanceof Hex ? hex.coord : hex;\n    if (!this.grid.hasHex(coord)) {\n      throw new Error(`L'hexagone \u00E0 la coordonn\u00E9e ${coord.toString()} n'existe pas dans la grille.`);\n    }\n    this.hexTypeMap.set(coord.hashCode(), hexType);\n  }\n\n  /**\n   * Retourne le type d'hexagone d'un hexagone.\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\n   * @returns Le type d'hexagone, ou undefined si l'hexagone n'existe pas\n   */\n  getHexType(hex: Hex | HexCoord): HexType | undefined {\n    const coord = hex instanceof Hex ? hex.coord : hex;\n    if (!this.grid.hasHex(coord)) {\n      return undefined;\n    }\n    return this.hexTypeMap.get(coord.hashCode());\n  }\n\n  /**\n   * Enregistre une civilisation dans la carte.\n   * @param civId - L'identifiant de la civilisation\n   */\n  registerCivilization(civId: CivilizationId): void {\n    this.registeredCivilizations.add(civId.hashCode());\n  }\n\n  /**\n   * V\u00E9rifie si une civilisation est enregistr\u00E9e.\n   * @param civId - L'identifiant de la civilisation\n   * @returns true si la civilisation est enregistr\u00E9e\n   */\n  isCivilizationRegistered(civId: CivilizationId): boolean {\n    return this.registeredCivilizations.has(civId.hashCode());\n  }\n\n  /**\n   * Retourne les valeurs (getValue) des civilisations enregistr\u00E9es.\n   * Utilis\u00E9 pour la s\u00E9rialisation.\n   */\n  getRegisteredCivilizationValues(): string[] {\n    return Array.from(this.registeredCivilizations);\n  }\n\n  /**\n   * Ajoute une ville sur un sommet pour une civilisation donn\u00E9e.\n   * La ville est cr\u00E9\u00E9e au niveau Outpost (0) par d\u00E9faut.\n   * @param vertex - Le sommet o\u00F9 placer la ville\n   * @param civId - L'identifiant de la civilisation propri\u00E9taire\n   * @param level - Le niveau initial de la ville (par d\u00E9faut: Outpost)\n   * @throws Error si le sommet n'est pas valide dans la grille\n   * @throws Error si une ville existe d\u00E9j\u00E0 sur ce sommet\n   * @throws Error si la civilisation n'est pas enregistr\u00E9e\n   */\n  addCity(vertex: Vertex, civId: CivilizationId, level: CityLevel = CityLevel.Outpost): void {\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\n    if (!this.isCivilizationRegistered(civId)) {\n      throw new Error(`La civilisation ${civId.toString()} n'est pas enregistr\u00E9e.`);\n    }\n\n    const vertexKey = vertex.hashCode();\n\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une ville sur ce sommet\n    if (this.cityMap.has(vertexKey)) {\n      throw new Error(`Une ville existe d\u00E9j\u00E0 sur le sommet ${vertex.toString()}.`);\n    }\n\n    // V\u00E9rifier que le sommet est valide (au moins un hexagone doit exister)\n    const hexes = vertex.getHexes();\n    const hasValidHex = hexes.some(coord => this.grid.hasHex(coord));\n    \n    if (!hasValidHex) {\n      throw new Error(`Le sommet ${vertex.toString()} n'est pas valide dans la grille.`);\n    }\n    \n    // Cr\u00E9er la ville\n    const city = new City(vertex, civId, level);\n    this.cityMap.set(vertexKey, city);\n    \n    // Recalculer les distances des routes apr\u00E8s l'ajout d'une ville\n    // Cela permet de mettre \u00E0 jour les distances pour tenir compte de la nouvelle ville\n    this.updateRoadDistances(civId);\n  }\n\n  /**\n   * V\u00E9rifie si une ville existe sur un sommet.\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\n   * @returns true si une ville existe sur ce sommet\n   */\n  hasCity(vertex: Vertex): boolean {\n    return this.cityMap.has(vertex.hashCode());\n  }\n\n  /**\n   * Retourne la ville sur un sommet donn\u00E9.\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\n   * @returns La ville, ou undefined s'il n'y a pas de ville sur ce sommet\n   */\n  getCity(vertex: Vertex): City | undefined {\n    return this.cityMap.get(vertex.hashCode());\n  }\n\n  /**\n   * Ajoute une route sur une ar\u00EAte pour une civilisation donn\u00E9e.\n   * @param edge - L'ar\u00EAte o\u00F9 placer la route\n   * @param civId - L'identifiant de la civilisation propri\u00E9taire\n   * @throws Error si l'ar\u00EAte n'est pas valide dans la grille\n   * @throws Error si une route existe d\u00E9j\u00E0 sur cette ar\u00EAte\n   * @throws Error si la civilisation n'est pas enregistr\u00E9e\n   */\n  addRoad(edge: Edge, civId: CivilizationId): void {\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\n    if (!this.isCivilizationRegistered(civId)) {\n      throw new Error(`La civilisation ${civId.toString()} n'est pas enregistr\u00E9e.`);\n    }\n\n    const edgeKey = edge.hashCode();\n\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une route sur cette ar\u00EAte\n    if (this.roads.has(edgeKey)) {\n      throw new Error(`Une route existe d\u00E9j\u00E0 sur l'ar\u00EAte ${edge.toString()}.`);\n    }\n\n    // V\u00E9rifier que l'ar\u00EAte est valide (au moins un hexagone doit exister)\n    const [hex1, hex2] = edge.getHexes();\n    const hasValidHex = this.grid.hasHex(hex1) || this.grid.hasHex(hex2);\n    \n    if (!hasValidHex) {\n      throw new Error(`L'ar\u00EAte ${edge.toString()} n'est pas valide dans la grille.`);\n    }\n    \n    this.roads.add(edgeKey);\n    this.roadOwner.set(edgeKey, civId);\n    \n    // Calculer et mettre \u00E0 jour les distances depuis les villes pour toutes les routes\n    this.updateRoadDistances(civId);\n  }\n\n  /**\n   * Retourne le propri\u00E9taire d'une ville sur un sommet.\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\n   * @returns L'identifiant de la civilisation propri\u00E9taire, ou undefined s'il n'y a pas de ville\n   */\n  getCityOwner(vertex: Vertex): CivilizationId | undefined {\n    const city = this.cityMap.get(vertex.hashCode());\n    return city ? city.owner : undefined;\n  }\n\n  /**\n   * Retourne toutes les villes appartenant \u00E0 une civilisation donn\u00E9e.\n   * @param civId - L'identifiant de la civilisation\n   * @returns Un tableau des villes appartenant \u00E0 cette civilisation\n   */\n  getCitiesByCivilization(civId: CivilizationId): City[] {\n    const cities: City[] = [];\n    for (const city of this.cityMap.values()) {\n      if (city.owner.equals(civId)) {\n        cities.push(city);\n      }\n    }\n    return cities;\n  }\n\n  /**\n   * Retourne le nombre total de villes sur la carte.\n   * @returns Le nombre de villes\n   */\n  getCityCount(): number {\n    return this.cityMap.size;\n  }\n\n  /**\n   * Am\u00E9liore une ville au niveau suivant.\n   * @param vertex - Le sommet o\u00F9 se trouve la ville \u00E0 am\u00E9liorer\n   * @throws Error si aucune ville n'existe sur ce sommet\n   * @throws Error si la ville ne peut pas \u00EAtre am\u00E9lior\u00E9e (d\u00E9j\u00E0 au niveau maximum)\n   * @throws Error si une capitale existe d\u00E9j\u00E0 sur l'\u00EEle et que la ville devient capitale\n   */\n  upgradeCity(vertex: Vertex): void {\n    const city = this.cityMap.get(vertex.hashCode());\n    if (!city) {\n      throw new Error(`Aucune ville n'existe sur le sommet ${vertex.toString()}.`);\n    }\n\n    // V\u00E9rifier si la ville va devenir une capitale\n    if (city.level === CityLevel.Metropolis) {\n      // V\u00E9rifier s'il y a d\u00E9j\u00E0 une capitale sur l'\u00EEle\n      if (this.hasCapital()) {\n        throw new Error('Une seule capitale est autoris\u00E9e par \u00EEle.');\n      }\n    }\n\n    city.upgrade();\n  }\n\n  /**\n   * V\u00E9rifie s'il existe une capitale sur cette carte (\u00EEle).\n   * @returns true s'il existe au moins une capitale\n   */\n  hasCapital(): boolean {\n    for (const city of this.cityMap.values()) {\n      if (city.level === CityLevel.Capital) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Retourne le sommet o\u00F9 se trouve la capitale, s'il y en a une.\n   * @returns Le sommet de la capitale, ou undefined s'il n'y a pas de capitale\n   */\n  getCapital(): Vertex | undefined {\n    for (const city of this.cityMap.values()) {\n      if (city.level === CityLevel.Capital) {\n        return city.vertex;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * V\u00E9rifie si une capitale peut \u00EAtre cr\u00E9\u00E9e sur cette carte (\u00EEle).\n   * @returns true si aucune capitale n'existe d\u00E9j\u00E0\n   */\n  isCapitalAllowed(): boolean {\n    return !this.hasCapital();\n  }\n\n  /**\n   * Retourne le propri\u00E9taire d'une route sur une ar\u00EAte.\n   * @param edge - L'ar\u00EAte \u00E0 v\u00E9rifier\n   * @returns L'identifiant de la civilisation propri\u00E9taire, ou undefined s'il n'y a pas de route\n   */\n  getRoadOwner(edge: Edge): CivilizationId | undefined {\n    return this.roadOwner.get(edge.hashCode());\n  }\n\n  /**\n   * Retourne toutes les villes appartenant \u00E0 une civilisation donn\u00E9e.\n   * @param civId - L'identifiant de la civilisation\n   * @returns Un tableau des villes de cette civilisation\n   */\n  getCitiesForCivilization(civId: CivilizationId): City[] {\n    const cities: City[] = [];\n    const civKey = civId.hashCode();\n\n    // Parcourir toutes les villes pour trouver celles appartenant \u00E0 cette civilisation\n    for (const city of this.cityMap.values()) {\n      if (city.owner.hashCode() === civKey) {\n        cities.push(city);\n      }\n    }\n\n    return cities;\n  }\n\n  /**\n   * Retourne toutes les routes appartenant \u00E0 une civilisation donn\u00E9e.\n   * @param civId - L'identifiant de la civilisation\n   * @returns Un tableau des ar\u00EAtes contenant des routes de cette civilisation\n   */\n  getRoadsForCivilization(civId: CivilizationId): Edge[] {\n    const roads: Edge[] = [];\n    const civKey = civId.hashCode();\n\n    // Parcourir tous les hexagones pour obtenir leurs ar\u00EAtes\n    for (const hex of this.grid.getAllHexes()) {\n      const edges = this.grid.getEdgesForHex(hex.coord);\n      for (const edge of edges) {\n        const owner = this.roadOwner.get(edge.hashCode());\n        if (owner && owner.hashCode() === civKey && !roads.some(e => e.equals(edge))) {\n          roads.push(edge);\n        }\n      }\n    }\n\n    return roads;\n  }\n\n  /**\n   * V\u00E9rifie si une route existe sur une ar\u00EAte.\n   * @param edge - L'ar\u00EAte \u00E0 v\u00E9rifier\n   * @returns true si une route existe sur cette ar\u00EAte\n   */\n  hasRoad(edge: Edge): boolean {\n    return this.roads.has(edge.hashCode());\n  }\n\n  /**\n   * Retourne toutes les routes constructibles pour une civilisation donn\u00E9e.\n   * Une route est constructible si elle touche une ville de la civilisation\n   * ou si elle touche une route existante de la civilisation.\n   * @param civId - L'identifiant de la civilisation\n   * @returns Un tableau des ar\u00EAtes constructibles pour cette civilisation\n   */\n  getBuildableRoadsForCivilization(civId: CivilizationId): Edge[] {\n    const buildableRoads: Edge[] = [];\n    const civKey = civId.hashCode();\n\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\n    if (!this.isCivilizationRegistered(civId)) {\n      return buildableRoads;\n    }\n\n    // Parcourir toutes les ar\u00EAtes de la grille\n    const allEdges = this.grid.getAllEdges();\n    \n    for (const edge of allEdges) {\n      // V\u00E9rifier que les deux hexagones de l'edge existent dans la grille\n      const [hex1, hex2] = edge.getHexes();\n      if (!this.grid.hasHex(hex1) || !this.grid.hasHex(hex2)) {\n        continue; // Ignorer les edges vers des hexagones inexistants\n      }\n\n      // Ignorer les edges entre deux hexagones d'eau (mais autoriser terre-eau)\n      const hex1Type = this.getHexType(hex1);\n      const hex2Type = this.getHexType(hex2);\n      if (hex1Type === HexType.Water && hex2Type === HexType.Water) {\n        continue; // Ignorer les edges entre deux hexagones d'eau\n      }\n\n      // Ignorer les routes d\u00E9j\u00E0 construites\n      if (this.hasRoad(edge)) {\n        continue;\n      }\n\n      // V\u00E9rifier si l'edge touche une ville de la civilisation\n      const vertices = this.getVerticesForEdge(edge);\n      let touchesCity = false;\n      for (const vertex of vertices) {\n        // V\u00E9rifier que tous les hexagones du vertex existent\n        const vertexHexes = vertex.getHexes();\n        const allVertexHexesExist = vertexHexes.every(h => this.grid.hasHex(h));\n        if (!allVertexHexesExist) {\n          continue; // Ignorer les vertices avec des hexagones inexistants\n        }\n        \n        if (this.hasCity(vertex)) {\n          const owner = this.getCityOwner(vertex);\n          if (owner && owner.hashCode() === civKey) {\n            touchesCity = true;\n            break;\n          }\n        }\n      }\n\n      if (touchesCity) {\n        buildableRoads.push(edge);\n        continue;\n      }\n\n      // V\u00E9rifier si l'edge touche une route de la civilisation\n      // Un edge touche une route s'ils partagent un vertex\n      const adjacentEdges = this.getAdjacentEdges(edge);\n      for (const adjacentEdge of adjacentEdges) {\n        // V\u00E9rifier que l'edge adjacent existe vraiment dans la grille\n        const [adjHex1, adjHex2] = adjacentEdge.getHexes();\n        if (!this.grid.hasHex(adjHex1) || !this.grid.hasHex(adjHex2)) {\n          continue;\n        }\n        \n        // Ignorer les edges adjacents entre deux hexagones d'eau (mais autoriser terre-eau)\n        const adjHex1Type = this.getHexType(adjHex1);\n        const adjHex2Type = this.getHexType(adjHex2);\n        if (adjHex1Type === HexType.Water && adjHex2Type === HexType.Water) {\n          continue; // Ignorer les edges adjacents entre deux hexagones d'eau\n        }\n        \n        if (this.hasRoad(adjacentEdge)) {\n          const owner = this.getRoadOwner(adjacentEdge);\n          if (owner && owner.hashCode() === civKey) {\n            buildableRoads.push(edge);\n            break;\n          }\n        }\n      }\n    }\n\n    return buildableRoads;\n  }\n\n  /**\n   * Retourne les edges adjacents \u00E0 un edge donn\u00E9.\n   * Deux edges sont adjacents s'ils partagent un vertex et que tous les hexagones existent dans la grille.\n   * @param edge - L'ar\u00EAte pour laquelle trouver les edges adjacents\n   * @returns Un tableau des edges adjacents \u00E0 cette ar\u00EAte\n   */\n  private getAdjacentEdges(edge: Edge): Edge[] {\n    const adjacentEdges: Edge[] = [];\n    const vertices = this.getVerticesForEdge(edge);\n\n    // Pour chaque vertex adjacent \u00E0 l'edge, obtenir tous les edges qui touchent ce vertex\n    for (const vertex of vertices) {\n      const hexes = vertex.getHexes();\n      \n      // V\u00E9rifier que tous les hexagones du vertex existent dans la grille\n      const allHexesExist = hexes.every(h => this.grid.hasHex(h));\n      if (!allHexesExist) {\n        continue; // Ignorer les vertices avec des hexagones inexistants\n      }\n      \n      // Un vertex est form\u00E9 de 3 hexagones, donc il y a 3 edges possibles entre ces hexagones\n      for (let i = 0; i < hexes.length; i++) {\n        for (let j = i + 1; j < hexes.length; j++) {\n          try {\n            const adjacentEdge = Edge.create(hexes[i], hexes[j]);\n            \n            // V\u00E9rifier que les deux hexagones de l'edge existent dans la grille\n            const [adjHex1, adjHex2] = adjacentEdge.getHexes();\n            if (!this.grid.hasHex(adjHex1) || !this.grid.hasHex(adjHex2)) {\n              continue; // Ignorer les edges avec des hexagones inexistants\n            }\n            \n            // Ignorer les edges adjacents entre deux hexagones d'eau (mais autoriser terre-eau)\n            const adjHex1Type = this.getHexType(adjHex1);\n            const adjHex2Type = this.getHexType(adjHex2);\n            if (adjHex1Type === HexType.Water && adjHex2Type === HexType.Water) {\n              continue; // Ignorer les edges entre deux hexagones d'eau\n            }\n            \n            // Ne pas inclure l'edge original\n            if (!adjacentEdge.equals(edge)) {\n              // \u00C9viter les doublons\n              if (!adjacentEdges.some(e => e.equals(adjacentEdge))) {\n                adjacentEdges.push(adjacentEdge);\n              }\n            }\n          } catch (e) {\n            // Ignorer les edges invalides\n          }\n        }\n      }\n    }\n\n    return adjacentEdges;\n  }\n\n  /**\n   * Retourne les edges qui touchent un vertex donn\u00E9.\n   * Un edge touche un vertex s'il contient deux des trois hexagones qui forment le vertex.\n   * @param vertex - Le vertex pour lequel trouver les edges\n   * @returns Un tableau des edges qui touchent ce vertex\n   */\n  getEdgesForVertex(vertex: Vertex): Edge[] {\n    const edges: Edge[] = [];\n    const hexes = vertex.getHexes();\n    \n    // V\u00E9rifier que tous les hexagones du vertex existent dans la grille\n    const allHexesExist = hexes.every(h => this.grid.hasHex(h));\n    if (!allHexesExist) {\n      return edges; // Retourner vide si les hexagones n'existent pas\n    }\n    \n    // Un vertex est form\u00E9 de 3 hexagones, donc il y a 3 edges possibles entre ces hexagones\n    for (let i = 0; i < hexes.length; i++) {\n      for (let j = i + 1; j < hexes.length; j++) {\n        try {\n          const edge = Edge.create(hexes[i], hexes[j]);\n          \n          // V\u00E9rifier que les deux hexagones de l'edge existent dans la grille\n          const [edgeHex1, edgeHex2] = edge.getHexes();\n          if (!this.grid.hasHex(edgeHex1) || !this.grid.hasHex(edgeHex2)) {\n            continue;\n          }\n          \n          // Ignorer les edges entre deux hexagones d'eau\n          const hex1Type = this.getHexType(edgeHex1);\n          const hex2Type = this.getHexType(edgeHex2);\n          if (hex1Type === HexType.Water && hex2Type === HexType.Water) {\n            continue;\n          }\n          \n          // \u00C9viter les doublons\n          if (!edges.some(e => e.equals(edge))) {\n            edges.push(edge);\n          }\n        } catch (e) {\n          // Ignorer les edges invalides\n        }\n      }\n    }\n    \n    return edges;\n  }\n\n  /**\n   * Retourne les vertices adjacents \u00E0 une ar\u00EAte donn\u00E9e.\n   * Un vertex est adjacent \u00E0 un edge s'il contient les deux hexagones de l'edge.\n   * @param edge - L'ar\u00EAte pour laquelle trouver les vertices adjacents\n   * @returns Un tableau des vertices adjacents \u00E0 cette ar\u00EAte\n   */\n  getVerticesForEdge(edge: Edge): Vertex[] {\n    const vertices: Vertex[] = [];\n    const [hex1, hex2] = edge.getHexes();\n\n    // Obtenir tous les vertices de la grille et filtrer ceux qui contiennent les deux hexagones de l'edge\n    // Un vertex est form\u00E9 de 3 hexagones, donc on cherche ceux qui contiennent hex1 et hex2\n    for (const vertex of this.grid.getAllVertices()) {\n      const hexes = vertex.getHexes();\n      // Un vertex adjacent \u00E0 un edge doit contenir les deux hexagones de l'edge\n      // et tous les 3 hexagones du vertex doivent exister dans la grille\n      const containsHex1 = hexes.some(h => h.equals(hex1));\n      const containsHex2 = hexes.some(h => h.equals(hex2));\n      const allHexesExist = hexes.every(h => this.grid.hasHex(h));\n\n      if (containsHex1 && containsHex2 && allHexesExist) {\n        // \u00C9viter les doublons\n        if (!vertices.some(v => v.equals(vertex))) {\n          vertices.push(vertex);\n        }\n      }\n    }\n\n    return vertices;\n  }\n\n  /**\n   * D\u00E9termine si un hexagone est visible.\n   * \n   * Un hexagone terrestre est visible si au moins un de ses sommets a une ville ou une route connect\u00E9e.\n   * Un hexagone d'eau est visible s'il touche au moins un hexagone terrestre visible.\n   * \n   * @param hex - L'hexagone ou sa coordonn\u00E9e\n   * @returns true si l'hexagone est visible, false sinon\n   */\n  isHexVisible(hex: Hex | HexCoord): boolean {\n    const coord = hex instanceof Hex ? hex.coord : hex;\n    \n    // Si l'hexagone n'existe pas, il n'est pas visible\n    if (!this.grid.hasHex(coord)) {\n      return false;\n    }\n\n    const hexType = this.getHexType(coord);\n    \n    // Si c'est un hexagone d'eau, v\u00E9rifier si un voisin terrestre est visible\n    if (hexType === HexType.Water) {\n      // Obtenir tous les voisins de cet hexagone\n      const neighbors = this.grid.getNeighbors(coord);\n      \n      // V\u00E9rifier si au moins un voisin terrestre (non-Water) est visible\n      for (const neighbor of neighbors) {\n        const neighborType = this.getHexType(neighbor.coord);\n        // Ignorer les hexagones d'eau\n        if (neighborType !== HexType.Water && neighborType !== undefined) {\n          // V\u00E9rifier r\u00E9cursivement si ce voisin terrestre est visible\n          // Mais \u00E9viter la r\u00E9cursion infinie en v\u00E9rifiant directement\n          if (this.isTerrestrialHexVisible(neighbor.coord)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    // Pour les hexagones terrestres, utiliser la logique classique\n    return this.isTerrestrialHexVisible(coord);\n  }\n\n  /**\n   * D\u00E9termine si un hexagone terrestre est visible.\n   * Un hexagone terrestre est visible si au moins un de ses sommets a une ville ou une route connect\u00E9e.\n   * \n   * @param coord - La coordonn\u00E9e de l'hexagone\n   * @returns true si l'hexagone terrestre est visible, false sinon\n   */\n  private isTerrestrialHexVisible(coord: HexCoord): boolean {\n    // Obtenir tous les sommets de cet hexagone\n    const vertices = this.grid.getVerticesForHex(coord);\n    \n    // V\u00E9rifier si au moins un sommet a une ville ou une route connect\u00E9e\n    for (const vertex of vertices) {\n      // V\u00E9rifier si ce vertex a une ville\n      if (this.hasCity(vertex)) {\n        return true;\n      }\n      \n      // V\u00E9rifier si ce vertex a une route connect\u00E9e\n      // Un sommet est form\u00E9 par 3 hexagones, donc il y a 3 ar\u00EAtes qui se rencontrent \u00E0 ce sommet\n      const hexes = vertex.getHexes();\n      \n      // V\u00E9rifier chaque paire d'hexagones pour former une ar\u00EAte\n      // Les 3 ar\u00EAtes possibles: (hex1,hex2), (hex2,hex3), (hex1,hex3)\n      for (let i = 0; i < hexes.length; i++) {\n        for (let j = i + 1; j < hexes.length; j++) {\n          try {\n            const edge = Edge.create(hexes[i], hexes[j]);\n            if (this.hasRoad(edge)) {\n              return true;\n            }\n          } catch (e) {\n            // Ignorer les ar\u00EAtes invalides (non adjacentes)\n          }\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  /**\n   * Retourne la distance d'une route \u00E0 la ville la plus proche de la m\u00EAme civilisation.\n   * @param edge - L'ar\u00EAte de la route\n   * @returns La distance (1 si elle touche une ville, D+1 si elle touche une route de distance D), ou undefined si la route n'existe pas\n   */\n  getRoadDistanceToCity(edge: Edge): number | undefined {\n    return this.roadDistanceToCity.get(edge.hashCode());\n  }\n\n  /**\n   * Calcule la distance d'une route constructible \u00E0 la ville la plus proche.\n   * Cette m\u00E9thode simule la construction de la route et calcule sa distance bas\u00E9e sur les routes existantes.\n   * @param edge - L'ar\u00EAte constructible \u00E0 v\u00E9rifier\n   * @param civId - L'identifiant de la civilisation\n   * @returns La distance calcul\u00E9e (distance minimale + 1), ou undefined si la route ne peut pas \u00EAtre construite\n   */\n  calculateBuildableRoadDistance(edge: Edge, civId: CivilizationId): number | undefined {\n    const civKey = civId.hashCode();\n    \n    // Si l'edge touche directement une ville, la distance est 1\n    const vertices = this.getVerticesForEdge(edge);\n    for (const vertex of vertices) {\n      const vertexHexes = vertex.getHexes();\n      const allVertexHexesExist = vertexHexes.every(h => this.grid.hasHex(h));\n      if (!allVertexHexesExist) {\n        continue;\n      }\n      \n      if (this.hasCity(vertex)) {\n        const owner = this.getCityOwner(vertex);\n        if (owner && owner.hashCode() === civKey) {\n          return 1; // Distance = 1 si la route touche directement une ville\n        }\n      }\n    }\n    \n    // Si l'edge touche une route existante, calculer la distance minimale + 1\n    const adjacentEdges = this.getAdjacentEdges(edge);\n    let minDistance: number | undefined = undefined;\n    \n    for (const adjacentEdge of adjacentEdges) {\n      const [adjHex1, adjHex2] = adjacentEdge.getHexes();\n      if (!this.grid.hasHex(adjHex1) || !this.grid.hasHex(adjHex2)) {\n        continue;\n      }\n      \n      // Ignorer les edges entre deux hexagones d'eau\n      const adjHex1Type = this.getHexType(adjHex1);\n      const adjHex2Type = this.getHexType(adjHex2);\n      if (adjHex1Type === HexType.Water && adjHex2Type === HexType.Water) {\n        continue;\n      }\n      \n      if (this.hasRoad(adjacentEdge)) {\n        const owner = this.getRoadOwner(adjacentEdge);\n        if (owner && owner.hashCode() === civKey) {\n          const adjacentDistance = this.getRoadDistanceToCity(adjacentEdge);\n          if (adjacentDistance !== undefined) {\n            const newDistance = adjacentDistance + 1;\n            if (minDistance === undefined || newDistance < minDistance) {\n              minDistance = newDistance;\n            }\n          }\n        }\n      }\n    }\n    \n    return minDistance;\n  }\n\n  /**\n   * Calcule la distance minimale d'un vertex \u00E0 une ville de la civilisation (en nombre de routes).\n   * Utilise un algorithme BFS depuis les villes.\n   * Un vertex qui touche une route de distance D a lui-m\u00EAme une distance de D.\n   * @param vertex - Le vertex pour lequel calculer la distance\n   * @param civId - L'identifiant de la civilisation\n   * @returns La distance minimale, ou undefined si aucune ville de la civilisation n'est accessible\n   */\n  calculateVertexDistanceToCity(vertex: Vertex, civId: CivilizationId): number | undefined {\n    const civKey = civId.hashCode();\n    \n    // V\u00E9rifier que tous les hexagones du vertex existent\n    const vertexHexes = vertex.getHexes();\n    const allVertexHexesExist = vertexHexes.every(h => this.grid.hasHex(h));\n    if (!allVertexHexesExist) {\n      return undefined;\n    }\n    \n    // Si le vertex a directement une ville de la civilisation, distance = 0\n    if (this.hasCity(vertex)) {\n      const owner = this.getCityOwner(vertex);\n      if (owner && owner.hashCode() === civKey) {\n        return 0;\n      }\n    }\n    \n    // Trouver la distance minimale en v\u00E9rifiant toutes les routes qui touchent ce vertex\n    // Un vertex qui touche une route de distance D a lui-m\u00EAme distance D\n    const edgesForVertex = this.getEdgesForVertex(vertex);\n    let minDistance: number | undefined = undefined;\n    \n    for (const edge of edgesForVertex) {\n      // V\u00E9rifier que la route appartient \u00E0 la civilisation\n      if (!this.hasRoad(edge)) {\n        continue;\n      }\n      \n      const owner = this.getRoadOwner(edge);\n      if (!owner || owner.hashCode() !== civKey) {\n        continue;\n      }\n      \n      // Obtenir la distance de cette route\n      const roadDistance = this.getRoadDistanceToCity(edge);\n      if (roadDistance !== undefined) {\n        // Le vertex a la m\u00EAme distance que la route qu'il touche\n        if (minDistance === undefined || roadDistance < minDistance) {\n          minDistance = roadDistance;\n        }\n      }\n    }\n    \n    return minDistance;\n  }\n\n  /**\n   * Retourne tous les vertices o\u00F9 un avant-poste peut \u00EAtre construit pour une civilisation.\n   * @param civId - L'identifiant de la civilisation\n   * @returns Un tableau des vertices constructibles\n   */\n  getBuildableOutpostVertices(civId: CivilizationId): Vertex[] {\n    const buildableVertices: Vertex[] = [];\n    const civKey = civId.hashCode();\n    \n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\n    if (!this.isCivilizationRegistered(civId)) {\n      return buildableVertices;\n    }\n    \n    // Parcourir tous les vertices de la grille\n    const allVertices = this.grid.getAllVertices();\n    \n    for (const vertex of allVertices) {\n      // V\u00E9rifier que tous les hexagones du vertex existent\n      const vertexHexes = vertex.getHexes();\n      const allVertexHexesExist = vertexHexes.every(h => this.grid.hasHex(h));\n      if (!allVertexHexesExist) {\n        continue;\n      }\n      \n      // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une ville sur ce vertex\n      if (this.hasCity(vertex)) {\n        continue;\n      }\n      \n      // V\u00E9rifier que le vertex touche au moins une route de la civilisation\n      const edgesForVertex = this.getEdgesForVertex(vertex);\n      let touchesRoad = false;\n      for (const edge of edgesForVertex) {\n        if (this.hasRoad(edge)) {\n          const owner = this.getRoadOwner(edge);\n          if (owner && owner.hashCode() === civKey) {\n            touchesRoad = true;\n            break;\n          }\n        }\n      }\n      \n      if (!touchesRoad) {\n        continue;\n      }\n      \n      // V\u00E9rifier que le vertex est \u00E0 au moins 2 routes de distance d'une ville\n      const distance = this.calculateVertexDistanceToCity(vertex, civId);\n      if (distance !== undefined && distance >= 2) {\n        buildableVertices.push(vertex);\n      }\n    }\n    \n    return buildableVertices;\n  }\n\n  /**\n   * Met \u00E0 jour les distances de toutes les routes \u00E0 la ville la plus proche pour une civilisation donn\u00E9e.\n   * Utilise un algorithme BFS pour calculer les distances depuis les villes.\n   * @param civId - L'identifiant de la civilisation\n   */\n  private updateRoadDistances(civId: CivilizationId): void {\n    const civKey = civId.hashCode();\n    \n    // R\u00E9initialiser les distances pour toutes les routes de cette civilisation\n    const civRoads = this.getRoadsForCivilization(civId);\n    for (const road of civRoads) {\n      this.roadDistanceToCity.delete(road.hashCode());\n    }\n\n    // \u00C9tape 1: Trouver toutes les routes qui touchent directement une ville de la civilisation (distance = 1)\n    const queue: Array<{ edge: Edge; distance: number }> = [];\n    const processed = new Set<string>();\n\n    for (const road of civRoads) {\n      const vertices = this.getVerticesForEdge(road);\n      let touchesCity = false;\n      \n      for (const vertex of vertices) {\n        // V\u00E9rifier que tous les hexagones du vertex existent\n        const vertexHexes = vertex.getHexes();\n        const allVertexHexesExist = vertexHexes.every(h => this.grid.hasHex(h));\n        if (!allVertexHexesExist) {\n          continue;\n        }\n        \n        if (this.hasCity(vertex)) {\n          const owner = this.getCityOwner(vertex);\n          if (owner && owner.hashCode() === civKey) {\n            touchesCity = true;\n            break;\n          }\n        }\n      }\n      \n      if (touchesCity) {\n        const roadKey = road.hashCode();\n        this.roadDistanceToCity.set(roadKey, 1);\n        queue.push({ edge: road, distance: 1 });\n        processed.add(roadKey);\n      }\n    }\n\n    // \u00C9tape 2: Propager les distances avec BFS\n    while (queue.length > 0) {\n      const { edge: currentRoad, distance: currentDistance } = queue.shift()!;\n      const adjacentEdges = this.getAdjacentEdges(currentRoad);\n      \n      for (const adjacentEdge of adjacentEdges) {\n        const adjRoadKey = adjacentEdge.hashCode();\n        const adjOwner = this.getRoadOwner(adjacentEdge);\n        \n        // Ignorer les routes qui ne sont pas de la m\u00EAme civilisation ou d\u00E9j\u00E0 trait\u00E9es\n        if (!adjOwner || adjOwner.hashCode() !== civKey || processed.has(adjRoadKey)) {\n          continue;\n        }\n        \n        // V\u00E9rifier que l'edge adjacent existe vraiment dans la grille\n        const [adjHex1, adjHex2] = adjacentEdge.getHexes();\n        if (!this.grid.hasHex(adjHex1) || !this.grid.hasHex(adjHex2)) {\n          continue;\n        }\n        \n        // Ignorer les edges adjacents entre deux hexagones d'eau (mais autoriser terre-eau)\n        const adjHex1Type = this.getHexType(adjHex1);\n        const adjHex2Type = this.getHexType(adjHex2);\n        if (adjHex1Type === HexType.Water && adjHex2Type === HexType.Water) {\n          continue;\n        }\n        \n        const newDistance = currentDistance + 1;\n        const existingDistance = this.roadDistanceToCity.get(adjRoadKey);\n        \n        // Mettre \u00E0 jour seulement si la nouvelle distance est meilleure (plus petite)\n        if (existingDistance === undefined || newDistance < existingDistance) {\n          this.roadDistanceToCity.set(adjRoadKey, newDistance);\n          queue.push({ edge: adjacentEdge, distance: newDistance });\n        }\n        processed.add(adjRoadKey);\n      }\n    }\n  }\n\n  /** Format s\u00E9rialis\u00E9 de la carte (pour GameMap.serialize). */\n  serialize(): {\n    grid: { hexes: [number, number][] };\n    hexTypes: Record<string, string>;\n    civilizations: string[];\n    cities: CitySerialized[];\n    roads: { edge: [[number, number], [number, number]]; owner: string }[];\n  } {\n    const roads: { edge: [[number, number], [number, number]]; owner: string }[] = [];\n    for (const s of this.getRegisteredCivilizationValues()) {\n      const civId = CivilizationId.create(s);\n      for (const edge of this.getRoadsForCivilization(civId)) {\n        roads.push({ edge: edge.serialize(), owner: s });\n      }\n    }\n    return {\n      grid: this.grid.serialize(),\n      hexTypes: Object.fromEntries(this.hexTypeMap),\n      civilizations: this.getRegisteredCivilizationValues(),\n      cities: [...this.cityMap.values()].map((c) => c.serialize()),\n      roads,\n    };\n  }\n\n  /** D\u00E9s\u00E9rialise depuis l'objet produit par serialize. */\n  static deserialize(\n    data: {\n      grid: { hexes: [number, number][] };\n      hexTypes: Record<string, string>;\n      civilizations: string[];\n      cities: CitySerialized[];\n      roads: { edge: [[number, number], [number, number]]; owner: string }[];\n    }\n  ): GameMap {\n    const grid = HexGrid.deserialize(data.grid);\n    const map = new GameMap(grid);\n    for (const [key, type] of Object.entries(data.hexTypes)) {\n      const [q, r] = key.split(',').map(Number);\n      map.setHexType(HexCoord.deserialize([q, r]), type as HexType);\n    }\n    for (const s of data.civilizations) {\n      map.registerCivilization(CivilizationId.deserialize(s));\n    }\n    for (const c of data.cities) {\n      const v = Vertex.deserialize(c.vertex);\n      const owner = CivilizationId.deserialize(c.owner);\n      map.addCity(v, owner, c.level as CityLevel);\n      const city = map.getCity(v)!;\n      for (const b of c.buildings) {\n        city.addBuilding(b as BuildingType);\n      }\n      for (const [bt, time] of Object.entries(c.buildingProductionTimes)) {\n        city.setBuildingProductionTime(bt as BuildingType, time);\n      }\n    }\n    for (const r of data.roads) {\n      map.addRoad(Edge.deserialize(r.edge), CivilizationId.deserialize(r.owner));\n    }\n    return map;\n  }\n}", "/**\r\n * G\u00E9n\u00E9rateur de nombres al\u00E9atoires seed\u00E9 simple.\r\n * \r\n * Impl\u00E9mentation d'un Linear Congruential Generator (LCG)\r\n * pour une g\u00E9n\u00E9ration al\u00E9atoire d\u00E9terministe et reproductible.\r\n * \r\n * Formule: next = (a * current + c) mod m\r\n * Param\u00E8tres: a = 1664525, c = 1013904223, m = 2^32\r\n */\r\nexport class SeededRNG {\r\n  private state: number;\r\n\r\n  /**\r\n   * Cr\u00E9e un nouveau g\u00E9n\u00E9rateur avec une seed initiale.\r\n   * @param seed - La seed initiale\r\n   */\r\n  constructor(seed: number) {\r\n    // Convertir en entier non sign\u00E9 32 bits\r\n    this.state = seed >>> 0;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re le prochain nombre al\u00E9atoire entre 0 (inclus) et 1 (exclus).\r\n   * @returns Un nombre al\u00E9atoire entre 0 et 1\r\n   */\r\n  next(): number {\r\n    // LCG: (a * state + c) mod m\r\n    // Param\u00E8tres de Borland C/C++ (utilis\u00E9s pour leur simplicit\u00E9 et qualit\u00E9)\r\n    this.state = (this.state * 1664525 + 1013904223) >>> 0;\r\n    // Normaliser \u00E0 [0, 1)\r\n    return (this.state >>> 0) / 0x100000000;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un nombre entier al\u00E9atoire entre min (inclus) et max (exclus).\r\n   * @param min - Borne inf\u00E9rieure (inclus)\r\n   * @param max - Borne sup\u00E9rieure (exclus)\r\n   * @returns Un entier al\u00E9atoire dans l'intervalle [min, max)\r\n   */\r\n  nextInt(min: number, max: number): number {\r\n    if (min >= max) {\r\n      throw new Error(`min (${min}) doit \u00EAtre strictement inf\u00E9rieur \u00E0 max (${max})`);\r\n    }\r\n    const range = max - min;\r\n    return min + Math.floor(this.next() * range);\r\n  }\r\n\r\n  /**\r\n   * S\u00E9lectionne un \u00E9l\u00E9ment al\u00E9atoire dans un tableau.\r\n   * @param array - Le tableau source\r\n   * @returns Un \u00E9l\u00E9ment du tableau, ou undefined si le tableau est vide\r\n   */\r\n  pick<T>(array: T[]): T | undefined {\r\n    if (array.length === 0) {\r\n      return undefined;\r\n    }\r\n    const index = this.nextInt(0, array.length);\r\n    return array[index];\r\n  }\r\n\r\n  /**\r\n   * M\u00E9lange un tableau de mani\u00E8re al\u00E9atoire (algorithme de Fisher-Yates).\r\n   * Modifie le tableau en place.\r\n   * @param array - Le tableau \u00E0 m\u00E9langer\r\n   */\r\n  shuffle<T>(array: T[]): void {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = this.nextInt(0, i + 1);\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne l'\u00E9tat actuel du g\u00E9n\u00E9rateur (utile pour les tests).\r\n   */\r\n  getState(): number {\r\n    return this.state;\r\n  }\r\n}\r\n", "import { HexGrid } from '../model/hex/HexGrid';\r\nimport { Hex } from '../model/hex/Hex';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { HexDirection, ALL_DIRECTIONS } from '../model/hex/HexDirection';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { HexType } from '../model/map/HexType';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { SeededRNG } from './util/SeededRNG';\r\n\r\n/**\r\n * Configuration pour la g\u00E9n\u00E9ration d'une carte.\r\n */\r\nexport interface MapGeneratorConfig {\r\n  /** Distribution des hexagones : nombre d'hexagones par type d'hexagone */\r\n  resourceDistribution: Map<HexType, number>;\r\n  /** Liste des civilisations (au moins une requise) */\r\n  civilizations: CivilizationId[];\r\n  /** Seed pour la g\u00E9n\u00E9ration d\u00E9terministe */\r\n  seed: number;\r\n}\r\n\r\n/**\r\n * G\u00E9n\u00E8re une GameMap selon des r\u00E8gles configurables.\r\n * \r\n * Cette classe appartient \u00E0 la couche Controller et agit comme une factory\r\n * pour cr\u00E9er des GameMap avec une structure et des ressources pr\u00E9d\u00E9termin\u00E9es.\r\n */\r\nexport class MapGenerator {\r\n  /**\r\n   * G\u00E9n\u00E8re une nouvelle GameMap selon la configuration fournie.\r\n   * \r\n   * @param config - Configuration de g\u00E9n\u00E9ration\r\n   * @returns Une GameMap compl\u00E8tement initialis\u00E9e avec ressources assign\u00E9es\r\n   * @throws Error si la configuration est invalide\r\n   */\r\n  generate(config: MapGeneratorConfig): GameMap {\r\n    this.validateConfig(config);\r\n\r\n    const rng = new SeededRNG(config.seed);\r\n    \r\n    // G\u00E9n\u00E9rer d'abord les hexagones terrestres (avec identification de Bois et Argile)\r\n    const { hexes: terrestrialHexes, woodCoord, brickCoord } = this.generateTerrestrialHexes(config, rng);\r\n    \r\n    // Ajouter la couche d'eau autour des hexagones terrestres\r\n    const allHexes = this.addWaterLayer(terrestrialHexes);\r\n    \r\n    // Cr\u00E9er la grille compl\u00E8te avec tous les hexagones (terrestres + eau)\r\n    const hexGrid = new HexGrid(allHexes);\r\n    const gameMap = new GameMap(hexGrid);\r\n\r\n    // Enregistrer les civilisations\r\n    for (const civId of config.civilizations) {\r\n      gameMap.registerCivilization(civId);\r\n    }\r\n\r\n    // Assigner les ressources aux hexagones terrestres\r\n    // Les deux premiers (Bois et Argile) doivent \u00EAtre assign\u00E9s en premier\r\n    this.assignResources(gameMap, terrestrialHexes, config, rng, woodCoord, brickCoord);\r\n\r\n    // Assigner Water \u00E0 tous les hexagones d'eau\r\n    this.assignWaterResources(gameMap, terrestrialHexes);\r\n\r\n    // Ajouter la ville initiale sur le vertex bois-argile-eau pour la premi\u00E8re civilisation\r\n    if (config.civilizations.length > 0) {\r\n      this.addInitialCity(gameMap, woodCoord, brickCoord, config.civilizations[0]);\r\n    }\r\n\r\n    return gameMap;\r\n  }\r\n\r\n  /**\r\n   * Valide la configuration de g\u00E9n\u00E9ration.\r\n   * @throws Error si la configuration est invalide\r\n   */\r\n  private validateConfig(config: MapGeneratorConfig): void {\r\n    if (!config.civilizations || config.civilizations.length === 0) {\r\n      throw new Error('Au moins une civilisation est requise.');\r\n    }\r\n\r\n    // Calculer le nombre total d'hexagones requis\r\n    let totalHexes = 0;\r\n    for (const count of config.resourceDistribution.values()) {\r\n      if (count < 0) {\r\n        throw new Error('La distribution de ressources ne peut pas contenir de valeurs n\u00E9gatives.');\r\n      }\r\n      totalHexes += count;\r\n    }\r\n\r\n    if (totalHexes === 0) {\r\n      throw new Error('Au moins un hexagone est requis (distribution de ressources vide).');\r\n    }\r\n\r\n    // V\u00E9rifier que le seed est valide (n'importe quel nombre est valide)\r\n    if (typeof config.seed !== 'number' || !isFinite(config.seed)) {\r\n      throw new Error('Le seed doit \u00EAtre un nombre fini.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re uniquement les hexagones terrestres selon les r\u00E8gles de placement.\r\n   * - Les 2 premiers hexagones sont plac\u00E9s adjacents\r\n   * - Chaque hexagone suivant doit \u00EAtre adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n   * - Apr\u00E8s g\u00E9n\u00E9ration, trouve un vertex au bord (2 hexagones + 1 emplacement eau) pour Bois et Argile\r\n   */\r\n  private generateTerrestrialHexes(config: MapGeneratorConfig, rng: SeededRNG): { hexes: Hex[], woodCoord: HexCoord, brickCoord: HexCoord } {\r\n    const totalHexes = this.calculateTotalHexes(config.resourceDistribution);\r\n    const placedCoords = new Set<string>();\r\n    const hexes: Hex[] = [];\r\n\r\n    // \u00C9tape 1: Placer les 2 premiers hexagones adjacents\r\n    const firstCoord = new HexCoord(0, 0);\r\n    const secondCoord = firstCoord.neighbor(HexDirection.N);\r\n\r\n    hexes.push(new Hex(firstCoord));\r\n    hexes.push(new Hex(secondCoord));\r\n    placedCoords.add(firstCoord.hashCode());\r\n    placedCoords.add(secondCoord.hashCode());\r\n\r\n    // \u00C9tape 2: Placer les hexagones restants\r\n    while (hexes.length < totalHexes) {\r\n      const candidateCoord = this.findValidPlacement(placedCoords, rng);\r\n\r\n      if (!candidateCoord) {\r\n        // Si aucun placement valide n'est trouv\u00E9, cela peut arriver si la distribution\r\n        // demande plus d'hexagones que possible avec les r\u00E8gles donn\u00E9es\r\n        throw new Error(\r\n          `Impossible de placer tous les hexagones requis. ` +\r\n          `Plac\u00E9s: ${hexes.length}/${totalHexes}. ` +\r\n          `V\u00E9rifiez que la distribution de ressources est raisonnable.`\r\n        );\r\n      }\r\n\r\n      hexes.push(new Hex(candidateCoord));\r\n      placedCoords.add(candidateCoord.hashCode());\r\n    }\r\n\r\n    // \u00C9tape 3: Trouver un vertex au bord pour placer Bois et Argile\r\n    // Un vertex au bord = 2 hexagones terrestres adjacents qui ont un voisin commun\r\n    // qui n'est pas encore dans les hexagones terrestres (sera l'eau)\r\n    const borderVertex = this.findBorderVertex(placedCoords, rng);\r\n    if (!borderVertex) {\r\n      throw new Error('Impossible de trouver un vertex au bord pour placer Bois et Argile.');\r\n    }\r\n\r\n    const { woodCoord, brickCoord } = borderVertex;\r\n\r\n    return { hexes, woodCoord, brickCoord };\r\n  }\r\n\r\n  /**\r\n   * Trouve un vertex au bord de la carte terrestre.\r\n   * Un vertex au bord est form\u00E9 par 2 hexagones terrestres adjacents\r\n   * qui ont un voisin commun qui n'est pas terrestre (sera l'eau).\r\n   */\r\n  private findBorderVertex(terrestrialCoords: Set<string>, rng: SeededRNG): { woodCoord: HexCoord, brickCoord: HexCoord } | null {\r\n    const borderCandidates: Array<{ woodCoord: HexCoord, brickCoord: HexCoord }> = [];\r\n\r\n    // Parcourir tous les hexagones terrestres\r\n    for (const coordHash of terrestrialCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const coord1 = new HexCoord(q, r);\r\n\r\n      // V\u00E9rifier tous les voisins de ce hexagone\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const coord2 = coord1.neighbor(direction);\r\n        \r\n        // Si le voisin est aussi terrestre, on a une paire adjacente\r\n        if (terrestrialCoords.has(coord2.hashCode())) {\r\n          // V\u00E9rifier si cette paire a un voisin commun qui n'est pas terrestre\r\n          const neighbors1 = coord1.neighbors();\r\n          const neighbors2 = coord2.neighbors();\r\n          \r\n          // Trouver les voisins communs\r\n          for (const n1 of neighbors1) {\r\n            if (neighbors2.some(n2 => n2.equals(n1))) {\r\n              // Ce voisin commun existe pour les deux hexagones\r\n              // Si ce voisin n'est pas terrestre, c'est un vertex au bord\r\n              if (!terrestrialCoords.has(n1.hashCode())) {\r\n                // On a trouv\u00E9 un vertex au bord : coord1, coord2, et n1 (qui sera l'eau)\r\n                borderCandidates.push({\r\n                  woodCoord: coord1,\r\n                  brickCoord: coord2,\r\n                });\r\n                break; // Pas besoin de continuer pour cette paire\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Choisir un candidat al\u00E9atoire\r\n    if (borderCandidates.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    return rng.pick(borderCandidates) || null;\r\n  }\r\n\r\n  /**\r\n   * Trouve une coordonn\u00E9e valide pour le prochain hexagone.\r\n   * Un placement est valide si le nouvel hexagone est adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s.\r\n   */\r\n  private findValidPlacement(placedCoords: Set<string>, rng: SeededRNG): HexCoord | null {\r\n    // Collecter tous les candidats (voisins des hexagones plac\u00E9s)\r\n    const candidateMap = new Map<string, HexCoord>();\r\n\r\n    // Pour chaque hexagone d\u00E9j\u00E0 plac\u00E9, examiner ses voisins\r\n    for (const coordHash of placedCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const coord = new HexCoord(q, r);\r\n\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const neighbor = coord.neighbor(direction);\r\n        const neighborHash = neighbor.hashCode();\r\n\r\n        // Si ce voisin n'est pas d\u00E9j\u00E0 plac\u00E9, l'ajouter aux candidats\r\n        if (!placedCoords.has(neighborHash)) {\r\n          candidateMap.set(neighborHash, neighbor);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Filtrer les candidats qui sont adjacents \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n    const validCandidates: HexCoord[] = [];\r\n    for (const candidate of candidateMap.values()) {\r\n      // Compter combien de voisins de ce candidat sont d\u00E9j\u00E0 plac\u00E9s\r\n      let adjacentCount = 0;\r\n      for (const dir of ALL_DIRECTIONS) {\r\n        const neighbor = candidate.neighbor(dir);\r\n        if (placedCoords.has(neighbor.hashCode())) {\r\n          adjacentCount++;\r\n        }\r\n      }\r\n\r\n      // Un hexagone doit \u00EAtre adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n      if (adjacentCount >= 2) {\r\n        validCandidates.push(candidate);\r\n      }\r\n    }\r\n\r\n    // Choisir un candidat al\u00E9atoire\r\n    return rng.pick(validCandidates) || null;\r\n  }\r\n\r\n  /**\r\n   * Calcule le nombre total d'hexagones requis.\r\n   */\r\n  private calculateTotalHexes(resourceDistribution: Map<HexType, number>): number {\r\n    let total = 0;\r\n    for (const count of resourceDistribution.values()) {\r\n      total += count;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Ajoute une couche d'hexagones d'eau autour des hexagones terrestres.\r\n   * Retourne tous les hexagones (terrestres + eau).\r\n   */\r\n  private addWaterLayer(terrestrialHexes: Hex[]): Hex[] {\r\n    const terrestrialCoords = new Set<string>();\r\n    const waterCoords = new Set<string>();\r\n\r\n    // Marquer tous les hexagones terrestres\r\n    for (const hex of terrestrialHexes) {\r\n      terrestrialCoords.add(hex.coord.hashCode());\r\n    }\r\n\r\n    // Trouver tous les hexagones d'eau n\u00E9cessaires (voisins des hexagones terrestres)\r\n    for (const hex of terrestrialHexes) {\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const neighborCoord = hex.coord.neighbor(direction);\r\n        const neighborHash = neighborCoord.hashCode();\r\n\r\n        // Si ce voisin n'est pas terrestre, c'est un hexagone d'eau\r\n        if (!terrestrialCoords.has(neighborHash) && !waterCoords.has(neighborHash)) {\r\n          waterCoords.add(neighborHash);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Cr\u00E9er tous les hexagones (terrestres + eau)\r\n    const allHexes: Hex[] = [...terrestrialHexes];\r\n\r\n    // Ajouter tous les hexagones d'eau\r\n    for (const coordHash of waterCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const waterCoord = new HexCoord(q, r);\r\n      allHexes.push(new Hex(waterCoord));\r\n    }\r\n\r\n    return allHexes;\r\n  }\r\n\r\n  /**\r\n   * Assign\u00EB les ressources aux hexagones terrestres selon la distribution.\r\n   * Exclut les hexagones d'eau.\r\n   * Les deux premiers hexagones (Bois et Argile) sont assign\u00E9s en premier.\r\n   */\r\n  private assignResources(\r\n    gameMap: GameMap,\r\n    terrestrialHexes: Hex[],\r\n    config: MapGeneratorConfig,\r\n    rng: SeededRNG,\r\n    woodCoord: HexCoord,\r\n    brickCoord: HexCoord\r\n  ): void {\r\n    // Cr\u00E9er une liste de tous les types d'hexagones \u00E0 assigner (sans l'eau)\r\n    const hexTypesToAssign: HexType[] = [];\r\n    for (const [hexType, count] of config.resourceDistribution.entries()) {\r\n      // Ignorer l'eau dans la distribution (elle sera ajout\u00E9e s\u00E9par\u00E9ment)\r\n      if (hexType === HexType.Water) {\r\n        continue;\r\n      }\r\n      for (let i = 0; i < count; i++) {\r\n        hexTypesToAssign.push(hexType);\r\n      }\r\n    }\r\n\r\n    // S\u00E9parer les hexagones Bois et Argile pour les placer en premier\r\n    const woodIndex = hexTypesToAssign.indexOf(HexType.Wood);\r\n    const brickIndex = hexTypesToAssign.indexOf(HexType.Brick);\r\n    \r\n    // Retirer Bois et Argile de la liste (un exemplaire de chaque)\r\n    if (woodIndex !== -1) {\r\n      hexTypesToAssign.splice(woodIndex, 1);\r\n    }\r\n    if (brickIndex !== -1 && brickIndex !== woodIndex) {\r\n      // Ajuster l'index si Wood a \u00E9t\u00E9 retir\u00E9 avant\r\n      const adjustedBrickIndex = hexTypesToAssign.indexOf(HexType.Brick);\r\n      if (adjustedBrickIndex !== -1) {\r\n        hexTypesToAssign.splice(adjustedBrickIndex, 1);\r\n      }\r\n    }\r\n\r\n    // M\u00E9langer la liste pour un placement al\u00E9atoire\r\n    rng.shuffle(hexTypesToAssign);\r\n\r\n    // Assigner Bois et Argile aux deux premiers hexagones\r\n    gameMap.setHexType(woodCoord, HexType.Wood);\r\n    gameMap.setHexType(brickCoord, HexType.Brick);\r\n\r\n    // Filtrer les hexagones terrestres (exclure Bois et Argile)\r\n    const remainingHexes = terrestrialHexes.filter(\r\n      hex => !hex.coord.equals(woodCoord) && !hex.coord.equals(brickCoord)\r\n    );\r\n\r\n    // M\u00E9langer les hexagones restants\r\n    const shuffledHexes = [...remainingHexes];\r\n    rng.shuffle(shuffledHexes);\r\n\r\n    // Assigner chaque type d'hexagone restant \u00E0 un hexagone\r\n    for (let i = 0; i < hexTypesToAssign.length && i < shuffledHexes.length; i++) {\r\n      const hex = shuffledHexes[i];\r\n      const hexType = hexTypesToAssign[i];\r\n      gameMap.setHexType(hex.coord, hexType);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign\u00EB Water \u00E0 tous les hexagones d'eau de la carte.\r\n   */\r\n  private assignWaterResources(gameMap: GameMap, terrestrialHexes: Hex[]): void {\r\n    const grid = gameMap.getGrid();\r\n    const terrestrialCoords = new Set<string>();\r\n\r\n    // Marquer tous les hexagones terrestres\r\n    for (const hex of terrestrialHexes) {\r\n      terrestrialCoords.add(hex.coord.hashCode());\r\n    }\r\n\r\n    // Parcourir tous les hexagones de la grille et assigner Water \u00E0 ceux qui ne sont pas terrestres\r\n    for (const hex of grid.getAllHexes()) {\r\n      if (!terrestrialCoords.has(hex.coord.hashCode())) {\r\n        gameMap.setHexType(hex.coord, HexType.Water);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ajoute la ville initiale sur le vertex bois-argile-eau.\r\n   */\r\n  private addInitialCity(\r\n    gameMap: GameMap,\r\n    woodCoord: HexCoord,\r\n    brickCoord: HexCoord,\r\n    civId: CivilizationId\r\n  ): void {\r\n    const grid = gameMap.getGrid();\r\n\r\n    // Trouver l'hexagone d'eau qui forme un vertex avec Bois et Argile\r\n    // Un vertex est form\u00E9 par trois hexagones mutuellement adjacents\r\n    // Nous devons trouver un hexagone d'eau adjacent \u00E0 la fois \u00E0 Bois et Argile\r\n    \r\n    // Les deux hexagones sont adjacents (brickCoord est en N de woodCoord)\r\n    // Pour former un vertex, il faut un troisi\u00E8me hexagone adjacent aux deux\r\n    \r\n    // M\u00E9thode 1: Chercher parmi tous les vertices du hexagone Bois\r\n    // Cela garantit que le vertex retourn\u00E9 correspond \u00E0 celui utilis\u00E9 dans la grille\r\n    const woodVertices = grid.getVerticesForHex(woodCoord);\r\n    for (const vertex of woodVertices) {\r\n      const hexes = vertex.getHexes();\r\n      // V\u00E9rifier si ce vertex contient woodCoord, brickCoord et un hexagone d'eau\r\n      const hasWood = hexes.some(h => h.equals(woodCoord));\r\n      const hasBrick = hexes.some(h => h.equals(brickCoord));\r\n      \r\n      if (hasWood && hasBrick) {\r\n        // Trouver l'hexagone qui n'est ni wood ni brick (c'est l'eau)\r\n        const waterHex = hexes.find(h => !h.equals(woodCoord) && !h.equals(brickCoord));\r\n        if (waterHex) {\r\n          const hexType = gameMap.getHexType(waterHex);\r\n          if (hexType === HexType.Water) {\r\n            // Ajouter la ville sur ce vertex (utiliser le vertex retourn\u00E9 par la grille)\r\n            try {\r\n              gameMap.addCity(vertex, civId);\r\n              const hexList = hexes.map(h => `(${h.q},${h.r})`).join(', ');\r\n              console.log(`[MapGenerator] \u2713 Ville cr\u00E9\u00E9e avec succ\u00E8s sur le vertex: [${hexList}]`);\r\n              return;\r\n            } catch (e) {\r\n              // Ignorer les erreurs (ville d\u00E9j\u00E0 pr\u00E9sente ou civilisation non enregistr\u00E9e)\r\n              // mais continuer la recherche\r\n              console.warn(`[MapGenerator] \u00C9chec lors de l'ajout de la ville (m\u00E9thode 1): ${e}`);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // M\u00E9thode 2: Si la m\u00E9thode 1 \u00E9choue, chercher les voisins communs\r\n    // Trouver tous les voisins communs de woodCoord et brickCoord\r\n    const woodNeighbors = woodCoord.neighbors();\r\n    const brickNeighbors = brickCoord.neighbors();\r\n    \r\n    for (const neighborCoord of woodNeighbors) {\r\n      // V\u00E9rifier si ce voisin est aussi voisin de brickCoord\r\n      const isNeighborOfBrick = brickNeighbors.some(n => n.equals(neighborCoord));\r\n      \r\n      if (isNeighborOfBrick) {\r\n        // V\u00E9rifier si cet hexagone existe dans la grille et est de l'eau\r\n        const neighborHex = grid.getHex(neighborCoord);\r\n        if (neighborHex) {\r\n          const hexType = gameMap.getHexType(neighborCoord);\r\n          if (hexType === HexType.Water) {\r\n            // Trouver le vertex correspondant dans la grille (pour utiliser le m\u00EAme instance)\r\n            const vertices = grid.getVerticesForHex(woodCoord);\r\n            for (const vertex of vertices) {\r\n              const hexes = vertex.getHexes();\r\n              if (hexes.some(h => h.equals(woodCoord)) &&\r\n                  hexes.some(h => h.equals(brickCoord)) &&\r\n                  hexes.some(h => h.equals(neighborCoord))) {\r\n                try {\r\n                  gameMap.addCity(vertex, civId);\r\n                  const hexList = hexes.map(h => `(${h.q},${h.r})`).join(', ');\r\n                  console.log(`[MapGenerator] \u2713 Ville cr\u00E9\u00E9e avec succ\u00E8s sur le vertex: [${hexList}]`);\r\n                  return;\r\n                } catch (e) {\r\n                  console.warn(`[MapGenerator] \u00C9chec lors de l'ajout de la ville (m\u00E9thode 2): ${e}`);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Si on arrive ici, la ville n'a pas pu \u00EAtre cr\u00E9\u00E9e\r\n    console.error(`[MapGenerator] \u2717 \u00C9CHEC: Impossible de cr\u00E9er la ville initiale sur le vertex Bois(${woodCoord.q},${woodCoord.r})-Argile(${brickCoord.q},${brickCoord.r})-Eau`);\r\n  }\r\n}\r\n", "import { GameState } from '../model/game/GameState';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { GameClock } from '../model/game/GameClock';\r\n\r\n/**\r\n * Contr\u00F4leur de la partie : expose l'\u00E9tat du jeu et les mises \u00E0 jour (temps).\r\n * Toute la gestion du jeu est d\u00E9l\u00E9gu\u00E9e ici ; MainGame assure NewGame, SaveGame, LoadGame.\r\n */\r\nexport class MainGameController {\r\n  constructor(private gameState: GameState) {}\r\n\r\n  getGameState(): GameState {\r\n    return this.gameState;\r\n  }\r\n\r\n  setGameState(state: GameState): void {\r\n    this.gameState = state;\r\n  }\r\n\r\n  getGameMap(): GameMap | null {\r\n    return this.gameState.getGameMap();\r\n  }\r\n\r\n  getPlayerResources(): PlayerResources {\r\n    return this.gameState.getPlayerResources();\r\n  }\r\n\r\n  getPlayerCivilizationId(): CivilizationId {\r\n    return this.gameState.getPlayerCivilizationId();\r\n  }\r\n\r\n  getGameClock(): GameClock {\r\n    return this.gameState.getGameClock();\r\n  }\r\n\r\n  getSeed(): number | null {\r\n    return this.gameState.getSeed();\r\n  }\r\n\r\n  updateGameTime(timeSeconds: number): void {\r\n    this.gameState.getGameClock().updateTime(timeSeconds);\r\n  }\r\n}\r\n", "import { ResourceType } from '../map/ResourceType';\r\n\r\n/**\r\n * G\u00E8re l'inventaire des ressources du joueur.\r\n * \r\n * Les ressources r\u00E9coltables sont : Wood, Brick, Wheat, Sheep, Ore.\r\n * Les ressources non r\u00E9coltables (Desert, Water) ne sont pas g\u00E9r\u00E9es ici.\r\n */\r\nexport class PlayerResources {\r\n  private resources: Map<ResourceType, number>;\r\n\r\n  /**\r\n   * Cr\u00E9e un inventaire vide.\r\n   */\r\n  constructor() {\r\n    this.resources = new Map();\r\n    // Initialiser toutes les ressources r\u00E9coltables \u00E0 0\r\n    this.resources.set(ResourceType.Wood, 0);\r\n    this.resources.set(ResourceType.Brick, 0);\r\n    this.resources.set(ResourceType.Wheat, 0);\r\n    this.resources.set(ResourceType.Sheep, 0);\r\n    this.resources.set(ResourceType.Ore, 0);\r\n  }\r\n\r\n  /**\r\n   * Ajoute une quantit\u00E9 de ressource \u00E0 l'inventaire.\r\n   * @param resource - Le type de ressource\r\n   * @param amount - La quantit\u00E9 \u00E0 ajouter (doit \u00EAtre positive)\r\n   * @throws Error si la ressource n'est pas r\u00E9coltable\r\n   * @throws Error si la quantit\u00E9 est n\u00E9gative\r\n   */\r\n  addResource(resource: ResourceType, amount: number): void {\r\n    if (!this.isHarvestable(resource)) {\r\n      throw new Error(`La ressource ${resource} n'est pas r\u00E9coltable.`);\r\n    }\r\n    if (amount < 0) {\r\n      throw new Error('La quantit\u00E9 \u00E0 ajouter doit \u00EAtre positive.');\r\n    }\r\n\r\n    const current = this.resources.get(resource) || 0;\r\n    this.resources.set(resource, current + amount);\r\n  }\r\n\r\n  /**\r\n   * Retire une quantit\u00E9 de ressource de l'inventaire.\r\n   * @param resource - Le type de ressource\r\n   * @param amount - La quantit\u00E9 \u00E0 retirer (doit \u00EAtre positive)\r\n   * @throws Error si la ressource n'est pas r\u00E9coltable\r\n   * @throws Error si la quantit\u00E9 est n\u00E9gative\r\n   * @throws Error si l'inventaire n'a pas assez de ressources\r\n   */\r\n  removeResource(resource: ResourceType, amount: number): void {\r\n    if (!this.isHarvestable(resource)) {\r\n      throw new Error(`La ressource ${resource} n'est pas r\u00E9coltable.`);\r\n    }\r\n    if (amount < 0) {\r\n      throw new Error('La quantit\u00E9 \u00E0 retirer doit \u00EAtre positive.');\r\n    }\r\n\r\n    const current = this.resources.get(resource) || 0;\r\n    if (current < amount) {\r\n      throw new Error(\r\n        `Pas assez de ${resource}. Disponible: ${current}, requis: ${amount}.`\r\n      );\r\n    }\r\n\r\n    this.resources.set(resource, current - amount);\r\n  }\r\n\r\n  /**\r\n   * Retourne la quantit\u00E9 d'une ressource dans l'inventaire.\r\n   * @param resource - Le type de ressource\r\n   * @returns La quantit\u00E9 disponible (0 si la ressource n'est pas r\u00E9coltable)\r\n   */\r\n  getResource(resource: ResourceType): number {\r\n    if (!this.isHarvestable(resource)) {\r\n      return 0;\r\n    }\r\n    return this.resources.get(resource) || 0;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si le joueur a assez d'une ressource donn\u00E9e.\r\n   * @param resource - Le type de ressource\r\n   * @param amount - La quantit\u00E9 requise\r\n   * @returns true si l'inventaire contient au moins la quantit\u00E9 requise\r\n   */\r\n  hasEnough(resource: ResourceType, amount: number): boolean {\r\n    if (!this.isHarvestable(resource)) {\r\n      return false;\r\n    }\r\n    return this.getResource(resource) >= amount;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si le joueur peut se permettre un co\u00FBt donn\u00E9.\r\n   * Un co\u00FBt est un objet avec des ressources et leurs quantit\u00E9s requises.\r\n   * @param cost - Un objet Map ou Record avec les ressources et quantit\u00E9s requises\r\n   * @returns true si toutes les ressources requises sont disponibles en quantit\u00E9 suffisante\r\n   */\r\n  canAfford(cost: Map<ResourceType, number> | Record<string, number>): boolean {\r\n    // Convertir Record en Map si n\u00E9cessaire\r\n    const costMap = cost instanceof Map\r\n      ? cost\r\n      : new Map(\r\n          Object.entries(cost).map(([key, value]) => [\r\n            key as ResourceType,\r\n            value as number,\r\n          ])\r\n        );\r\n\r\n    // V\u00E9rifier chaque ressource du co\u00FBt\r\n    for (const [resource, requiredAmount] of costMap.entries()) {\r\n      if (!this.hasEnough(resource, requiredAmount)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Retire les ressources correspondant \u00E0 un co\u00FBt de l'inventaire.\r\n   * @param cost - Un objet Map ou Record avec les ressources et quantit\u00E9s requises\r\n   * @throws Error si le joueur ne peut pas se permettre le co\u00FBt\r\n   */\r\n  payCost(cost: Map<ResourceType, number> | Record<string, number>): void {\r\n    if (!this.canAfford(cost)) {\r\n      throw new Error('Le joueur ne peut pas se permettre ce co\u00FBt.');\r\n    }\r\n\r\n    // Convertir Record en Map si n\u00E9cessaire\r\n    const costMap = cost instanceof Map\r\n      ? cost\r\n      : new Map(\r\n          Object.entries(cost).map(([key, value]) => [\r\n            key as ResourceType,\r\n            value as number,\r\n          ])\r\n        );\r\n\r\n    // Retirer chaque ressource\r\n    for (const [resource, amount] of costMap.entries()) {\r\n      this.removeResource(resource, amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ressources de l'inventaire.\r\n   * @returns Un Map avec toutes les ressources et leurs quantit\u00E9s\r\n   */\r\n  getAllResources(): Map<ResourceType, number> {\r\n    return new Map(this.resources);\r\n  }\r\n\r\n  /**\r\n   * R\u00E9initialise toutes les ressources \u00E0 0.\r\n   */\r\n  clear(): void {\r\n    this.resources.set(ResourceType.Wood, 0);\r\n    this.resources.set(ResourceType.Brick, 0);\r\n    this.resources.set(ResourceType.Wheat, 0);\r\n    this.resources.set(ResourceType.Sheep, 0);\r\n    this.resources.set(ResourceType.Ore, 0);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une ressource est r\u00E9coltable.\r\n   * @param resource - Le type de ressource\r\n   * @returns true si la ressource peut \u00EAtre r\u00E9colt\u00E9e (Wood, Brick, Wheat, Sheep, Ore)\r\n   */\r\n  private isHarvestable(resource: ResourceType): boolean {\r\n    return (\r\n      resource === ResourceType.Wood ||\r\n      resource === ResourceType.Brick ||\r\n      resource === ResourceType.Wheat ||\r\n      resource === ResourceType.Sheep ||\r\n      resource === ResourceType.Ore\r\n    );\r\n  }\r\n\r\n  /** S\u00E9rialise l'inventaire en Record<ResourceType, number>. */\r\n  serialize(): Record<string, number> {\r\n    return Object.fromEntries(this.resources);\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis un objet { [ResourceType]: number }. */\r\n  static deserialize(data: Record<string, number>): PlayerResources {\r\n    const pr = new PlayerResources();\r\n    pr.clear();\r\n    for (const rt of Object.values(ResourceType)) {\r\n      const n = data[rt] ?? 0;\r\n      if (n > 0) pr.addResource(rt, n);\r\n    }\r\n    return pr;\r\n  }\r\n}\r\n", "/**\r\n * Horloge de jeu qui g\u00E8re le temps \u00E9coul\u00E9 en secondes.\r\n * \r\n * Le temps est mis \u00E0 jour par la couche applicative \u00E0 chaque frame,\r\n * permettant une gestion du temps ind\u00E9pendante de la vitesse d'ex\u00E9cution.\r\n */\r\nexport class GameClock {\r\n  private currentTime: number = 0; // Temps courant en secondes\r\n\r\n  /**\r\n   * Met \u00E0 jour le temps courant de l'horloge.\r\n   * Doit \u00EAtre appel\u00E9e par la couche applicative \u00E0 chaque frame.\r\n   * \r\n   * @param nowSeconds - Le temps actuel en secondes (depuis un point de r\u00E9f\u00E9rence, ex: timestamp / 1000)\r\n   */\r\n  updateTime(nowSeconds: number): void {\r\n    this.currentTime = nowSeconds;\r\n  }\r\n\r\n  /**\r\n   * Retourne le temps courant de l'horloge en secondes.\r\n   * @returns Le temps courant en secondes\r\n   */\r\n  getCurrentTime(): number {\r\n    return this.currentTime;\r\n  }\r\n\r\n  /**\r\n   * R\u00E9initialise l'horloge \u00E0 0.\r\n   * Utile pour les tests ou lors d'une nouvelle partie.\r\n   */\r\n  reset(): void {\r\n    this.currentTime = 0;\r\n  }\r\n\r\n  /** S\u00E9rialise l'horloge en { currentTime }. */\r\n  serialize(): { currentTime: number } {\r\n    return { currentTime: this.currentTime };\r\n  }\r\n\r\n  /** D\u00E9s\u00E9rialise depuis { currentTime }. */\r\n  static deserialize(data: { currentTime: number }): GameClock {\r\n    const gc = new GameClock();\r\n    gc.updateTime(data.currentTime);\r\n    return gc;\r\n  }\r\n}\r\n", "import { GameMap } from '../map/GameMap';\r\nimport { CivilizationId } from '../map/CivilizationId';\r\nimport { PlayerResources } from './PlayerResources';\r\nimport { GameClock } from './GameClock';\r\n\r\n/**\r\n * \u00C9tat de la partie : ressources, civilisations, carte, horloge et seed.\r\n * Couche mod\u00E8le regroupant les donn\u00E9es de jeu.\r\n * La s\u00E9rialisation est d\u00E9l\u00E9gu\u00E9e \u00E0 chaque sous-objet (PlayerResources, GameClock, GameMap, etc.).\r\n */\r\nexport class GameState {\r\n  private gameMap: GameMap | null = null;\r\n  private civilizations: CivilizationId[] = [];\r\n  /** Seed utilis\u00E9 pour la g\u00E9n\u00E9ration de la carte (null si non initialis\u00E9e). */\r\n  private seed: number | null = null;\r\n\r\n  constructor(\r\n    private readonly playerResources: PlayerResources,\r\n    private readonly playerCivilizationId: CivilizationId,\r\n    private readonly gameClock: GameClock\r\n  ) {}\r\n\r\n  /** Ressources du joueur. */\r\n  getPlayerResources(): PlayerResources {\r\n    return this.playerResources;\r\n  }\r\n\r\n  /** Identifiant de la civilisation du joueur. */\r\n  getPlayerCivilizationId(): CivilizationId {\r\n    return this.playerCivilizationId;\r\n  }\r\n\r\n  /** Liste des civilisations de la partie. */\r\n  getCivilizations(): readonly CivilizationId[] {\r\n    return this.civilizations;\r\n  }\r\n\r\n  /** Carte de jeu, ou null si non initialis\u00E9e. */\r\n  getGameMap(): GameMap | null {\r\n    return this.gameMap;\r\n  }\r\n\r\n  /** Horloge de jeu. */\r\n  getGameClock(): GameClock {\r\n    return this.gameClock;\r\n  }\r\n\r\n  /** Seed de g\u00E9n\u00E9ration de la carte, ou null si non initialis\u00E9e. */\r\n  getSeed(): number | null {\r\n    return this.seed;\r\n  }\r\n\r\n  /** D\u00E9finit la carte de jeu (lors d'une nouvelle partie ou r\u00E9g\u00E9n\u00E9ration). */\r\n  setGameMap(map: GameMap | null): void {\r\n    this.gameMap = map;\r\n  }\r\n\r\n  /** D\u00E9finit la liste des civilisations de la partie. */\r\n  setCivilizations(civs: CivilizationId[]): void {\r\n    this.civilizations = [...civs];\r\n  }\r\n\r\n  /** D\u00E9finit le seed de g\u00E9n\u00E9ration (lors d'une nouvelle partie ou r\u00E9g\u00E9n\u00E9ration). */\r\n  setSeed(seed: number | null): void {\r\n    this.seed = seed;\r\n  }\r\n\r\n  /**\r\n   * S\u00E9rialise l'\u00E9tat en une cha\u00EEne JSON.\r\n   * Chaque sous-objet (PlayerResources, GameClock, GameMap) se s\u00E9rialise lui-m\u00EAme.\r\n   */\r\n  serialize(): string {\r\n    const obj = {\r\n      playerResources: this.playerResources.serialize(),\r\n      playerCivilizationId: this.playerCivilizationId.serialize(),\r\n      gameClock: this.gameClock.serialize(),\r\n      gameMap: this.gameMap?.serialize() ?? null,\r\n      civilizations: this.civilizations.map((c) => c.serialize()),\r\n      seed: this.seed,\r\n    };\r\n    return JSON.stringify(obj);\r\n  }\r\n\r\n  /**\r\n   * D\u00E9s\u00E9rialise un GameState depuis une cha\u00EEne JSON.\r\n   * Chaque sous-objet est reconstruit via sa m\u00E9thode deserialize.\r\n   */\r\n  static deserialize(json: string): GameState {\r\n    const obj = JSON.parse(json);\r\n    const pr = PlayerResources.deserialize(obj.playerResources);\r\n    const civId = CivilizationId.deserialize(obj.playerCivilizationId);\r\n    const gc = GameClock.deserialize(obj.gameClock);\r\n    const gs = new GameState(pr, civId, gc);\r\n    gs.setCivilizations((obj.civilizations as string[]).map((s: string) => CivilizationId.deserialize(s)));\r\n    gs.setSeed(obj.seed);\r\n    if (obj.gameMap != null) {\r\n      gs.setGameMap(GameMap.deserialize(obj.gameMap));\r\n    }\r\n    return gs;\r\n  }\r\n}\r\n", "import { MapGenerator, MapGeneratorConfig } from '../controller/MapGenerator';\r\nimport { MainGameController } from '../controller/MainGameController';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { HexType } from '../model/map/HexType';\r\nimport { GameState } from '../model/game/GameState';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\nimport { GameClock } from '../model/game/GameClock';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\n\r\n/**\r\n * Point d'entr\u00E9e applicatif : NewGame (g\u00E9n\u00E9ration de carte), SaveGame et LoadGame.\r\n * La gestion du jeu (\u00E9tat, temps, etc.) est d\u00E9l\u00E9gu\u00E9e \u00E0 MainGameController.\r\n */\r\nexport class MainGame {\r\n  private readonly mapGenerator: MapGenerator;\r\n  private readonly controller: MainGameController;\r\n\r\n  constructor() {\r\n    this.mapGenerator = new MapGenerator();\r\n    const gameState = new GameState(\r\n      new PlayerResources(),\r\n      CivilizationId.create('player1'),\r\n      new GameClock()\r\n    );\r\n    this.controller = new MainGameController(gameState);\r\n    console.log(\"VERSION TEST\", Date.now());\r\n  }\r\n\r\n  /**\r\n   * Retourne le contr\u00F4leur de partie (acc\u00E8s \u00E0 la carte, ressources, horloge, etc.).\r\n   */\r\n  getController(): MainGameController {\r\n    return this.controller;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9marre une nouvelle partie : g\u00E9n\u00E8re une carte et r\u00E9initialise l'\u00E9tat.\r\n   * @param seed - Seed optionnel pour la g\u00E9n\u00E9ration (par d\u00E9faut: timestamp)\r\n   */\r\n  newGame(seed?: number): void {\r\n    const actualSeed = seed ?? Date.now();\r\n    const state = this.controller.getGameState();\r\n\r\n    const resourceDistribution = new Map<HexType, number>([\r\n      [HexType.Wood, 5],\r\n      [HexType.Brick, 5],\r\n      [HexType.Wheat, 5],\r\n      [HexType.Sheep, 5],\r\n      [HexType.Ore, 5],\r\n      [HexType.Desert, 1],\r\n    ]);\r\n\r\n    const civilizations = [state.getPlayerCivilizationId()];\r\n    const config: MapGeneratorConfig = {\r\n      resourceDistribution,\r\n      civilizations,\r\n      seed: actualSeed,\r\n    };\r\n\r\n    const gameMap = this.mapGenerator.generate(config);\r\n    state.setGameMap(gameMap);\r\n    state.setCivilizations(civilizations);\r\n    state.setSeed(actualSeed);\r\n    state.getPlayerResources().clear();\r\n    state.getGameClock().reset();\r\n  }\r\n\r\n  /**\r\n   * Sauvegarde la partie en une cha\u00EEne (s\u00E9rialisation de GameState).\r\n   */\r\n  saveGame(): string {\r\n    return this.controller.getGameState().serialize();\r\n  }\r\n\r\n  /**\r\n   * Charge une partie depuis une cha\u00EEne et remplace l'\u00E9tat du contr\u00F4leur.\r\n   */\r\n  loadGame(serialized: string): void {\r\n    const state = GameState.deserialize(serialized);\r\n    this.controller.setGameState(state);\r\n  }\r\n\r\n  // \u2014\u2014\u2014 D\u00E9l\u00E9gations vers le contr\u00F4leur (compatibilit\u00E9 / raccourcis) \u2014\u2014\u2014\r\n\r\n  getGameState(): GameState {\r\n    return this.controller.getGameState();\r\n  }\r\n\r\n  getGameMap(): GameMap | null {\r\n    return this.controller.getGameMap();\r\n  }\r\n\r\n  getPlayerResources(): PlayerResources {\r\n    return this.controller.getPlayerResources();\r\n  }\r\n\r\n  getPlayerCivilizationId(): CivilizationId {\r\n    return this.controller.getPlayerCivilizationId();\r\n  }\r\n\r\n  getGameClock(): GameClock {\r\n    return this.controller.getGameClock();\r\n  }\r\n\r\n  getSeed(): number | null {\r\n    return this.controller.getSeed();\r\n  }\r\n\r\n  updateGameTime(timeSeconds: number): void {\r\n    this.controller.updateGameTime(timeSeconds);\r\n  }\r\n}\r\n", "import { HexCoord } from '../hex/HexCoord';\r\nimport { Vertex } from '../hex/Vertex';\r\nimport { ResourceType } from '../map/ResourceType';\r\nimport { HexType } from '../map/HexType';\r\nimport { GameMap } from '../map/GameMap';\r\nimport { CivilizationId } from '../map/CivilizationId';\r\nimport { PlayerResources } from './PlayerResources';\r\n\r\n/**\r\n * G\u00E8re la logique de r\u00E9colte de ressources par clic sur les hexagones.\r\n * \r\n * Un hexagone est r\u00E9coltable si :\r\n * - Il est adjacent \u00E0 une ville du joueur (la ville est sur un vertex qui contient cet hexagone)\r\n * - Il est visible (d\u00E9termin\u00E9 par GameMap.isHexVisible)\r\n * - Il contient une ressource r\u00E9coltable (pas Desert ni Water)\r\n */\r\nexport class ResourceHarvest {\r\n  /**\r\n   * Convertit un HexType en ResourceType si c'est une ressource r\u00E9coltable.\r\n   * @param hexType - Le type d'hexagone\r\n   * @returns Le ResourceType correspondant, ou null si non r\u00E9coltable\r\n   */\r\n  static hexTypeToResourceType(hexType: HexType): ResourceType | null {\r\n    switch (hexType) {\r\n      case HexType.Wood:\r\n        return ResourceType.Wood;\r\n      case HexType.Brick:\r\n        return ResourceType.Brick;\r\n      case HexType.Wheat:\r\n        return ResourceType.Wheat;\r\n      case HexType.Sheep:\r\n        return ResourceType.Sheep;\r\n      case HexType.Ore:\r\n        return ResourceType.Ore;\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calcule le gain de ressource pour un hexagone donn\u00E9.\r\n   * Le gain de base est de 1 par hexagone, mais peut \u00EAtre modifi\u00E9 par des bonus futurs.\r\n   * @param hexType - Le type d'hexagone\r\n   * @returns La quantit\u00E9 de ressource gagn\u00E9e (0 si non r\u00E9coltable)\r\n   */\r\n  static calculateGain(hexType: HexType): number {\r\n    // Pour l'instant, gain de base de 1 par hexagone\r\n    // Peut \u00EAtre \u00E9tendu avec des bonus de b\u00E2timents plus tard\r\n    return this.hexTypeToResourceType(hexType) !== null ? 1 : 0;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone est adjacent \u00E0 une ville du joueur.\r\n   * Un hexagone est adjacent \u00E0 une ville si la ville est sur un vertex qui contient cet hexagone.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @returns true si l'hexagone est adjacent \u00E0 au moins une ville du joueur\r\n   */\r\n  static isAdjacentToPlayerCity(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId\r\n  ): boolean {\r\n    return this.getAdjacentPlayerCity(hexCoord, gameMap, civId) !== null;\r\n  }\r\n\r\n  /**\r\n   * Retourne la premi\u00E8re ville du joueur adjacente \u00E0 un hexagone.\r\n   * Un hexagone est adjacent \u00E0 une ville si la ville est sur un vertex qui contient cet hexagone.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @returns Le vertex avec la ville adjacente, ou null si aucune ville adjacente\r\n   */\r\n  static getAdjacentPlayerCity(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId\r\n  ): Vertex | null {\r\n    const grid = gameMap.getGrid();\r\n    \r\n    // Obtenir tous les vertices qui touchent cet hexagone\r\n    const vertices = grid.getVerticesForHex(hexCoord);\r\n    \r\n    // Retourner la premi\u00E8re ville appartenant au joueur\r\n    for (const vertex of vertices) {\r\n      if (gameMap.hasCity(vertex)) {\r\n        const owner = gameMap.getCityOwner(vertex);\r\n        if (owner && owner.equals(civId)) {\r\n          return vertex;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone peut \u00EAtre r\u00E9colt\u00E9 par le joueur.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @returns true si l'hexagone est r\u00E9coltable\r\n   */\r\n  static canHarvest(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId\r\n  ): boolean {\r\n    // V\u00E9rifier que l'hexagone existe dans la grille\r\n    const grid = gameMap.getGrid();\r\n    if (!grid.hasHex(hexCoord)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que l'hexagone est visible\r\n    if (!gameMap.isHexVisible(hexCoord)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que l'hexagone est adjacent \u00E0 une ville du joueur\r\n    if (!this.isAdjacentToPlayerCity(hexCoord, gameMap, civId)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que l'hexagone contient une ressource r\u00E9coltable\r\n    const hexType = gameMap.getHexType(hexCoord);\r\n    if (!hexType) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier si le type d'hexagone est une ressource r\u00E9coltable\r\n    return this.hexTypeToResourceType(hexType) !== null;\r\n  }\r\n\r\n  /**\r\n   * R\u00E9colte les ressources d'un hexagone et les ajoute \u00E0 l'inventaire du joueur.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone \u00E0 r\u00E9colter\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @param playerResources - L'inventaire du joueur\r\n   * @param cityVertex - Optionnel: le vertex de la ville qui r\u00E9colte. Si fourni, cette ville sera utilis\u00E9e au lieu de chercher automatiquement.\r\n   * @returns Un objet contenant la quantit\u00E9 r\u00E9colt\u00E9e et la ville qui a permis la r\u00E9colte\r\n   * @throws Error si l'hexagone ne peut pas \u00EAtre r\u00E9colt\u00E9\r\n   */\r\n  static harvest(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId,\r\n    playerResources: PlayerResources,\r\n    cityVertex?: Vertex\r\n  ): { gain: number; cityVertex: Vertex } {\r\n    // Si un vertex est fourni, v\u00E9rifier qu'il est valide et adjacent \u00E0 l'hex\r\n    let actualCityVertex: Vertex | null = null;\r\n    \r\n    if (cityVertex !== undefined) {\r\n      // V\u00E9rifier que le vertex fourni est bien adjacent \u00E0 l'hex\r\n      const vertexHexes = cityVertex.getHexes();\r\n      const isAdjacent = vertexHexes.some(h => h.equals(hexCoord));\r\n      \r\n      if (!isAdjacent) {\r\n        throw new Error(\r\n          `Le vertex fourni n'est pas adjacent \u00E0 l'hexagone \u00E0 ${hexCoord.toString()}.`\r\n        );\r\n      }\r\n      \r\n      // V\u00E9rifier que le vertex a une ville appartenant \u00E0 la civilisation\r\n      if (!gameMap.hasCity(cityVertex)) {\r\n        throw new Error(\r\n          `Aucune ville trouv\u00E9e sur le vertex fourni pour l'hexagone \u00E0 ${hexCoord.toString()}.`\r\n        );\r\n      }\r\n      \r\n      const owner = gameMap.getCityOwner(cityVertex);\r\n      if (!owner || !owner.equals(civId)) {\r\n        throw new Error(\r\n          `La ville sur le vertex fourni n'appartient pas \u00E0 la civilisation pour l'hexagone \u00E0 ${hexCoord.toString()}.`\r\n        );\r\n      }\r\n      \r\n      actualCityVertex = cityVertex;\r\n    } else {\r\n      // Comportement par d\u00E9faut: chercher la premi\u00E8re ville adjacente\r\n      // V\u00E9rifier que la r\u00E9colte est possible\r\n      if (!this.canHarvest(hexCoord, gameMap, civId)) {\r\n        throw new Error(\r\n          `L'hexagone \u00E0 ${hexCoord.toString()} ne peut pas \u00EAtre r\u00E9colt\u00E9.`\r\n        );\r\n      }\r\n\r\n      // Obtenir la ville adjacente qui permet la r\u00E9colte\r\n      actualCityVertex = this.getAdjacentPlayerCity(hexCoord, gameMap, civId);\r\n      if (!actualCityVertex) {\r\n        throw new Error(\r\n          `Aucune ville adjacente trouv\u00E9e pour l'hexagone \u00E0 ${hexCoord.toString()}.`\r\n        );\r\n      }\r\n    }\r\n    \r\n    // V\u00E9rifier que l'hex est visible et r\u00E9coltable\r\n    const grid = gameMap.getGrid();\r\n    if (!grid.hasHex(hexCoord)) {\r\n      throw new Error(\r\n        `L'hexagone \u00E0 ${hexCoord.toString()} n'existe pas dans la grille.`\r\n      );\r\n    }\r\n\r\n    if (!gameMap.isHexVisible(hexCoord)) {\r\n      throw new Error(\r\n        `L'hexagone \u00E0 ${hexCoord.toString()} n'est pas visible.`\r\n      );\r\n    }\r\n\r\n    // Obtenir le type d'hexagone\r\n    const hexType = gameMap.getHexType(hexCoord);\r\n    if (!hexType) {\r\n      throw new Error(\r\n        `Aucun type d'hexagone trouv\u00E9 sur l'hexagone \u00E0 ${hexCoord.toString()}.`\r\n      );\r\n    }\r\n\r\n    // Convertir en ResourceType\r\n    const resourceType = this.hexTypeToResourceType(hexType);\r\n    if (!resourceType) {\r\n      throw new Error(\r\n        `L'hexagone \u00E0 ${hexCoord.toString()} ne contient pas de ressource r\u00E9coltable.`\r\n      );\r\n    }\r\n\r\n    // Calculer le gain\r\n    const gain = this.calculateGain(hexType);\r\n    \r\n    if (gain > 0) {\r\n      // Ajouter la ressource \u00E0 l'inventaire\r\n      playerResources.addResource(resourceType, gain);\r\n    }\r\n\r\n    return { gain, cityVertex: actualCityVertex };\r\n  }\r\n}\r\n", "import { HexCoord } from '../model/hex/HexCoord';\nimport { Vertex } from '../model/hex/Vertex';\nimport { GameMap } from '../model/map/GameMap';\nimport { CivilizationId } from '../model/map/CivilizationId';\nimport { PlayerResources } from '../model/game/PlayerResources';\nimport { ResourceHarvest } from '../model/game/ResourceHarvest';\nimport { GameClock } from '../model/game/GameClock';\n\n/**\n * R\u00E9sultat d'une tentative de r\u00E9colte.\n */\nexport interface HarvestResult {\n  /** Indique si la r\u00E9colte a r\u00E9ussi */\n  success: boolean;\n  /** Temps restant avant le prochain harvest possible (en millisecondes) */\n  remainingTimeMs: number;\n  /** Ville qui a permis la r\u00E9colte (null si la r\u00E9colte a \u00E9chou\u00E9) */\n  cityVertex: Vertex | null;\n}\n\n/**\n * Contr\u00F4leur pour g\u00E9rer la r\u00E9colte de ressources avec limitation de taux.\n * \n * Cette classe orchestre la logique de r\u00E9colte en coordonnant\n * les v\u00E9rifications m\u00E9tier (ResourceHarvest) avec la limitation\n * de taux (rate limiting) pour \u00E9viter les clics trop rapides.\n */\nexport class ResourceHarvestController {\n  private static hexCooldowns: Map<string, number> = new Map(); // Map<hexCoord.hashCode(), lastHarvestTime en secondes>\n  private static readonly MIN_HARVEST_INTERVAL_S = 1;\n\n  /**\n   * R\u00E9colte une ressource d'un hexagone pour une civilisation donn\u00E9e.\n   * Applique une limitation de taux de 1 r\u00E9colte par seconde maximum par hex.\n   *\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone \u00E0 r\u00E9colter\n   * @param civId - L'identifiant de la civilisation\n   * @param map - La carte de jeu\n   * @param resources - Les ressources du joueur\n   * @param options - Optionnel : { gameClock } pour piloter le temps (tests). Sans options, utilise Date.now()/1000.\n   * @returns Un objet indiquant le succ\u00E8s de la r\u00E9colte et le temps restant\n   */\n  static harvest(\n    hexCoord: HexCoord,\n    civId: CivilizationId,\n    map: GameMap,\n    resources: PlayerResources,\n    options?: { gameClock?: GameClock }\n  ): HarvestResult {\n    const hexKey = hexCoord.hashCode();\n    const lastHarvestTime = ResourceHarvestController.hexCooldowns.get(hexKey);\n    const now = options?.gameClock ? options.gameClock.getCurrentTime() : Date.now() / 1000;\n    const timeSinceLastHarvest = now - (lastHarvestTime ?? 0);\n\n    // Si premi\u00E8re r\u00E9colte sur cet hex (lastHarvestTime === undefined), pas de blocage. Sinon v\u00E9rifier le cooldown.\n    if (lastHarvestTime !== undefined && timeSinceLastHarvest < ResourceHarvestController.MIN_HARVEST_INTERVAL_S) {\n      const remainingTimeMs =\n        Math.max(0, ResourceHarvestController.MIN_HARVEST_INTERVAL_S - timeSinceLastHarvest) * 1000;\n      return {\n        success: false,\n        remainingTimeMs,\n        cityVertex: null,\n      };\n    }\n\n    // V\u00E9rifier que la r\u00E9colte est possible\n    if (!ResourceHarvest.canHarvest(hexCoord, map, civId)) {\n      return {\n        success: false,\n        remainingTimeMs: 0, // Pas de limitation si la r\u00E9colte n'est pas possible pour d'autres raisons\n        cityVertex: null,\n      };\n    }\n\n    // Effectuer la r\u00E9colte et obtenir la ville\n    const harvestResult = ResourceHarvest.harvest(hexCoord, map, civId, resources);\n\n    // Mettre \u00E0 jour le timestamp de la derni\u00E8re r\u00E9colte pour cet hex (en secondes)\n    ResourceHarvestController.hexCooldowns.set(hexKey, now);\n\n    return {\n      success: true,\n      remainingTimeMs: ResourceHarvestController.MIN_HARVEST_INTERVAL_S * 1000,\n      cityVertex: harvestResult.cityVertex,\n    };\n  }\n\n  /**\n   * Retourne le temps restant avant qu'un hexagone puisse \u00EAtre r\u00E9colt\u00E9 \u00E0 nouveau.\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone\n   * @param options - Optionnel : { gameClock } pour piloter le temps (tests). Sans options, utilise Date.now()/1000.\n   * @returns Le temps restant en millisecondes (0 si pr\u00EAt \u00E0 r\u00E9colter)\n   */\n  static getRemainingCooldown(hexCoord: HexCoord, options?: { gameClock?: GameClock }): number {\n    const hexKey = hexCoord.hashCode();\n    const last = ResourceHarvestController.hexCooldowns.get(hexKey);\n    if (last === undefined) {\n      return 0;\n    }\n    const now = options?.gameClock ? options.gameClock.getCurrentTime() : Date.now() / 1000;\n    return Math.max(0, ResourceHarvestController.MIN_HARVEST_INTERVAL_S - (now - last)) * 1000;\n  }\n\n  /**\n   * R\u00E9initialise tous les cooldowns. Utile pour les tests.\n   */\n  static resetCooldowns(): void {\n    ResourceHarvestController.hexCooldowns.clear();\n  }\n}\n", "import { GameMap } from '../model/map/GameMap';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\nimport { GameClock } from '../model/game/GameClock';\r\nimport { City } from '../model/city/City';\r\nimport { BuildingType, getRequiredHexType, getResourceProductionBuildings } from '../model/city/BuildingType';\r\nimport { HexType } from '../model/map/HexType';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { ResourceHarvest } from '../model/game/ResourceHarvest';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\n\r\n/**\r\n * R\u00E9sultat d'une production automatique d'un b\u00E2timent.\r\n */\r\nexport interface BuildingProductionResult {\r\n  /** La ville qui a produit */\r\n  cityVertex: Vertex;\r\n  /** Le type de b\u00E2timent qui a produit */\r\n  buildingType: BuildingType;\r\n  /** L'hexagone r\u00E9colt\u00E9 */\r\n  hexCoord: HexCoord;\r\n  /** Le type de ressource r\u00E9colt\u00E9e */\r\n  resourceType: ResourceType;\r\n}\r\n\r\n/**\r\n * Contr\u00F4leur pour g\u00E9rer la production automatique des b\u00E2timents de ressources.\r\n * \r\n * Les b\u00E2timents de ressources produisent automatiquement des ressources\r\n * en r\u00E9coltant les hexagones adjacents du bon type lorsque l'intervalle de production est \u00E9coul\u00E9.\r\n * Utilise GameClock pour g\u00E9rer le temps de mani\u00E8re ind\u00E9pendante de la vitesse d'ex\u00E9cution.\r\n */\r\nexport class BuildingProductionController {\r\n  /**\r\n   * Intervalle entre deux productions pour un b\u00E2timent (en secondes).\r\n   */\r\n  private static readonly PRODUCTION_INTERVAL_SECONDS = 1.0;\r\n\r\n  /**\r\n   * Traite la production automatique pour toutes les villes d'une civilisation.\r\n   * Pour chaque b\u00E2timent de ressource, v\u00E9rifie les hexagones adjacents et r\u00E9colte\r\n   * ceux qui sont pr\u00EAts (intervalle de production \u00E9coul\u00E9 + conditions de r\u00E9colte).\r\n   * \r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @param resources - Les ressources du joueur\r\n   * @param gameClock - L'horloge de jeu pour g\u00E9rer le temps\r\n   * @returns Liste des productions effectu\u00E9es (pour notifier la vue)\r\n   */\r\n  static processAutomaticProduction(\r\n    civId: CivilizationId,\r\n    map: GameMap,\r\n    resources: PlayerResources,\r\n    gameClock: GameClock\r\n  ): BuildingProductionResult[] {\r\n    const results: BuildingProductionResult[] = [];\r\n    \r\n    // Obtenir toutes les villes de la civilisation\r\n    const cities = map.getCitiesByCivilization(civId);\r\n    \r\n    // Pour chaque ville\r\n    for (const city of cities) {\r\n      const cityResults = this.processCityProduction(city, civId, map, resources, gameClock);\r\n      results.push(...cityResults);\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Traite la production automatique pour une ville donn\u00E9e.\r\n   * \r\n   * @param city - La ville \u00E0 traiter\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @param resources - Les ressources du joueur\r\n   * @param gameClock - L'horloge de jeu pour g\u00E9rer le temps\r\n   * @returns Liste des productions effectu\u00E9es pour cette ville\r\n   */\r\n  private static processCityProduction(\r\n    city: City,\r\n    civId: CivilizationId,\r\n    map: GameMap,\r\n    resources: PlayerResources,\r\n    gameClock: GameClock\r\n  ): BuildingProductionResult[] {\r\n    const results: BuildingProductionResult[] = [];\r\n    \r\n    // Obtenir les b\u00E2timents de production de ressources construits dans cette ville\r\n    const resourceBuildings = getResourceProductionBuildings();\r\n    const cityBuildings = city.getBuildings();\r\n    \r\n    for (const buildingType of cityBuildings) {\r\n      // V\u00E9rifier si c'est un b\u00E2timent de production de ressources\r\n      if (!resourceBuildings.includes(buildingType)) {\r\n        continue;\r\n      }\r\n      \r\n      // Obtenir le type d'hex requis pour ce b\u00E2timent\r\n      const requiredHexType = getRequiredHexType(buildingType);\r\n      if (requiredHexType === null) {\r\n        continue; // Ne devrait pas arriver pour les b\u00E2timents de ressources\r\n      }\r\n      \r\n      // V\u00E9rifier si le temps de production est \u00E9coul\u00E9\r\n      const currentTime = gameClock.getCurrentTime();\r\n      const lastProductionTime = city.getBuildingProductionTime(buildingType);\r\n      \r\n      // Si le b\u00E2timent n'a jamais produit, initialiser son temps de production au temps actuel\r\n      if (lastProductionTime === undefined) {\r\n        city.setBuildingProductionTime(buildingType, currentTime);\r\n        continue; // Ne pas produire imm\u00E9diatement \u00E0 la construction\r\n      }\r\n      \r\n      // Calculer le temps \u00E9coul\u00E9 depuis la derni\u00E8re production\r\n      const timeElapsed = currentTime - lastProductionTime;\r\n      \r\n      // V\u00E9rifier si l'intervalle de production est \u00E9coul\u00E9\r\n      if (timeElapsed < this.PRODUCTION_INTERVAL_SECONDS) {\r\n        // Pas encore le temps de produire\r\n        continue;\r\n      }\r\n      \r\n      // Trouver les hexagones adjacents du bon type\r\n      const adjacentHexes = this.getAdjacentHexesOfType(city.vertex, requiredHexType, map);\r\n      \r\n      // Pour chaque hex adjacent, v\u00E9rifier s'il peut \u00EAtre r\u00E9colt\u00E9 automatiquement\r\n      for (const hexCoord of adjacentHexes) {\r\n        // V\u00E9rifier que la r\u00E9colte est possible (visible, etc.)\r\n        if (!ResourceHarvest.canHarvest(hexCoord, map, civId)) {\r\n          continue;\r\n        }\r\n        \r\n        // V\u00E9rifier que l'hex a bien le type requis (double v\u00E9rification)\r\n        const hexType = map.getHexType(hexCoord);\r\n        if (hexType !== requiredHexType) {\r\n          continue;\r\n        }\r\n        \r\n        // Effectuer la r\u00E9colte directement (sans passer par ResourceHarvestController pour \u00E9viter le cooldown)\r\n        // Passer le vertex de la ville pour permettre \u00E0 plusieurs villes de r\u00E9colter le m\u00EAme hex\r\n        try {\r\n          const harvestResult = ResourceHarvest.harvest(hexCoord, map, civId, resources, city.vertex);\r\n          \r\n          // Convertir le type d'hex en type de ressource\r\n          const resourceType = ResourceHarvest.hexTypeToResourceType(hexType);\r\n          if (resourceType) {\r\n            // Calculer le nouveau temps de production : ancien temps + intervalle\r\n            // Cela garantit qu'une production par seconde est bien faite une fois par seconde\r\n            const newProductionTime = lastProductionTime + this.PRODUCTION_INTERVAL_SECONDS;\r\n            city.updateBuildingProductionTime(buildingType, newProductionTime);\r\n            \r\n            results.push({\r\n              cityVertex: city.vertex,\r\n              buildingType,\r\n              hexCoord,\r\n              resourceType,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          // Si la r\u00E9colte \u00E9choue (par exemple hex non visible), continuer avec le suivant\r\n          continue;\r\n        }\r\n        \r\n        // On arr\u00EAte apr\u00E8s la premi\u00E8re r\u00E9colte r\u00E9ussie pour ce b\u00E2timent\r\n        // (un b\u00E2timent ne peut produire qu'\u00E0 partir d'un hex \u00E0 la fois)\r\n        break;\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Retourne les hexagones adjacents \u00E0 un vertex qui ont le type requis.\r\n   * Un hexagone est adjacent \u00E0 un vertex s'il fait partie des 3 hexagones qui forment le vertex.\r\n   * \r\n   * @param vertex - Le vertex (ville)\r\n   * @param hexType - Le type d'hex recherch\u00E9\r\n   * @param map - La carte de jeu\r\n   * @returns Liste des hexagones adjacents du type requis\r\n   */\r\n  private static getAdjacentHexesOfType(\r\n    vertex: Vertex,\r\n    hexType: HexType,\r\n    map: GameMap\r\n  ): HexCoord[] {\r\n    const matchingHexes: HexCoord[] = [];\r\n    \r\n    // Obtenir les 3 hexagones qui forment le vertex\r\n    const hexes = vertex.getHexes();\r\n    \r\n    // V\u00E9rifier chaque hexagone\r\n    for (const hexCoord of hexes) {\r\n      // V\u00E9rifier que l'hex existe dans la grille\r\n      if (!map.getGrid().hasHex(hexCoord)) {\r\n        continue;\r\n      }\r\n      \r\n      // V\u00E9rifier le type\r\n      const hexTypeInMap = map.getHexType(hexCoord);\r\n      if (hexTypeInMap === hexType) {\r\n        matchingHexes.push(hexCoord);\r\n      }\r\n    }\r\n    \r\n    return matchingHexes;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone est automatiquement r\u00E9colt\u00E9 par un b\u00E2timent.\r\n   * Un hex est automatiquement r\u00E9colt\u00E9 s'il est adjacent \u00E0 une ville qui a un b\u00E2timent\r\n   * de production de ressources capable de r\u00E9colter ce type d'hex.\r\n   * \r\n   * @param hexCoord - L'hexagone \u00E0 v\u00E9rifier\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @returns true si l'hex est automatiquement r\u00E9colt\u00E9\r\n   */\r\n  static isHexAutoHarvested(hexCoord: HexCoord, civId: CivilizationId, map: GameMap): boolean {\r\n    // Obtenir le type de l'hex\r\n    const hexType = map.getHexType(hexCoord);\r\n    if (!hexType) {\r\n      return false;\r\n    }\r\n\r\n    // Obtenir les vertices adjacents \u00E0 cet hex\r\n    const grid = map.getGrid();\r\n    const vertices = grid.getVertices(hexCoord);\r\n    \r\n    // V\u00E9rifier chaque vertex adjacent\r\n    for (const vertex of vertices) {\r\n      // V\u00E9rifier si une ville existe sur ce vertex\r\n      const city = map.getCity(vertex);\r\n      if (!city || !city.owner.equals(civId)) {\r\n        continue;\r\n      }\r\n\r\n      // Obtenir les b\u00E2timents de production de ressources de cette ville\r\n      const resourceBuildings = getResourceProductionBuildings();\r\n      const cityBuildings = city.getBuildings();\r\n      \r\n      // V\u00E9rifier si un b\u00E2timent peut r\u00E9colter cet hex\r\n      for (const buildingType of cityBuildings) {\r\n        if (!resourceBuildings.includes(buildingType)) {\r\n          continue;\r\n        }\r\n        \r\n        // V\u00E9rifier si ce b\u00E2timent r\u00E9colte ce type d'hex\r\n        const requiredHexType = getRequiredHexType(buildingType);\r\n        if (requiredHexType === hexType) {\r\n          // V\u00E9rifier que l'hex est bien adjacent au vertex de la ville\r\n          const vertexHexes = vertex.getHexes();\r\n          if (vertexHexes.some(h => h.equals(hexCoord))) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n}\r\n", "import { Edge } from '../hex/Edge';\r\nimport { GameMap } from '../map/GameMap';\r\nimport { CivilizationId } from '../map/CivilizationId';\r\nimport { ResourceType } from '../map/ResourceType';\r\nimport { PlayerResources } from './PlayerResources';\r\n\r\n/**\r\n * G\u00E8re la logique de construction de routes.\r\n * \r\n * Une route peut \u00EAtre construite sur un edge si :\r\n * - L'edge touche une ville de la m\u00EAme civilisation\r\n * - OU l'edge touche une autre route de la m\u00EAme civilisation\r\n * \r\n * Le co\u00FBt de construction est : 1 argile (Brick) + 1 bois (Wood).\r\n */\r\nexport class RoadConstruction {\r\n  private static readonly COST = new Map<ResourceType, number>([\r\n    [ResourceType.Brick, 1],\r\n    [ResourceType.Wood, 1],\r\n  ]);\r\n\r\n  /**\r\n   * V\u00E9rifie si un edge peut \u00EAtre construit par une civilisation donn\u00E9e.\r\n   * @param edge - L'ar\u00EAte \u00E0 construire\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @returns true si l'edge peut \u00EAtre construit\r\n   */\r\n  static canBuildRoad(edge: Edge, civId: CivilizationId, map: GameMap): boolean {\r\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\r\n    if (!map.isCivilizationRegistered(civId)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une route sur cet edge\r\n    if (map.hasRoad(edge)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier si l'edge touche une ville de la m\u00EAme civilisation\r\n    const vertices = map.getVerticesForEdge(edge);\r\n    for (const vertex of vertices) {\r\n      if (map.hasCity(vertex)) {\r\n        const owner = map.getCityOwner(vertex);\r\n        if (owner && owner.equals(civId)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // V\u00E9rifier si l'edge touche une autre route de la m\u00EAme civilisation\r\n    const adjacentEdges = this.getAdjacentEdges(edge, map);\r\n    for (const adjacentEdge of adjacentEdges) {\r\n      if (map.hasRoad(adjacentEdge)) {\r\n        const owner = map.getRoadOwner(adjacentEdge);\r\n        if (owner && owner.equals(civId)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si le joueur a assez de ressources pour construire une route.\r\n   * @param resources - Les ressources du joueur\r\n   * @param distance - La distance \u00E0 la ville (optionnel, pour v\u00E9rifier le co\u00FBt r\u00E9el)\r\n   * @returns true si le joueur a assez de ressources\r\n   */\r\n  static canAfford(resources: PlayerResources, distance?: number): boolean {\r\n    const cost = RoadConstruction.getCost(distance);\r\n    return resources.canAfford(cost);\r\n  }\r\n\r\n  /**\r\n   * Retourne le co\u00FBt de construction d'une route.\r\n   * Le co\u00FBt de base est multipli\u00E9 par 2^distance.\r\n   * @param distance - La distance \u00E0 la ville la plus proche (optionnel, d\u00E9faut = 0 pour co\u00FBt de base)\r\n   * @returns Le co\u00FBt sous forme de Map\r\n   */\r\n  static getCost(distance?: number): Map<ResourceType, number> {\r\n    const multiplier = distance !== undefined ? Math.pow(2, distance) : 1;\r\n    const cost = new Map<ResourceType, number>();\r\n    \r\n    for (const [resourceType, baseAmount] of RoadConstruction.COST.entries()) {\r\n      cost.set(resourceType, baseAmount * multiplier);\r\n    }\r\n    \r\n    return cost;\r\n  }\r\n\r\n  /**\r\n   * Retourne les edges adjacents \u00E0 un edge donn\u00E9.\r\n   * Deux edges sont adjacents s'ils partagent un vertex.\r\n   * @param edge - L'ar\u00EAte pour laquelle trouver les edges adjacents\r\n   * @param map - La carte de jeu\r\n   * @returns Un tableau des edges adjacents \u00E0 cette ar\u00EAte\r\n   */\r\n  private static getAdjacentEdges(edge: Edge, map: GameMap): Edge[] {\r\n    const adjacentEdges: Edge[] = [];\r\n    const vertices = map.getVerticesForEdge(edge);\r\n\r\n    // Pour chaque vertex adjacent \u00E0 l'edge, obtenir tous les edges qui touchent ce vertex\r\n    for (const vertex of vertices) {\r\n      const hexes = vertex.getHexes();\r\n      // Un vertex est form\u00E9 de 3 hexagones, donc il y a 3 edges possibles entre ces hexagones\r\n      for (let i = 0; i < hexes.length; i++) {\r\n        for (let j = i + 1; j < hexes.length; j++) {\r\n          try {\r\n            const adjacentEdge = Edge.create(hexes[i], hexes[j]);\r\n            // Ne pas inclure l'edge original\r\n            if (!adjacentEdge.equals(edge)) {\r\n              // \u00C9viter les doublons\r\n              if (!adjacentEdges.some(e => e.equals(adjacentEdge))) {\r\n                adjacentEdges.push(adjacentEdge);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            // Ignorer les edges invalides\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacentEdges;\r\n  }\r\n}\r\n", "import { Vertex } from '../model/hex/Vertex';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\nimport { CityLevel } from '../model/city/CityLevel';\r\n\r\n/**\r\n * Contr\u00F4leur pour g\u00E9rer la construction d'avant-postes.\r\n * \r\n * Un avant-poste peut \u00EAtre construit si :\r\n * - Le vertex n'a pas d\u00E9j\u00E0 de ville\r\n * - Le vertex touche une route de la civilisation\r\n * - Le vertex est \u00E0 au moins 2 routes de distance d'une ville existante de la m\u00EAme civilisation\r\n */\r\nexport class OutpostController {\r\n  /**\r\n   * Co\u00FBt de base pour construire un avant-poste (multipli\u00E9 par le nombre de villes).\r\n   */\r\n  private static readonly BASE_COST = new Map<ResourceType, number>([\r\n    [ResourceType.Wood, 10],\r\n    [ResourceType.Brick, 10],\r\n    [ResourceType.Wheat, 10],\r\n    [ResourceType.Sheep, 10],\r\n  ]);\r\n\r\n  /**\r\n   * V\u00E9rifie si un avant-poste peut \u00EAtre construit sur un vertex.\r\n   * @param vertex - Le vertex o\u00F9 construire l'avant-poste\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @returns true si l'avant-poste peut \u00EAtre construit\r\n   */\r\n  static canBuildOutpost(\r\n    vertex: Vertex,\r\n    civId: CivilizationId,\r\n    map: GameMap\r\n  ): boolean {\r\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\r\n    if (!map.isCivilizationRegistered(civId)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une ville sur ce vertex\r\n    if (map.hasCity(vertex)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que le vertex touche au moins une route de la civilisation\r\n    const edgesForVertex = map.getEdgesForVertex(vertex);\r\n    let touchesRoad = false;\r\n    for (const edge of edgesForVertex) {\r\n      if (map.hasRoad(edge)) {\r\n        const owner = map.getRoadOwner(edge);\r\n        if (owner && owner.equals(civId)) {\r\n          touchesRoad = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!touchesRoad) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que le vertex est \u00E0 au moins 2 routes de distance d'une ville\r\n    const distance = map.calculateVertexDistanceToCity(vertex, civId);\r\n    if (distance === undefined || distance < 2) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calcule le co\u00FBt de construction d'un avant-poste en fonction du nombre de villes.\r\n   * @param cityCount - Le nombre de villes existantes sur la carte\r\n   * @returns Le co\u00FBt sous forme de Map\r\n   */\r\n  static getBuildableOutpostCost(cityCount: number): Map<ResourceType, number> {\r\n    const cost = new Map<ResourceType, number>();\r\n    \r\n    for (const [resourceType, baseAmount] of this.BASE_COST.entries()) {\r\n      cost.set(resourceType, baseAmount * cityCount);\r\n    }\r\n    \r\n    return cost;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si le joueur a assez de ressources pour construire un avant-poste.\r\n   * @param resources - Les ressources du joueur\r\n   * @param cityCount - Le nombre de villes existantes sur la carte\r\n   * @returns true si le joueur a assez de ressources\r\n   */\r\n  static canAfford(resources: PlayerResources, cityCount: number): boolean {\r\n    const cost = this.getBuildableOutpostCost(cityCount);\r\n    return resources.canAfford(cost);\r\n  }\r\n\r\n  /**\r\n   * Construit un avant-poste sur un vertex.\r\n   * @param vertex - Le vertex o\u00F9 construire l'avant-poste\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @param resources - Les ressources du joueur\r\n   * @throws Error si la construction n'est pas possible ou si les ressources sont insuffisantes\r\n   */\r\n  static buildOutpost(\r\n    vertex: Vertex,\r\n    civId: CivilizationId,\r\n    map: GameMap,\r\n    resources: PlayerResources\r\n  ): void {\r\n    // V\u00E9rifier que la construction est possible\r\n    if (!this.canBuildOutpost(vertex, civId, map)) {\r\n      throw new Error(\r\n        `L'avant-poste ne peut pas \u00EAtre construit sur le vertex ${vertex.toString()}. ` +\r\n        `Le vertex doit toucher une route de la civilisation et \u00EAtre \u00E0 au moins 2 routes de distance d'une ville.`\r\n      );\r\n    }\r\n\r\n    // Calculer le co\u00FBt en fonction du nombre de villes\r\n    const cityCount = map.getCityCount();\r\n    const cost = this.getBuildableOutpostCost(cityCount);\r\n\r\n    // V\u00E9rifier que le joueur a assez de ressources\r\n    if (!this.canAfford(resources, cityCount)) {\r\n      const woodCost = cost.get(ResourceType.Wood) || 0;\r\n      const brickCost = cost.get(ResourceType.Brick) || 0;\r\n      const wheatCost = cost.get(ResourceType.Wheat) || 0;\r\n      const sheepCost = cost.get(ResourceType.Sheep) || 0;\r\n      throw new Error(\r\n        `Pas assez de ressources pour construire un avant-poste. ` +\r\n        `Requis: ${woodCost} Bois, ${brickCost} Brique, ${wheatCost} Bl\u00E9, ${sheepCost} Mouton (${cityCount} ville${cityCount > 1 ? 's' : ''}).`\r\n      );\r\n    }\r\n\r\n    // Retirer les ressources\r\n    resources.payCost(cost);\r\n\r\n    // Construire la ville de niveau Outpost\r\n    map.addCity(vertex, civId, CityLevel.Outpost);\r\n  }\r\n}\r\n", "import { GameMap } from '../model/map/GameMap';\r\nimport { Hex } from '../model/hex/Hex';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { Edge } from '../model/hex/Edge';\r\nimport { HexType } from '../model/map/HexType';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { City } from '../model/city/City';\r\nimport { CityLevel } from '../model/city/CityLevel';\r\nimport { ResourceHarvestController } from '../controller/ResourceHarvestController';\r\nimport { ResourceHarvest } from '../model/game/ResourceHarvest';\r\nimport { BuildingProductionController } from '../controller/BuildingProductionController';\r\nimport { RoadConstruction } from '../model/game/RoadConstruction';\r\nimport { OutpostController } from '../controller/OutpostController';\r\n\r\n/**\r\n * Configuration pour le rendu des hexagones.\r\n */\r\ninterface RenderConfig {\r\n  /** Taille d'un hexagone (rayon) en pixels */\r\n  hexSize: number;\r\n  /** Offset X pour centrer la carte */\r\n  offsetX: number;\r\n  /** Offset Y pour centrer la carte */\r\n  offsetY: number;\r\n}\r\n\r\n/**\r\n * Particule anim\u00E9e pour repr\u00E9senter une ressource qui vole de l'hex vers l'inventaire.\r\n */\r\ninterface ResourceParticle {\r\n  /** Position X actuelle */\r\n  x: number;\r\n  /** Position Y actuelle */\r\n  y: number;\r\n  /** Position X de d\u00E9part */\r\n  startX: number;\r\n  /** Position Y de d\u00E9part */\r\n  startY: number;\r\n  /** Position X de destination */\r\n  endX: number;\r\n  /** Position Y de destination */\r\n  endY: number;\r\n  /** Type de ressource (pour la couleur) */\r\n  resourceType: ResourceType;\r\n  /** Progression de l'animation (0 \u00E0 1) */\r\n  progress: number;\r\n  /** Temps de cr\u00E9ation en millisecondes */\r\n  createdAt: number;\r\n}\r\n\r\n/**\r\n * Couleur associ\u00E9e \u00E0 chaque type d'hexagone.\r\n */\r\nconst HEX_TYPE_COLORS: Record<HexType, string> = {\r\n  [HexType.Wood]: '#8B4513',      // Marron (bois)\r\n  [HexType.Brick]: '#CD5C5C',     // Rouge brique\r\n  [HexType.Wheat]: '#FFD700',     // Or (bl\u00E9)\r\n  [HexType.Sheep]: '#90EE90',     // Vert clair (mouton)\r\n  [HexType.Ore]: '#708090',       // Gris ardoise (minerai)\r\n  [HexType.Desert]: '#F4A460',   // Sable (d\u00E9sert)\r\n  [HexType.Water]: '#4169E1',     // Bleu royal (eau)\r\n};\r\n\r\n/**\r\n * Renderer pour afficher une GameMap sur un canvas HTML5.\r\n */\r\nexport class HexMapRenderer {\r\n  private canvas: HTMLCanvasElement;\r\n  private ctx: CanvasRenderingContext2D;\r\n  private showCoordinates: boolean = false;\r\n  private currentConfig: RenderConfig | null = null;\r\n  private currentGameMap: GameMap | null = null;\r\n  private onHexClickCallback: ((hexCoord: HexCoord) => void) | null = null;\r\n  private onEdgeClickCallback: ((edge: Edge) => void) | null = null;\r\n  private onVertexClickCallback: ((vertex: Vertex) => void) | null = null;\r\n  private onOutpostVertexClickCallback: ((vertex: Vertex) => void) | null = null;\r\n  private hoveredEdge: Edge | null = null;\r\n  private hoveredVertex: Vertex | null = null;\r\n  private hoveredOutpostVertex: Vertex | null = null;\r\n  private selectedVertex: Vertex | null = null;\r\n  private currentCivilizationId: CivilizationId | null = null;\r\n  private renderCallback: (() => void) | null = null;\r\n  private harvestedHexes: Map<string, number> = new Map(); // Map<hexCoord.hashCode(), timestamp>\r\n  private citySprites: Map<CityLevel, HTMLImageElement> = new Map();\r\n  private citySpritesLoaded: boolean = false;\r\n  private hexTextures: Map<HexType, HTMLImageElement> = new Map();\r\n  private hexTexturesLoaded: boolean = false;\r\n  private lockSprite: HTMLImageElement | null = null;\r\n  private lockSpriteLoaded: boolean = false;\r\n  private resourceParticles: ResourceParticle[] = [];\r\n  private animationFrameId: number | null = null;\r\n  private cooldownAnimationFrameId: number | null = null;\r\n  private tooltipElement: HTMLDivElement | null = null;\r\n  private tooltipEdge: Edge | null = null;\r\n  private tooltipOutpostVertex: Vertex | null = null;\r\n\r\n  constructor(canvas: HTMLCanvasElement) {\r\n    this.canvas = canvas;\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new Error('Impossible d\\'obtenir le contexte 2D du canvas');\r\n    }\r\n    this.ctx = context;\r\n    this.setupMouseMoveHandler();\r\n    this.setupTooltip();\r\n    this.loadCitySprites();\r\n    this.loadHexTextures();\r\n    this.loadLockSprite();\r\n  }\r\n\r\n  /**\r\n   * Charge les sprites SVG des villes.\r\n   */\r\n  private loadCitySprites(): void {\r\n    // Le serveur sert les fichiers depuis la racine du projet\r\n    // Les sprites sont accessibles via assets/sprites/ (chemins relatifs)\r\n\r\n    const spriteFiles: Record<CityLevel, string> = {\r\n      [CityLevel.Outpost]: 'city-outpost.svg',\r\n      [CityLevel.Colony]: 'city-colony.svg',\r\n      [CityLevel.Town]: 'city-town.svg',\r\n      [CityLevel.Metropolis]: 'city-metropolis.svg',\r\n      [CityLevel.Capital]: 'city-capital.svg',\r\n    };\r\n\r\n    let loadedCount = 0;\r\n    const totalSprites = Object.keys(spriteFiles).length;\r\n\r\n    const checkAllLoaded = (): void => {\r\n      loadedCount++;\r\n      if (loadedCount === totalSprites) {\r\n        this.citySpritesLoaded = true;\r\n        // Re-rendre si n\u00E9cessaire pour mettre \u00E0 jour le panneau\r\n        if (this.renderCallback) {\r\n          this.renderCallback();\r\n        }\r\n      }\r\n    };\r\n\r\n    for (const [level, filename] of Object.entries(spriteFiles)) {\r\n      const levelNum = Number(level) as CityLevel;\r\n      \r\n      const tryLoad = (): void => {\r\n        const img = new Image();\r\n        const fullPath = \"assets/sprites/\" + filename;\r\n        \r\n        img.onload = () => {\r\n          this.citySprites.set(levelNum, img);\r\n          checkAllLoaded();\r\n        };\r\n        \r\n        img.onerror = () => {\r\n          console.warn(`\u00C9chec du chargement avec ${fullPath}`);\r\n          // Compter quand m\u00EAme pour ne pas bloquer\r\n          checkAllLoaded();\r\n        };\r\n        \r\n        img.src = fullPath;\r\n      };\r\n\r\n      tryLoad();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Charge le sprite SVG du cadenas.\r\n   */\r\n  private loadLockSprite(): void {\r\n    const img = new Image();\r\n    const fullPath = \"assets/sprites/lock.svg\";\r\n    \r\n    img.onload = () => {\r\n      this.lockSprite = img;\r\n      this.lockSpriteLoaded = true;\r\n      // Re-rendre si n\u00E9cessaire pour mettre \u00E0 jour la carte\r\n      if (this.renderCallback) {\r\n        this.renderCallback();\r\n      }\r\n    };\r\n    \r\n    img.onerror = () => {\r\n      console.warn(`\u00C9chec du chargement du sprite de cadenas ${fullPath}`);\r\n    };\r\n    \r\n    img.src = fullPath;\r\n  }\r\n\r\n\r\n  /**\r\n   * Charge les textures SVG des hexagones.\r\n   */\r\n  private loadHexTextures(): void {\r\n    const textureFiles: Record<HexType, string> = {\r\n      [HexType.Wood]: 'texture-wood.svg',\r\n      [HexType.Brick]: 'texture-brick.svg',\r\n      [HexType.Wheat]: 'texture-wheat.svg',\r\n      [HexType.Sheep]: 'texture-sheep.svg',\r\n      [HexType.Ore]: 'texture-ore.svg',\r\n      [HexType.Desert]: 'texture-desert.svg',\r\n      [HexType.Water]: 'texture-water.svg',\r\n    };\r\n\r\n    let loadedCount = 0;\r\n    const totalTextures = Object.keys(textureFiles).length;\r\n\r\n    const checkAllLoaded = (): void => {\r\n      loadedCount++;\r\n      if (loadedCount === totalTextures) {\r\n        this.hexTexturesLoaded = true;\r\n        // Re-rendre si n\u00E9cessaire pour mettre \u00E0 jour la carte\r\n        if (this.renderCallback) {\r\n          this.renderCallback();\r\n        }\r\n      }\r\n    };\r\n\r\n    for (const [hexType, filename] of Object.entries(textureFiles)) {\r\n      const type = hexType as HexType;\r\n      \r\n      const tryLoad = (): void => {\r\n        const img = new Image();\r\n        const fullPath = \"assets/textures/\" + filename;\r\n        \r\n        img.onload = () => {\r\n          this.hexTextures.set(type, img);\r\n          checkAllLoaded();\r\n        };\r\n        \r\n        img.onerror = () => {\r\n          console.warn(`\u00C9chec du chargement de la texture ${fullPath}`);\r\n          // Compter quand m\u00EAme pour ne pas bloquer\r\n          checkAllLoaded();\r\n        };\r\n        \r\n        img.src = fullPath;\r\n      };\r\n\r\n      tryLoad();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Active ou d\u00E9sactive l'affichage des coordonn\u00E9es.\r\n   */\r\n  setShowCoordinates(show: boolean): void {\r\n    this.showCoordinates = show;\r\n  }\r\n\r\n  /**\r\n   * Dessine la carte compl\u00E8te sur le canvas.\r\n   * @param gameMap - La carte \u00E0 dessiner\r\n   * @param civId - Optionnel: la civilisation pour laquelle dessiner les routes constructibles\r\n   */\r\n  render(gameMap: GameMap, civId?: CivilizationId): void {\r\n    // Stocker la civilisation actuelle pour la d\u00E9tection de survol\r\n    this.currentCivilizationId = civId || null;\r\n    // Effacer le canvas\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    // Calculer les dimensions de la carte\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n\r\n    if (allHexes.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Filtrer uniquement les hexagones visibles\r\n    const visibleHexes = allHexes.filter(hex => gameMap.isHexVisible(hex.coord));\r\n\r\n    if (visibleHexes.length === 0) {\r\n      // Si aucun hexagone n'est visible, ne rien dessiner\r\n      return;\r\n    }\r\n\r\n    // Trouver les limites de la carte (uniquement pour les hexagones visibles)\r\n    let minQ = Infinity;\r\n    let maxQ = -Infinity;\r\n    let minR = Infinity;\r\n    let maxR = -Infinity;\r\n\r\n    for (const hex of visibleHexes) {\r\n      minQ = Math.min(minQ, hex.coord.q);\r\n      maxQ = Math.max(maxQ, hex.coord.q);\r\n      minR = Math.min(minR, hex.coord.r);\r\n      maxR = Math.max(maxR, hex.coord.r);\r\n    }\r\n\r\n    // Calculer la taille des hexagones pour que la carte tienne dans le canvas\r\n    const hexSize = this.calculateHexSize(minQ, maxQ, minR, maxR);\r\n    \r\n    // Calculer le centre de la carte en coordonn\u00E9es hexagonales\r\n    const centerQ = (minQ + maxQ) / 2;\r\n    const centerR = (minR + maxR) / 2;\r\n    \r\n    // Calculer les offsets pour centrer la carte\r\n    const offsetX = this.canvas.width / 2 - Math.sqrt(3) * (centerQ + centerR / 2) * hexSize;\r\n    const offsetY = this.canvas.height / 2 - (3 / 2) * centerR * hexSize;\r\n\r\n    const config: RenderConfig = {\r\n      hexSize,\r\n      offsetX,\r\n      offsetY,\r\n    };\r\n\r\n    // Stocker la configuration et la carte pour la d\u00E9tection de clic\r\n    this.currentConfig = config;\r\n    this.currentGameMap = gameMap;\r\n\r\n    // Dessiner uniquement les hexagones visibles\r\n    for (const hex of visibleHexes) {\r\n      this.drawHex(hex, gameMap, config, civId);\r\n    }\r\n\r\n    // Dessiner les coordonn\u00E9es si activ\u00E9 (uniquement pour les hexagones visibles)\r\n    if (this.showCoordinates) {\r\n      for (const hex of visibleHexes) {\r\n        this.drawCoordinates(hex, config);\r\n      }\r\n    }\r\n\r\n    // Dessiner les routes construites (avant les villes pour qu'elles passent sous)\r\n    this.drawRoads(gameMap, config);\r\n\r\n    // Dessiner les routes constructibles si une civilisation est fournie (avant les villes)\r\n    if (civId) {\r\n      this.drawBuildableRoads(gameMap, config, civId);\r\n    }\r\n\r\n    // Dessiner les avant-postes constructibles si une civilisation est fournie (avant les villes)\r\n    if (civId) {\r\n      this.drawBuildableOutposts(gameMap, config, civId);\r\n    }\r\n\r\n    // Dessiner les villes sur leurs sommets (en dernier pour qu'elles soient par-dessus les routes)\r\n    this.drawCities(gameMap, config);\r\n\r\n    // Dessiner les particules de ressources anim\u00E9es (par-dessus tout le reste)\r\n    this.drawResourceParticles();\r\n    \r\n    // V\u00E9rifier s'il y a des cooldowns actifs et programmer un nouveau rendu si n\u00E9cessaire\r\n    this.scheduleCooldownAnimation(gameMap);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie s'il y a des cooldowns actifs sur la carte et programme un nouveau rendu si n\u00E9cessaire.\r\n   * Cette m\u00E9thode continue \u00E0 programmer des frames jusqu'\u00E0 ce qu'il n'y ait plus de cooldowns actifs.\r\n   */\r\n  private scheduleCooldownAnimation(gameMap: GameMap): void {\r\n    // V\u00E9rifier s'il y a des cooldowns actifs\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n    const visibleHexes = allHexes.filter(hex => gameMap.isHexVisible(hex.coord));\r\n    \r\n    const hasActiveCooldown = visibleHexes.some(hex => {\r\n      const remainingCooldown = ResourceHarvestController.getRemainingCooldown(hex.coord);\r\n      return remainingCooldown > 0;\r\n    });\r\n    \r\n    if (hasActiveCooldown) {\r\n      // Il y a des cooldowns actifs, programmer un nouveau rendu\r\n      // Ne programmer qu'une seule fois pour \u00E9viter les multiples animations en parall\u00E8le\r\n      if (this.cooldownAnimationFrameId === null) {\r\n        const animate = () => {\r\n          // V\u00E9rifier \u00E0 nouveau s'il y a encore des cooldowns actifs en recalculant les hexagones visibles\r\n          if (!this.currentGameMap) {\r\n            this.cooldownAnimationFrameId = null;\r\n            return;\r\n          }\r\n          \r\n          const currentGrid = this.currentGameMap.getGrid();\r\n          const currentAllHexes = currentGrid.getAllHexes();\r\n          const currentVisibleHexes = currentAllHexes.filter(hex => this.currentGameMap!.isHexVisible(hex.coord));\r\n          \r\n          // Toujours re-rendre avant de v\u00E9rifier si on continue, pour mettre \u00E0 jour les timers\r\n          if (this.currentCivilizationId !== null) {\r\n            if (this.renderCallback) {\r\n              this.renderCallback();\r\n            } else {\r\n              this.render(this.currentGameMap, this.currentCivilizationId);\r\n            }\r\n          }\r\n          \r\n          // V\u00E9rifier s'il y a encore des cooldowns actifs apr\u00E8s le rendu\r\n          const stillHasActiveCooldown = currentVisibleHexes.some(hex => {\r\n            const remainingCooldown = ResourceHarvestController.getRemainingCooldown(hex.coord);\r\n            return remainingCooldown > 0;\r\n          });\r\n          \r\n          if (stillHasActiveCooldown) {\r\n            // Programmer le prochain frame\r\n            this.cooldownAnimationFrameId = requestAnimationFrame(animate);\r\n          } else {\r\n            // Plus de cooldowns actifs, arr\u00EAter l'animation\r\n            // (le dernier rendu a d\u00E9j\u00E0 \u00E9t\u00E9 fait juste avant)\r\n            this.cooldownAnimationFrameId = null;\r\n          }\r\n        };\r\n        this.cooldownAnimationFrameId = requestAnimationFrame(animate);\r\n      }\r\n    } else {\r\n      // Plus de cooldowns actifs, annuler l'animation si elle existe\r\n      if (this.cooldownAnimationFrameId !== null) {\r\n        cancelAnimationFrame(this.cooldownAnimationFrameId);\r\n        this.cooldownAnimationFrameId = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit un callback \u00E0 appeler pour re-rendre la carte.\r\n   * Utilis\u00E9 pour mettre \u00E0 jour l'affichage lors du survol de la souris.\r\n   */\r\n  setRenderCallback(callback: () => void): void {\r\n    this.renderCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Retourne le vertex (ville) actuellement s\u00E9lectionn\u00E9, ou null si aucune ville n'est s\u00E9lectionn\u00E9e.\r\n   * @returns Le vertex s\u00E9lectionn\u00E9 ou null\r\n   */\r\n  getSelectedVertex(): Vertex | null {\r\n    return this.selectedVertex;\r\n  }\r\n\r\n  /**\r\n   * Retourne le sprite (image) d'une ville selon son niveau.\r\n   * @param level - Le niveau de la ville\r\n   * @returns L'image du sprite ou null si non charg\u00E9\r\n   */\r\n  getCitySprite(level: CityLevel): HTMLImageElement | null {\r\n    return this.citySprites.get(level) || null;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si les sprites sont charg\u00E9s.\r\n   * @returns true si tous les sprites sont charg\u00E9s\r\n   */\r\n  areCitySpritesLoaded(): boolean {\r\n    return this.citySpritesLoaded;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9clenche un effet visuel pour indiquer qu'un hexagone a \u00E9t\u00E9 r\u00E9colt\u00E9.\r\n   * L'hexagone sera l\u00E9g\u00E8rement r\u00E9duit pendant un court instant (uniquement pour les r\u00E9coltes manuelles).\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone r\u00E9colt\u00E9\r\n   * @param isAutomatic - Si true, n'affiche pas l'effet de r\u00E9duction de taille (seulement la particule)\r\n   */\r\n  triggerHarvestEffect(hexCoord: HexCoord, isAutomatic: boolean = false): void {\r\n    // Pour les r\u00E9coltes automatiques, ne pas appliquer l'effet de r\u00E9duction de taille\r\n    if (isAutomatic) {\r\n      return;\r\n    }\r\n\r\n    const hexKey = hexCoord.hashCode();\r\n    const now = Date.now();\r\n    this.harvestedHexes.set(hexKey, now);\r\n\r\n    // Re-rendre imm\u00E9diatement pour afficher l'effet\r\n    if (this.renderCallback) {\r\n      this.renderCallback();\r\n    }\r\n\r\n    // Nettoyer apr\u00E8s la dur\u00E9e de l'animation (100ms)\r\n    setTimeout(() => {\r\n      this.harvestedHexes.delete(hexKey);\r\n      // Re-rendre pour revenir \u00E0 la taille normale\r\n      if (this.renderCallback) {\r\n        this.renderCallback();\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  /**\r\n   * Couleurs des ressources pour les particules d'animation.\r\n   */\r\n  private static readonly RESOURCE_COLORS: Record<ResourceType, string> = {\r\n    [ResourceType.Wood]: '#8B4513',\r\n    [ResourceType.Brick]: '#CD5C5C',\r\n    [ResourceType.Wheat]: '#FFD700',\r\n    [ResourceType.Sheep]: '#90EE90',\r\n    [ResourceType.Ore]: '#708090',\r\n  };\r\n\r\n  /**\r\n   * D\u00E9clenche une animation de particule pour repr\u00E9senter une ressource qui vole de l'hex vers la ville.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone r\u00E9colt\u00E9\r\n   * @param resourceType - Le type de ressource r\u00E9colt\u00E9e\r\n   * @param cityVertex - Le vertex (ville) vers lequel la particule doit voler\r\n   */\r\n  triggerResourceHarvestAnimation(hexCoord: HexCoord, resourceType: ResourceType, cityVertex: Vertex): void {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    // Calculer la position de d\u00E9part (centre de l'hex)\r\n    const { hexSize, offsetX, offsetY } = this.currentConfig;\r\n    const startX = offsetX + Math.sqrt(3) * (hexCoord.q + hexCoord.r / 2) * hexSize;\r\n    const startY = offsetY + (3 / 2) * hexCoord.r * hexSize;\r\n\r\n    // Calculer la position de destination (position de la ville)\r\n    const cityPosition = this.getVertexPosition(cityVertex, this.currentConfig);\r\n    const endX = cityPosition.x;\r\n    const endY = cityPosition.y;\r\n\r\n    // Cr\u00E9er la particule\r\n    const particle: ResourceParticle = {\r\n      x: startX,\r\n      y: startY,\r\n      startX,\r\n      startY,\r\n      endX,\r\n      endY,\r\n      resourceType,\r\n      progress: 0,\r\n      createdAt: Date.now(),\r\n    };\r\n\r\n    this.resourceParticles.push(particle);\r\n\r\n    // D\u00E9marrer l'animation si elle n'est pas d\u00E9j\u00E0 en cours\r\n    if (this.animationFrameId === null) {\r\n      this.animateParticles();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Anime les particules de ressources en utilisant requestAnimationFrame.\r\n   */\r\n  private animateParticles(): void {\r\n    const now = Date.now();\r\n    const ANIMATION_DURATION_MS = 800; // Dur\u00E9e de l'animation en millisecondes\r\n    const EASING_FUNCTION = (t: number): number => {\r\n      // Fonction d'easing ease-out (commence vite, ralentit \u00E0 la fin)\r\n      return 1 - Math.pow(1 - t, 3);\r\n    };\r\n\r\n    // Mettre \u00E0 jour les particules\r\n    const activeParticles: ResourceParticle[] = [];\r\n    \r\n    for (const particle of this.resourceParticles) {\r\n      const elapsed = now - particle.createdAt;\r\n      particle.progress = Math.min(elapsed / ANIMATION_DURATION_MS, 1);\r\n      \r\n      if (particle.progress < 1) {\r\n        // Calculer la position interpol\u00E9e avec easing\r\n        const easedProgress = EASING_FUNCTION(particle.progress);\r\n        particle.x = particle.startX + (particle.endX - particle.startX) * easedProgress;\r\n        particle.y = particle.startY + (particle.endY - particle.startY) * easedProgress;\r\n        activeParticles.push(particle);\r\n      }\r\n    }\r\n\r\n    this.resourceParticles = activeParticles;\r\n\r\n    // Dessiner les particules\r\n    if (this.resourceParticles.length > 0) {\r\n      // Re-rendre la carte pour afficher les particules\r\n      if (this.renderCallback) {\r\n        this.renderCallback();\r\n      }\r\n      \r\n      // Continuer l'animation\r\n      this.animationFrameId = requestAnimationFrame(() => this.animateParticles());\r\n    } else {\r\n      // Arr\u00EAter l'animation si toutes les particules sont termin\u00E9es\r\n      this.animationFrameId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine les particules de ressources actives.\r\n   */\r\n  private drawResourceParticles(): void {\r\n    for (const particle of this.resourceParticles) {\r\n      const color = HexMapRenderer.RESOURCE_COLORS[particle.resourceType] || '#000000';\r\n      const size = 8; // Taille de la particule\r\n      \r\n      // Dessiner un cercle color\u00E9 pour repr\u00E9senter la ressource\r\n      this.ctx.save();\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(particle.x, particle.y, size / 2, 0, Math.PI * 2);\r\n      this.ctx.fill();\r\n      \r\n      // Ajouter une bordure pour plus de visibilit\u00E9\r\n      this.ctx.strokeStyle = '#FFFFFF';\r\n      this.ctx.lineWidth = 1.5;\r\n      this.ctx.stroke();\r\n      \r\n      this.ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calcule la taille optimale des hexagones pour que la carte tienne dans le canvas.\r\n   */\r\n  private calculateHexSize(minQ: number, maxQ: number, minR: number, maxR: number): number {\r\n    const width = maxQ - minQ + 1;\r\n    const height = maxR - minR + 1;\r\n\r\n    // Dimensions approximatives d'un hexagone en coordonn\u00E9es axiales\r\n    // Largeur: sqrt(3) * size, Hauteur: 2 * size\r\n    const hexWidth = Math.sqrt(3);\r\n    const hexHeight = 2;\r\n\r\n    // Calculer la taille maximale possible\r\n    const maxWidth = (this.canvas.width * 0.9) / (width * hexWidth);\r\n    const maxHeight = (this.canvas.height * 0.9) / (height * hexHeight);\r\n\r\n    return Math.min(maxWidth, maxHeight, 40); // Limiter \u00E0 40px max\r\n  }\r\n\r\n  /**\r\n   * Dessine un hexagone sur le canvas.\r\n   */\r\n  private drawHex(hex: Hex, gameMap: GameMap, config: RenderConfig, civId?: CivilizationId): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const coord = hex.coord;\r\n\r\n    // V\u00E9rifier si cet hexagone vient d'\u00EAtre r\u00E9colt\u00E9 (pour l'effet visuel)\r\n    const hexKey = coord.hashCode();\r\n    const harvestTime = this.harvestedHexes.get(hexKey);\r\n    const isHarvested = harvestTime !== undefined;\r\n    \r\n    // Calculer le facteur de r\u00E9duction (0.85 = r\u00E9duction de 15%)\r\n    const scale = isHarvested ? 0.85 : 1.0;\r\n    const currentHexSize = hexSize * scale;\r\n\r\n    // Convertir les coordonn\u00E9es axiales en coordonn\u00E9es pixel\r\n    // Formule: x = sqrt(3) * (q + r/2) * size\r\n    //          y = 3/2 * r * size\r\n    const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n    const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n\r\n    // Obtenir le type d'hexagone\r\n    const hexType = gameMap.getHexType(coord) || HexType.Desert;\r\n    const color = HEX_TYPE_COLORS[hexType] || '#CCCCCC';\r\n\r\n    // Dessiner l'hexagone avec une rotation de 30\u00B0 (pointy-top)\r\n    // Rotation de 30\u00B0 = \u03C0/6 radians pour passer de flat-top \u00E0 pointy-top\r\n    this.ctx.beginPath();\r\n    for (let i = 0; i < 6; i++) {\r\n      const angle = (Math.PI / 3) * i + Math.PI / 6;\r\n      const hx = x + currentHexSize * Math.cos(angle);\r\n      const hy = y + currentHexSize * Math.sin(angle);\r\n      if (i === 0) {\r\n        this.ctx.moveTo(hx, hy);\r\n      } else {\r\n        this.ctx.lineTo(hx, hy);\r\n      }\r\n    }\r\n    this.ctx.closePath();\r\n\r\n    // Remplir avec la texture si disponible, sinon utiliser la couleur\r\n    const texture = this.hexTextures.get(hexType);\r\n    if (texture && this.hexTexturesLoaded && texture.complete && texture.naturalWidth > 0) {\r\n      // Cr\u00E9er un pattern r\u00E9p\u00E9table avec la texture\r\n      // Ajuster la taille du pattern en fonction de la taille de l'hexagone\r\n      const patternSize = Math.max(currentHexSize * 1.2, 32);\r\n      const pattern = this.ctx.createPattern(texture, 'repeat');\r\n      if (pattern) {\r\n        // Sauvegarder le contexte pour appliquer la transformation du pattern\r\n        this.ctx.save();\r\n        \r\n        // Cr\u00E9er un canvas temporaire pour redimensionner la texture si n\u00E9cessaire\r\n        // Note: createPattern utilise la taille originale de l'image, donc on peut\r\n        // utiliser directement l'image ou cr\u00E9er un pattern plus petit\r\n        this.ctx.fillStyle = pattern;\r\n        this.ctx.fill();\r\n        \r\n        this.ctx.restore();\r\n      } else {\r\n        // Fallback: utiliser la couleur si le pattern n'a pas pu \u00EAtre cr\u00E9\u00E9\r\n        this.ctx.fillStyle = color;\r\n        this.ctx.fill();\r\n      }\r\n    } else {\r\n      // Fallback: utiliser la couleur si la texture n'est pas disponible\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.fill();\r\n    }\r\n\r\n    // Dessiner le contour\r\n    this.ctx.strokeStyle = '#000000';\r\n    this.ctx.lineWidth = 1;\r\n    this.ctx.stroke();\r\n\r\n    // Dessiner le timer de cooldown si l'hex est en cooldown\r\n    this.drawCooldownTimer(coord, x, y, currentHexSize);\r\n    \r\n    // Dessiner un cadenas si l'hex est terrestre mais non r\u00E9coltable\r\n    if (civId && hexType !== HexType.Water) {\r\n      const isHarvestable = ResourceHarvest.canHarvest(coord, gameMap, civId);\r\n      if (!isHarvestable) {\r\n        this.drawLockIcon(x, y, currentHexSize);\r\n      }\r\n    }\r\n\r\n    // Dessiner le texte \"auto\" si l'hex est r\u00E9colt\u00E9 automatiquement\r\n    if (civId && BuildingProductionController.isHexAutoHarvested(coord, civId, gameMap)) {\r\n      this.drawAutoIcon(x, y, currentHexSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine une ic\u00F4ne de cadenas au centre d'un hexagone pour indiquer qu'il n'est pas r\u00E9coltable.\r\n   * Utilise le sprite SVG charg\u00E9 depuis les assets.\r\n   */\r\n  private drawLockIcon(centerX: number, centerY: number, hexSize: number): void {\r\n    // Si le sprite n'est pas encore charg\u00E9, ne rien dessiner\r\n    if (!this.lockSprite || !this.lockSpriteLoaded) {\r\n      return;\r\n    }\r\n    \r\n    const iconSize = hexSize * 0.5; // Taille de l'ic\u00F4ne proportionnelle \u00E0 l'hexagone\r\n    \r\n    this.ctx.save();\r\n    \r\n    // Centrer l'image sur le point (centerX, centerY)\r\n    // Largeur augment\u00E9e de 87.5% au total (1.5 * 1.25)\r\n    const spriteWidth = iconSize * 1.875;\r\n    const spriteHeight = iconSize;\r\n    const x = centerX - spriteWidth / 2;\r\n    const y = centerY - spriteHeight / 2;\r\n    \r\n    // Dessiner le sprite\r\n    this.ctx.drawImage(this.lockSprite, x, y, spriteWidth, spriteHeight);\r\n    \r\n    this.ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Dessine le texte \"auto\" au centre d'un hexagone pour indiquer qu'il est r\u00E9colt\u00E9 automatiquement.\r\n   */\r\n  private drawAutoIcon(centerX: number, centerY: number, hexSize: number): void {\r\n    this.ctx.save();\r\n    \r\n    const fontSize = hexSize * 0.25;\r\n    const text = 'auto';\r\n    \r\n    // Configurer la police\r\n    this.ctx.font = `bold ${fontSize}px Arial, sans-serif`;\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.textBaseline = 'middle';\r\n    \r\n    // Dessiner le texte avec un contour pour am\u00E9liorer la lisibilit\u00E9\r\n    this.ctx.strokeStyle = '#000000';\r\n    this.ctx.lineWidth = 3;\r\n    this.ctx.lineJoin = 'round';\r\n    this.ctx.miterLimit = 2;\r\n    this.ctx.strokeText(text, centerX, centerY);\r\n    \r\n    // Dessiner le texte en blanc\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.fillText(text, centerX, centerY);\r\n    \r\n    this.ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Dessine un timer circulaire pour indiquer le temps restant avant de pouvoir r\u00E9colter \u00E0 nouveau.\r\n   */\r\n  private drawCooldownTimer(hexCoord: HexCoord, centerX: number, centerY: number, hexSize: number): void {\r\n    const remainingCooldown = ResourceHarvestController.getRemainingCooldown(hexCoord);\r\n    \r\n    if (remainingCooldown <= 0) {\r\n      return; // Pas de cooldown, ne rien afficher\r\n    }\r\n\r\n    const MIN_HARVEST_INTERVAL_MS = 1000; // Doit correspondre \u00E0 ResourceHarvestController.MIN_HARVEST_INTERVAL_MS\r\n    const progress = remainingCooldown / MIN_HARVEST_INTERVAL_MS;\r\n    \r\n    // Taille du timer (cercle au centre de l'hex)\r\n    const timerRadius = hexSize * 0.3;\r\n    \r\n    this.ctx.save();\r\n    \r\n    // Dessiner le fond du timer (cercle gris semi-transparent)\r\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n    this.ctx.beginPath();\r\n    this.ctx.arc(centerX, centerY, timerRadius, 0, Math.PI * 2);\r\n    this.ctx.fill();\r\n    \r\n    // Dessiner l'arc de progression (de 0 \u00E0 progress * 2\u03C0)\r\n    // L'arc commence en haut (-\u03C0/2) et tourne dans le sens horaire\r\n    this.ctx.strokeStyle = '#FFFFFF';\r\n    this.ctx.lineWidth = 3;\r\n    this.ctx.beginPath();\r\n    const startAngle = -Math.PI / 2; // En haut\r\n    const endAngle = startAngle + (1 - progress) * Math.PI * 2; // Progression du cooldown\r\n    this.ctx.arc(centerX, centerY, timerRadius, startAngle, endAngle);\r\n    this.ctx.stroke();\r\n    \r\n    // Afficher le temps restant en secondes au centre\r\n    const remainingSeconds = Math.ceil(remainingCooldown / 1000);\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.font = `${Math.max(10, timerRadius * 0.5)}px Arial`;\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.textBaseline = 'middle';\r\n    this.ctx.fillText(remainingSeconds.toString(), centerX, centerY);\r\n    \r\n    this.ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Dessine les coordonn\u00E9es (q, r) au centre d'un hexagone.\r\n   */\r\n  private drawCoordinates(hex: Hex, config: RenderConfig): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const coord = hex.coord;\r\n\r\n    // Convertir les coordonn\u00E9es axiales en coordonn\u00E9es pixel (centre de l'hexagone)\r\n    const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n    const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n\r\n    // Dessiner le texte des coordonn\u00E9es\r\n    const text = `(${coord.q},${coord.r})`;\r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.font = `${Math.max(8, hexSize / 4)}px Arial`;\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.textBaseline = 'middle';\r\n    \r\n    // Dessiner un fond semi-transparent pour am\u00E9liorer la lisibilit\u00E9\r\n    const metrics = this.ctx.measureText(text);\r\n    const textWidth = metrics.width;\r\n    const textHeight = parseInt(this.ctx.font) || 12;\r\n    \r\n    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\r\n    this.ctx.fillRect(\r\n      x - textWidth / 2 - 2,\r\n      y - textHeight / 2 - 2,\r\n      textWidth + 4,\r\n      textHeight + 4\r\n    );\r\n    \r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.fillText(text, x, y);\r\n  }\r\n\r\n  /**\r\n   * Dessine les villes sur leurs sommets.\r\n   */\r\n  private drawCities(gameMap: GameMap, config: RenderConfig): void {\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n\r\n    \r\n    const allVertices = grid.getAllVertices();\r\n    for (const vertex of allVertices) {\r\n      const vertexKey = vertex.hashCode();\r\n      if (gameMap.hasCity(vertex)) {\r\n        const city = gameMap.getCity(vertex);\r\n        const isHovered = this.hoveredVertex !== null && this.hoveredVertex.equals(vertex);\r\n        const isSelected = this.selectedVertex !== null && this.selectedVertex.equals(vertex);\r\n        if (city) {\r\n          this.drawCity(vertex, city, config, isHovered, isSelected);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine une ville sur un sommet avec un sprite correspondant \u00E0 son niveau.\r\n   * @param vertex - Le sommet o\u00F9 se trouve la ville\r\n   * @param city - La ville \u00E0 dessiner\r\n   * @param config - La configuration de rendu\r\n   * @param isHovered - true si la ville est survol\u00E9e par la souris\r\n   * @param isSelected - true si la ville est s\u00E9lectionn\u00E9e\r\n   */\r\n  private drawCity(vertex: Vertex, city: City, config: RenderConfig, isHovered: boolean = false, isSelected: boolean = false): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const hexes = vertex.getHexes();\r\n\r\n    // Calculer la position du sommet (centre du triangle form\u00E9 par les 3 hexagones)\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n\r\n    for (const coord of hexes) {\r\n      const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n      const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n      sumX += x;\r\n      sumY += y;\r\n    }\r\n\r\n    const centerX = sumX / 3;\r\n    const centerY = sumY / 3;\r\n\r\n    // Taille fixe pour toutes les villes (taille de la capitale)\r\n    const baseSize = (8 + CityLevel.Capital * 2) * 2; // 32 pixels pour tous les niveaux\r\n    \r\n    // Agrandir si survol\u00E9e ou s\u00E9lectionn\u00E9e\r\n    let scale = 1.0;\r\n    if (isHovered || isSelected) {\r\n      scale = 1.3;\r\n    }\r\n    \r\n    const citySize = baseSize * scale;\r\n\r\n    // Sauvegarder le contexte pour restaurer apr\u00E8s le dessin\r\n    this.ctx.save();\r\n\r\n    // Obtenir le sprite correspondant au niveau\r\n    const sprite = this.citySprites.get(city.level);\r\n    \r\n    // V\u00E9rifier que le sprite est charg\u00E9 et pr\u00EAt\r\n    const isSpriteReady = sprite && \r\n                          this.citySpritesLoaded && \r\n                          sprite.complete && \r\n                          sprite.naturalWidth > 0;\r\n    \r\n    if (isSpriteReady) {\r\n      // Appliquer la transformation pour le scale et la position\r\n      this.ctx.translate(centerX, centerY);\r\n      this.ctx.scale(scale, scale);\r\n\r\n      // Dessiner l'aura jaune autour du sprite pour am\u00E9liorer le contraste\r\n      const auraRadius = baseSize / 2 + 3; // Rayon de l'aura (l\u00E9g\u00E8rement plus grand que le sprite)\r\n      const gradient = this.ctx.createRadialGradient(0, 0, baseSize / 2, 0, 0, auraRadius);\r\n      gradient.addColorStop(0, 'rgba(255, 255, 0, 0.0)'); // Transparent au centre\r\n      gradient.addColorStop(0.7, 'rgba(255, 255, 200, 0.6)'); // Jaune clair\r\n      gradient.addColorStop(1, 'rgba(255, 255, 0, 0.3)'); // Jaune plus fonc\u00E9 \u00E0 l'ext\u00E9rieur\r\n      \r\n      this.ctx.fillStyle = gradient;\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);\r\n      this.ctx.fill();\r\n\r\n      // Dessiner le sprite (apr\u00E8s l'aura pour qu'il soit au-dessus)\r\n      this.ctx.drawImage(\r\n        sprite,\r\n        -baseSize / 2,\r\n        -baseSize / 2,\r\n        baseSize,\r\n        baseSize\r\n      );\r\n\r\n      // Appliquer une teinte de couleur selon l'\u00E9tat (survol ou s\u00E9lection)\r\n      if (isSelected) {\r\n        // Orange pour la s\u00E9lection : overlay color\u00E9\r\n        this.ctx.globalCompositeOperation = 'multiply';\r\n        this.ctx.fillStyle = 'rgba(255, 165, 0, 0.4)'; // Orange semi-transparent\r\n        this.ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);\r\n        this.ctx.globalCompositeOperation = 'source-over';\r\n      } else if (isHovered) {\r\n        // Jaune dor\u00E9 pour le survol : overlay color\u00E9\r\n        this.ctx.globalCompositeOperation = 'multiply';\r\n        this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; // Jaune dor\u00E9 semi-transparent\r\n        this.ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);\r\n        this.ctx.globalCompositeOperation = 'source-over';\r\n      }\r\n    } else {\r\n      // Fallback : dessiner un carr\u00E9 simple si les sprites ne sont pas encore charg\u00E9s\r\n      const fallbackSize = baseSize * scale;\r\n      let baseColor = '#2C2C2C';\r\n      if (isSelected) {\r\n        baseColor = '#FFA500';\r\n      } else if (isHovered) {\r\n        baseColor = '#FFD700';\r\n      }\r\n      this.ctx.fillStyle = baseColor;\r\n      this.ctx.fillRect(centerX - fallbackSize / 2, centerY - fallbackSize / 2, fallbackSize, fallbackSize);\r\n    }\r\n\r\n    // Restaurer le contexte\r\n    this.ctx.restore();\r\n\r\n    // Dessiner une bordure si s\u00E9lectionn\u00E9e (apr\u00E8s le restore pour la taille normale)\r\n    if (isSelected) {\r\n      this.ctx.strokeStyle = '#000000';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(centerX, centerY, citySize / 2 + 3, 0, Math.PI * 2);\r\n      this.ctx.stroke();\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Dessine les routes construites sur la carte.\r\n   */\r\n  private drawRoads(gameMap: GameMap, config: RenderConfig): void {\r\n    const grid = gameMap.getGrid();\r\n    const allEdges = grid.getAllEdges();\r\n\r\n    // Utiliser un Set pour \u00E9viter de dessiner deux fois la m\u00EAme route\r\n    const drawnEdges = new Set<string>();\r\n\r\n    for (const edge of allEdges) {\r\n      if (gameMap.hasRoad(edge)) {\r\n        const edgeKey = edge.hashCode();\r\n        if (!drawnEdges.has(edgeKey)) {\r\n          drawnEdges.add(edgeKey);\r\n          this.drawRoad(edge, config, false, gameMap); // false = trait plein\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine les routes constructibles pour une civilisation.\r\n   */\r\n  private drawBuildableRoads(\r\n    gameMap: GameMap,\r\n    config: RenderConfig,\r\n    civId: CivilizationId\r\n  ): void {\r\n    const buildableRoads = gameMap.getBuildableRoadsForCivilization(civId);\r\n\r\n    for (const edge of buildableRoads) {\r\n      const isHighlighted = this.hoveredEdge !== null && this.hoveredEdge.equals(edge);\r\n      this.drawRoad(edge, config, true, gameMap, isHighlighted); // true = trait pointill\u00E9\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine les avant-postes constructibles pour une civilisation.\r\n   */\r\n  private drawBuildableOutposts(\r\n    gameMap: GameMap,\r\n    config: RenderConfig,\r\n    civId: CivilizationId\r\n  ): void {\r\n    const buildableVertices = gameMap.getBuildableOutpostVertices(civId);\r\n\r\n    for (const vertex of buildableVertices) {\r\n      const isHighlighted = this.hoveredOutpostVertex !== null && this.hoveredOutpostVertex.equals(vertex);\r\n      this.drawBuildableOutpostVertex(vertex, config, isHighlighted);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine un vertex constructible pour un avant-poste (rond en pointill\u00E9).\r\n   * @param vertex - Le vertex \u00E0 dessiner\r\n   * @param config - La configuration de rendu\r\n   * @param isHighlighted - true si le vertex est survol\u00E9\r\n   */\r\n  private drawBuildableOutpostVertex(vertex: Vertex, config: RenderConfig, isHighlighted: boolean = false): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const hexes = vertex.getHexes();\r\n\r\n    // Calculer la position du centre du vertex\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n\r\n    for (const coord of hexes) {\r\n      const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n      const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n      sumX += x;\r\n      sumY += y;\r\n    }\r\n\r\n    const centerX = sumX / 3;\r\n    const centerY = sumY / 3;\r\n\r\n    // Taille du cercle (deux fois plus petit que la ville)\r\n    const baseRadius = 8; // R\u00E9duit de 16 \u00E0 8\r\n    const radius = isHighlighted ? baseRadius * 1.3 : baseRadius;\r\n\r\n    // Sauvegarder le contexte\r\n    this.ctx.save();\r\n\r\n    // Dessiner un cercle en pointill\u00E9\r\n    this.ctx.beginPath();\r\n    this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);\r\n    \r\n    // Style du cercle pointill\u00E9\r\n    this.ctx.strokeStyle = isHighlighted ? '#00FF00' : '#90EE90'; // Vert clair\r\n    this.ctx.lineWidth = 2;\r\n    this.ctx.setLineDash([5, 5]); // Pointill\u00E9 : 5px trait, 5px espace\r\n    this.ctx.stroke();\r\n    \r\n    // Restaurer le contexte\r\n    this.ctx.setLineDash([]); // R\u00E9initialiser le pointill\u00E9\r\n    this.ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Dessine une route (construite ou constructible) sur une ar\u00EAte.\r\n   * @param edge - L'ar\u00EAte \u00E0 dessiner\r\n   * @param config - La configuration de rendu\r\n   * @param isDashed - true pour un trait pointill\u00E9 (route constructible), false pour un trait plein (route construite)\r\n   * @param isHighlighted - true pour mettre en surbrillance (route survol\u00E9e)\r\n   */\r\n  private drawRoad(edge: Edge, config: RenderConfig, isDashed: boolean, gameMap: GameMap, isHighlighted: boolean = false): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const [hex1, hex2] = edge.getHexes();\r\n\r\n    // Obtenir les vertices de l'edge (un edge a deux vertices)\r\n    const vertices = gameMap.getVerticesForEdge(edge);\r\n    \r\n    if (vertices.length < 2) {\r\n      // Fallback: utiliser les coins calcul\u00E9s \u00E0 partir de la direction\r\n      this.drawRoadFromDirection(edge, config, isDashed, isHighlighted);\r\n      return;\r\n    }\r\n\r\n    // Calculer les positions des deux vertices\r\n    const vertex1 = vertices[0];\r\n    const vertex2 = vertices[1];\r\n\r\n    const pos1 = this.getVertexPosition(vertex1, config);\r\n    const pos2 = this.getVertexPosition(vertex2, config);\r\n\r\n    // Dessiner la ligne entre les deux vertices\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(pos1.x, pos1.y);\r\n    this.ctx.lineTo(pos2.x, pos2.y);\r\n\r\n    // Configurer le style\r\n    if (isHighlighted) {\r\n      // Surbrillance : couleur plus claire et trait plus \u00E9pais\r\n      this.ctx.strokeStyle = '#FFA500'; // Orange\r\n      this.ctx.lineWidth = 6;\r\n    } else {\r\n      this.ctx.strokeStyle = '#000000';\r\n      this.ctx.lineWidth = 4;\r\n    }\r\n\r\n    if (isDashed) {\r\n      // Trait pointill\u00E9 pour les routes constructibles\r\n      this.ctx.setLineDash([5, 5]);\r\n    } else {\r\n      // Trait plein pour les routes construites\r\n      this.ctx.setLineDash([]);\r\n    }\r\n\r\n    this.ctx.stroke();\r\n    \r\n    // R\u00E9initialiser le lineDash pour ne pas affecter les autres dessins\r\n    this.ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Calcule la position d'un vertex en pixels.\r\n   * Un vertex est le point o\u00F9 3 hexagones se rencontrent (un coin d'hexagone).\r\n   */\r\n  private getVertexPosition(vertex: Vertex, config: RenderConfig): { x: number; y: number } {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const hexes = vertex.getHexes();\r\n\r\n    // Pour un vertex, on peut calculer la position comme la moyenne des centres des 3 hexagones\r\n    // Mais plus pr\u00E9cis\u00E9ment, un vertex est un coin d'hexagone, donc on peut le calculer\r\n    // en trouvant le coin commun aux 3 hexagones\r\n    \r\n    // Approche simple: moyenne des centres (ce qui donne approximativement le coin)\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n\r\n    for (const coord of hexes) {\r\n      const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n      const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n      sumX += x;\r\n      sumY += y;\r\n    }\r\n\r\n    return {\r\n      x: sumX / 3,\r\n      y: sumY / 3,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Dessine une route en utilisant la direction entre les deux hexagones (fallback).\r\n   */\r\n  private drawRoadFromDirection(edge: Edge, config: RenderConfig, isDashed: boolean, isHighlighted: boolean = false): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const [hex1, hex2] = edge.getHexes();\r\n\r\n    // Calculer les positions des centres des deux hexagones\r\n    const centerX1 = offsetX + Math.sqrt(3) * (hex1.q + hex1.r / 2) * hexSize;\r\n    const centerY1 = offsetY + (3 / 2) * hex1.r * hexSize;\r\n\r\n    // D\u00E9terminer la direction de hex1 vers hex2\r\n    const dq = hex2.q - hex1.q;\r\n    const dr = hex2.r - hex1.r;\r\n\r\n    // Mapper la direction (dq, dr) vers l'index du coin\r\n    // Pour un hexagone pointy-top, les directions sont:\r\n    // N: (0, -1) -> coin entre 0 et 1\r\n    // NE: (1, -1) -> coin entre 1 et 2\r\n    // SE: (1, 0) -> coin entre 2 et 3\r\n    // S: (0, 1) -> coin entre 3 et 4\r\n    // SW: (-1, 1) -> coin entre 4 et 5\r\n    // NW: (-1, 0) -> coin entre 5 et 0\r\n\r\n    let cornerIndex1: number;\r\n    let cornerIndex2: number;\r\n\r\n    if (dq === 0 && dr === -1) {\r\n      // N\r\n      cornerIndex1 = 0;\r\n      cornerIndex2 = 1;\r\n    } else if (dq === 1 && dr === -1) {\r\n      // NE\r\n      cornerIndex1 = 1;\r\n      cornerIndex2 = 2;\r\n    } else if (dq === 1 && dr === 0) {\r\n      // SE\r\n      cornerIndex1 = 2;\r\n      cornerIndex2 = 3;\r\n    } else if (dq === 0 && dr === 1) {\r\n      // S\r\n      cornerIndex1 = 3;\r\n      cornerIndex2 = 4;\r\n    } else if (dq === -1 && dr === 1) {\r\n      // SW\r\n      cornerIndex1 = 4;\r\n      cornerIndex2 = 5;\r\n    } else if (dq === -1 && dr === 0) {\r\n      // NW\r\n      cornerIndex1 = 5;\r\n      cornerIndex2 = 0;\r\n    } else {\r\n      // Fallback: utiliser les centres si la direction n'est pas reconnue\r\n      const centerX2 = offsetX + Math.sqrt(3) * (hex2.q + hex2.r / 2) * hexSize;\r\n      const centerY2 = offsetY + (3 / 2) * hex2.r * hexSize;\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(centerX1, centerY1);\r\n      this.ctx.lineTo(centerX2, centerY2);\r\n      if (isHighlighted) {\r\n        this.ctx.strokeStyle = '#FFA500'; // Orange\r\n        this.ctx.lineWidth = 6;\r\n      } else {\r\n        this.ctx.strokeStyle = '#000000';\r\n        this.ctx.lineWidth = 4;\r\n      }\r\n      if (isDashed) {\r\n        this.ctx.setLineDash([5, 5]);\r\n      } else {\r\n        this.ctx.setLineDash([]);\r\n      }\r\n      this.ctx.stroke();\r\n      this.ctx.setLineDash([]);\r\n      return;\r\n    }\r\n\r\n    // Calculer les positions des deux coins de hex1 qui forment l'edge\r\n    const angle1 = (Math.PI / 3) * cornerIndex1 + Math.PI / 6;\r\n    const angle2 = (Math.PI / 3) * cornerIndex2 + Math.PI / 6;\r\n    \r\n    const cornerX1 = centerX1 + hexSize * Math.cos(angle1);\r\n    const cornerY1 = centerY1 + hexSize * Math.sin(angle1);\r\n    const cornerX2 = centerX1 + hexSize * Math.cos(angle2);\r\n    const cornerY2 = centerY1 + hexSize * Math.sin(angle2);\r\n\r\n    // Dessiner la ligne entre les deux coins\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(cornerX1, cornerY1);\r\n    this.ctx.lineTo(cornerX2, cornerY2);\r\n\r\n    // Configurer le style\r\n    if (isHighlighted) {\r\n      // Surbrillance : couleur plus claire et trait plus \u00E9pais\r\n      this.ctx.strokeStyle = '#FFA500'; // Orange\r\n      this.ctx.lineWidth = 6;\r\n    } else {\r\n      this.ctx.strokeStyle = '#000000';\r\n      this.ctx.lineWidth = 4;\r\n    }\r\n\r\n    if (isDashed) {\r\n      // Trait pointill\u00E9 pour les routes constructibles\r\n      this.ctx.setLineDash([5, 5]);\r\n    } else {\r\n      // Trait plein pour les routes construites\r\n      this.ctx.setLineDash([]);\r\n    }\r\n\r\n    this.ctx.stroke();\r\n    \r\n    // R\u00E9initialiser le lineDash pour ne pas affecter les autres dessins\r\n    this.ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Redimensionne le canvas pour qu'il s'adapte \u00E0 la fen\u00EAtre.\r\n   */\r\n  resize(): void {\r\n    // Ajuster la taille du canvas en tenant compte du header et footer uniquement\r\n    // Le panneau de ville est en position absolue, donc il n'affecte pas la taille du canvas\r\n    const header = document.querySelector('header');\r\n    const footer = document.querySelector('footer');\r\n    const main = document.querySelector('main');\r\n    const headerHeight = header ? header.offsetHeight : 0;\r\n    const footerHeight = footer ? footer.offsetHeight : 0;\r\n    \r\n    // Calculer le padding du main (2rem de chaque c\u00F4t\u00E9)\r\n    const mainStyle = main ? window.getComputedStyle(main) : null;\r\n    const mainPaddingX = mainStyle ? (parseFloat(mainStyle.paddingLeft) || 32) + (parseFloat(mainStyle.paddingRight) || 32) : 64;\r\n    const mainPaddingY = mainStyle ? (parseFloat(mainStyle.paddingTop) || 32) + (parseFloat(mainStyle.paddingBottom) || 32) : 64;\r\n    \r\n    // Largeur disponible = largeur fen\u00EAtre - padding main\r\n    // Hauteur disponible = hauteur fen\u00EAtre - header - footer - padding main\r\n    this.canvas.width = window.innerWidth - mainPaddingX;\r\n    this.canvas.height = window.innerHeight - headerHeight - footerHeight - mainPaddingY;\r\n  }\r\n\r\n  /**\r\n   * Convertit les coordonn\u00E9es pixel (x, y) en coordonn\u00E9es hexagonales (q, r).\r\n   * @param pixelX - Coordonn\u00E9e X du pixel\r\n   * @param pixelY - Coordonn\u00E9e Y du pixel\r\n   * @returns Les coordonn\u00E9es hexagonales correspondantes, ou null si hors carte\r\n   */\r\n  pixelToHexCoord(pixelX: number, pixelY: number): HexCoord | null {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return null;\r\n    }\r\n\r\n    const { hexSize, offsetX, offsetY } = this.currentConfig;\r\n    const grid = this.currentGameMap.getGrid();\r\n\r\n    // Convertir les coordonn\u00E9es pixel en coordonn\u00E9es hexagonales\r\n    // Formule inverse de: \r\n    // x = sqrt(3) * (q + r/2) * size\r\n    // y = 3/2 * r * size\r\n    // \r\n    // Inverse:\r\n    // r = (2/3 * y) / size\r\n    // q = x / (sqrt(3) * size) - r/2\r\n    \r\n    // Convertir pixel canvas -> coordonn\u00E9es relatives au centre (apr\u00E8s offset)\r\n    const x = pixelX - offsetX;\r\n    const y = pixelY - offsetY;\r\n    \r\n    // Calculer r d'abord\r\n    const r = (2 / 3 * y) / hexSize;\r\n    // Puis calculer q\r\n    const q = x / (Math.sqrt(3) * hexSize) - r / 2;\r\n\r\n    // Arrondir pour obtenir les coordonn\u00E9es hexagonales les plus proches\r\n    const hexQ = Math.round(q);\r\n    const hexR = Math.round(r);\r\n    \r\n    // V\u00E9rifier les 7 candidats possibles (hexagone calcul\u00E9 + ses 6 voisins)\r\n    const candidates = [\r\n      new HexCoord(hexQ, hexR),\r\n      new HexCoord(hexQ + 1, hexR),\r\n      new HexCoord(hexQ - 1, hexR),\r\n      new HexCoord(hexQ, hexR + 1),\r\n      new HexCoord(hexQ, hexR - 1),\r\n      new HexCoord(hexQ + 1, hexR - 1),\r\n      new HexCoord(hexQ - 1, hexR + 1),\r\n    ];\r\n    \r\n    // Trouver le candidat le plus proche du point cliqu\u00E9\r\n    let closestHex: HexCoord | null = null;\r\n    let minDistance = Infinity;\r\n    const maxDistance = hexSize * 0.9; // Distance maximale (rayon de l'hexagone)\r\n    \r\n    for (const candidate of candidates) {\r\n      if (!grid.hasHex(candidate)) {\r\n        continue;\r\n      }\r\n      \r\n      // Calculer la position du centre de cet hexagone avec les M\u00CAMES formules que drawHex\r\n      const hexX = offsetX + Math.sqrt(3) * (candidate.q + candidate.r / 2) * hexSize;\r\n      const hexY = offsetY + (3 / 2) * candidate.r * hexSize;\r\n      \r\n      // Calculer la distance depuis le point cliqu\u00E9\r\n      const dx = pixelX - hexX;\r\n      const dy = pixelY - hexY;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      // Si la distance est inf\u00E9rieure au rayon et est la plus petite\r\n      if (distance < maxDistance && distance < minDistance) {\r\n        minDistance = distance;\r\n        closestHex = candidate;\r\n      }\r\n    }\r\n    \r\n    return closestHex;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit le callback \u00E0 appeler lorsqu'un hexagone est cliqu\u00E9.\r\n   * @param callback - Fonction appel\u00E9e avec les coordonn\u00E9es hexagonales du clic\r\n   */\r\n  setOnHexClick(callback: (hexCoord: HexCoord) => void): void {\r\n    this.onHexClickCallback = callback;\r\n    this.setupClickHandler();\r\n  }\r\n\r\n  /**\r\n   * Convertit les coordonn\u00E9es pixel (x, y) en Vertex (sommet avec ville) si le clic est proche d'un vertex avec une ville.\r\n   * @param pixelX - Coordonn\u00E9e X du pixel\r\n   * @param pixelY - Coordonn\u00E9e Y du pixel\r\n   * @returns Le vertex avec une ville le plus proche du point cliqu\u00E9, ou null si aucun vertex n'est assez proche\r\n   */\r\n  pixelToVertex(pixelX: number, pixelY: number): Vertex | null {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return null;\r\n    }\r\n\r\n    const gameMap = this.currentGameMap;\r\n    const grid = gameMap.getGrid();\r\n    const allVertices = grid.getAllVertices();\r\n\r\n    let closestVertex: Vertex | null = null;\r\n    let minDistance = Infinity;\r\n    const maxDistance = 12; // Distance maximale en pixels (taille de la ville + marge)\r\n\r\n    for (const vertex of allVertices) {\r\n      // Ne v\u00E9rifier que les vertices qui ont une ville\r\n      if (!gameMap.hasCity(vertex)) {\r\n        continue;\r\n      }\r\n\r\n      // Calculer la position du vertex\r\n      const pos = this.getVertexPosition(vertex, this.currentConfig);\r\n\r\n      // Calculer la distance du point cliqu\u00E9 au vertex\r\n      const dx = pixelX - pos.x;\r\n      const dy = pixelY - pos.y;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      if (distance < maxDistance && distance < minDistance) {\r\n        minDistance = distance;\r\n        closestVertex = vertex;\r\n      }\r\n    }\r\n\r\n    return closestVertex;\r\n  }\r\n\r\n  /**\r\n   * Convertit les coordonn\u00E9es pixel (x, y) en Vertex (sommet) parmi tous les vertices.\r\n   * Utilis\u00E9 pour d\u00E9tecter les clics sur les vertices constructibles d'avant-postes.\r\n   * @param pixelX - Coordonn\u00E9e X du pixel\r\n   * @param pixelY - Coordonn\u00E9e Y du pixel\r\n   * @param maxDistance - Distance maximale en pixels pour consid\u00E9rer qu'on a cliqu\u00E9 sur un sommet (d\u00E9faut: 32)\r\n   * @returns Le sommet le plus proche du point cliqu\u00E9, ou null si aucun sommet n'est assez proche\r\n   */\r\n  pixelToVertexAny(pixelX: number, pixelY: number, maxDistance: number = 32): Vertex | null {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return null;\r\n    }\r\n\r\n    const gameMap = this.currentGameMap;\r\n    const grid = gameMap.getGrid();\r\n    const allVertices = grid.getAllVertices();\r\n\r\n    let closestVertex: Vertex | null = null;\r\n    let minDistance = Infinity;\r\n\r\n    for (const vertex of allVertices) {\r\n      // V\u00E9rifier que tous les hexagones du vertex existent\r\n      const vertexHexes = vertex.getHexes();\r\n      const allVertexHexesExist = vertexHexes.every(h => grid.hasHex(h));\r\n      if (!allVertexHexesExist) {\r\n        continue;\r\n      }\r\n\r\n      // Calculer la position du vertex\r\n      const pos = this.getVertexPosition(vertex, this.currentConfig);\r\n\r\n      // Calculer la distance du point cliqu\u00E9 au vertex\r\n      const dx = pixelX - pos.x;\r\n      const dy = pixelY - pos.y;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      if (distance < maxDistance && distance < minDistance) {\r\n        minDistance = distance;\r\n        closestVertex = vertex;\r\n      }\r\n    }\r\n\r\n    return closestVertex;\r\n  }\r\n\r\n  /**\r\n   * Convertit les coordonn\u00E9es pixel (x, y) en Edge (ar\u00EAte) si le clic est proche d'une ar\u00EAte.\r\n   * @param pixelX - Coordonn\u00E9e X du pixel\r\n   * @param pixelY - Coordonn\u00E9e Y du pixel\r\n   * @returns L'ar\u00EAte la plus proche du point cliqu\u00E9, ou null si aucune ar\u00EAte n'est assez proche\r\n   */\r\n  pixelToEdge(pixelX: number, pixelY: number): Edge | null {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return null;\r\n    }\r\n\r\n    const gameMap = this.currentGameMap;\r\n    const grid = gameMap.getGrid();\r\n    const allEdges = grid.getAllEdges();\r\n\r\n    let closestEdge: Edge | null = null;\r\n    let minDistance = Infinity;\r\n    const maxDistance = 8; // Distance maximale en pixels pour consid\u00E9rer qu'on a cliqu\u00E9 sur une ar\u00EAte\r\n\r\n    for (const edge of allEdges) {\r\n      // Obtenir les vertices de l'edge\r\n      const vertices = gameMap.getVerticesForEdge(edge);\r\n      \r\n      if (vertices.length < 2) {\r\n        continue;\r\n      }\r\n\r\n      // Calculer les positions des deux vertices\r\n      const pos1 = this.getVertexPosition(vertices[0], this.currentConfig);\r\n      const pos2 = this.getVertexPosition(vertices[1], this.currentConfig);\r\n\r\n      // Calculer la distance du point cliqu\u00E9 au segment de ligne form\u00E9 par les deux vertices\r\n      const distance = this.distanceToLineSegment(pixelX, pixelY, pos1.x, pos1.y, pos2.x, pos2.y);\r\n\r\n      if (distance < maxDistance && distance < minDistance) {\r\n        minDistance = distance;\r\n        closestEdge = edge;\r\n      }\r\n    }\r\n\r\n    return closestEdge;\r\n  }\r\n\r\n  /**\r\n   * Calcule la distance d'un point \u00E0 un segment de ligne.\r\n   * @param px - Coordonn\u00E9e X du point\r\n   * @param py - Coordonn\u00E9e Y du point\r\n   * @param x1 - Coordonn\u00E9e X du premier point du segment\r\n   * @param y1 - Coordonn\u00E9e Y du premier point du segment\r\n   * @param x2 - Coordonn\u00E9e X du deuxi\u00E8me point du segment\r\n   * @param y2 - Coordonn\u00E9e Y du deuxi\u00E8me point du segment\r\n   * @returns La distance minimale du point au segment\r\n   */\r\n  private distanceToLineSegment(\r\n    px: number,\r\n    py: number,\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number\r\n  ): number {\r\n    const dx = x2 - x1;\r\n    const dy = y2 - y1;\r\n    const lengthSquared = dx * dx + dy * dy;\r\n\r\n    if (lengthSquared === 0) {\r\n      // Le segment est un point\r\n      const dx2 = px - x1;\r\n      const dy2 = py - y1;\r\n      return Math.sqrt(dx2 * dx2 + dy2 * dy2);\r\n    }\r\n\r\n    // Calculer le param\u00E8tre t qui repr\u00E9sente la projection du point sur le segment\r\n    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSquared));\r\n\r\n    // Calculer le point le plus proche sur le segment\r\n    const closestX = x1 + t * dx;\r\n    const closestY = y1 + t * dy;\r\n\r\n    // Calculer la distance\r\n    const dx3 = px - closestX;\r\n    const dy3 = py - closestY;\r\n    return Math.sqrt(dx3 * dx3 + dy3 * dy3);\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit le callback \u00E0 appeler lorsqu'un vertex constructible pour un avant-poste est cliqu\u00E9.\r\n   * @param callback - Fonction appel\u00E9e avec le vertex cliqu\u00E9\r\n   */\r\n  setOnOutpostVertexClick(callback: (vertex: Vertex) => void): void {\r\n    this.onOutpostVertexClickCallback = callback;\r\n    this.setupClickHandler();\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit le callback \u00E0 appeler lorsqu'une ar\u00EAte (route) est cliqu\u00E9e.\r\n   * @param callback - Fonction appel\u00E9e avec l'ar\u00EAte cliqu\u00E9e\r\n   */\r\n  setOnEdgeClick(callback: (edge: Edge) => void): void {\r\n    this.onEdgeClickCallback = callback;\r\n    this.setupClickHandler();\r\n  }\r\n\r\n  /**\r\n   * Configure le gestionnaire de clic unique qui g\u00E8re \u00E0 la fois les clics sur les edges et les hexagones.\r\n   * Priorit\u00E9 aux edges : si on clique sur un edge, on ne d\u00E9clenche pas le clic sur l'hexagone.\r\n   */\r\n  private setupClickHandler(): void {\r\n    // Supprimer les anciens listeners s'ils existent\r\n    this.canvas.removeEventListener('click', this.handleClick);\r\n    \r\n    // Ajouter le nouveau listener\r\n    this.canvas.addEventListener('click', this.handleClick);\r\n  }\r\n\r\n  /**\r\n   * Configure le gestionnaire de mouvement de souris pour la surbrillance des routes constructibles.\r\n   */\r\n  private setupMouseMoveHandler(): void {\r\n    this.canvas.addEventListener('mousemove', this.handleMouseMove);\r\n    this.canvas.addEventListener('mouseleave', this.handleMouseLeave);\r\n  }\r\n\r\n  /**\r\n   * Configure le tooltip pour afficher les informations des routes constructibles.\r\n   */\r\n  private setupTooltip(): void {\r\n    // Cr\u00E9er l'\u00E9l\u00E9ment tooltip s'il n'existe pas\r\n    if (!this.tooltipElement) {\r\n      this.tooltipElement = document.createElement('div');\r\n      this.tooltipElement.className = 'road-tooltip';\r\n      this.tooltipElement.style.cssText = `\r\n        position: absolute;\r\n        pointer-events: none;\r\n        background-color: rgba(0, 0, 0, 0.8);\r\n        color: white;\r\n        padding: 8px 12px;\r\n        border-radius: 4px;\r\n        font-size: 12px;\r\n        font-family: Arial, sans-serif;\r\n        z-index: 1000;\r\n        white-space: nowrap;\r\n        display: none;\r\n        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\r\n      `;\r\n      document.body.appendChild(this.tooltipElement);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Met \u00E0 jour le tooltip avec les informations de co\u00FBt d'une route constructible.\r\n   */\r\n  private updateTooltip(edge: Edge, event: MouseEvent): void {\r\n    if (!this.tooltipElement || !this.currentGameMap || !this.currentCivilizationId) {\r\n      return;\r\n    }\r\n\r\n    // S'assurer que le tooltip d'avant-poste est masqu\u00E9\r\n    this.tooltipOutpostVertex = null;\r\n\r\n    // Calculer la distance\r\n    const distance = this.currentGameMap.calculateBuildableRoadDistance(edge, this.currentCivilizationId);\r\n    if (distance === undefined) {\r\n      this.hideTooltip();\r\n      return;\r\n    }\r\n\r\n    // Calculer le co\u00FBt\r\n    const cost = RoadConstruction.getCost(distance);\r\n    const brickCost = cost.get(ResourceType.Brick) || 0;\r\n    const woodCost = cost.get(ResourceType.Wood) || 0;\r\n\r\n    // Mettre \u00E0 jour le contenu\r\n    this.tooltipElement.textContent = `${brickCost} Brique${brickCost > 1 ? 's' : ''}, ${woodCost} Bois (distance: ${distance})`;\r\n\r\n    // Positionner le tooltip pr\u00E8s du curseur\r\n    this.tooltipElement.style.left = `${event.clientX + 15}px`;\r\n    this.tooltipElement.style.top = `${event.clientY + 15}px`;\r\n    this.tooltipElement.style.display = 'block';\r\n\r\n    this.tooltipEdge = edge;\r\n  }\r\n\r\n  /**\r\n   * Met \u00E0 jour le tooltip avec les informations de co\u00FBt d'un avant-poste constructible.\r\n   */\r\n  private updateOutpostTooltip(vertex: Vertex, event: MouseEvent): void {\r\n    if (!this.tooltipElement || !this.currentGameMap || !this.currentCivilizationId) {\r\n      return;\r\n    }\r\n\r\n    // S'assurer que le tooltip de route est masqu\u00E9\r\n    this.tooltipEdge = null;\r\n\r\n    // Calculer le co\u00FBt\r\n    const cityCount = this.currentGameMap.getCityCount();\r\n    const cost = OutpostController.getBuildableOutpostCost(cityCount);\r\n    const woodCost = cost.get(ResourceType.Wood) || 0;\r\n    const brickCost = cost.get(ResourceType.Brick) || 0;\r\n    const wheatCost = cost.get(ResourceType.Wheat) || 0;\r\n    const sheepCost = cost.get(ResourceType.Sheep) || 0;\r\n\r\n    // Mettre \u00E0 jour le contenu\r\n    this.tooltipElement.textContent = \r\n      `${woodCost} Bois, ${brickCost} Brique, ${wheatCost} Bl\u00E9, ${sheepCost} Mouton (${cityCount} ville${cityCount > 1 ? 's' : ''})`;\r\n\r\n    // Positionner le tooltip pr\u00E8s du curseur\r\n    this.tooltipElement.style.left = `${event.clientX + 15}px`;\r\n    this.tooltipElement.style.top = `${event.clientY + 15}px`;\r\n    this.tooltipElement.style.display = 'block';\r\n\r\n    this.tooltipOutpostVertex = vertex;\r\n  }\r\n\r\n  /**\r\n   * Masque le tooltip.\r\n   */\r\n  private hideTooltip(): void {\r\n    if (this.tooltipElement) {\r\n      this.tooltipElement.style.display = 'none';\r\n      this.tooltipEdge = null;\r\n      this.tooltipOutpostVertex = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gestionnaire de mouvement de souris pour mettre en surbrillance les routes constructibles et les villes.\r\n   */\r\n  private handleMouseMove = (event: MouseEvent): void => {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    const rect = this.canvas.getBoundingClientRect();\r\n    \r\n    // Calculer les coordonn\u00E9es en tenant compte de l'\u00E9chelle CSS si le canvas est redimensionn\u00E9\r\n    const scaleX = this.canvas.width / rect.width;\r\n    const scaleY = this.canvas.height / rect.height;\r\n    \r\n    const pixelX = (event.clientX - rect.left) * scaleX;\r\n    const pixelY = (event.clientY - rect.top) * scaleY;\r\n\r\n    let needsRender = false;\r\n\r\n    // PRIORIT\u00C9 1: V\u00E9rifier d'abord si on survole une ville existante\r\n    const vertex = this.pixelToVertex(pixelX, pixelY);\r\n    if (vertex && this.currentGameMap && this.currentGameMap.hasCity(vertex)) {\r\n      // On survole une ville existante\r\n      if (!this.hoveredVertex || !this.hoveredVertex.equals(vertex)) {\r\n        this.hoveredVertex = vertex;\r\n        // Retirer la surbrillance des routes et avant-postes si on survole une ville\r\n        if (this.hoveredEdge !== null) {\r\n          this.hoveredEdge = null;\r\n        }\r\n        if (this.hoveredOutpostVertex !== null) {\r\n          this.hoveredOutpostVertex = null;\r\n        }\r\n        // Masquer le tooltip\r\n        this.hideTooltip();\r\n        needsRender = true;\r\n      }\r\n    } else {\r\n      // Pas de ville sur ce vertex, v\u00E9rifier si c'est un avant-poste constructible\r\n      if (this.currentCivilizationId) {\r\n        // Utiliser pixelToVertexAny pour trouver tous les vertices\r\n        const vertex = this.pixelToVertexAny(pixelX, pixelY, 16);\r\n        if (vertex && !this.currentGameMap.hasCity(vertex)) {\r\n          const buildableOutposts = this.currentGameMap.getBuildableOutpostVertices(this.currentCivilizationId);\r\n          const isBuildableOutpost = buildableOutposts.some(buildableVertex => buildableVertex.equals(vertex));\r\n          \r\n          if (isBuildableOutpost) {\r\n            if (!this.hoveredOutpostVertex || !this.hoveredOutpostVertex.equals(vertex)) {\r\n              this.hoveredOutpostVertex = vertex;\r\n              // Retirer la surbrillance des routes si on survole un avant-poste\r\n              if (this.hoveredEdge !== null) {\r\n                this.hoveredEdge = null;\r\n              }\r\n              needsRender = true;\r\n            }\r\n            // Afficher le tooltip avec le co\u00FBt\r\n            this.updateOutpostTooltip(vertex, event);\r\n          } else {\r\n            // Vertex non constructible, retirer la surbrillance\r\n            if (this.hoveredOutpostVertex !== null) {\r\n              this.hoveredOutpostVertex = null;\r\n              needsRender = true;\r\n            }\r\n            // V\u00E9rifier les routes constructibles\r\n            const edge = this.pixelToEdge(pixelX, pixelY);\r\n            \r\n            if (edge) {\r\n              const buildableRoads = this.currentGameMap.getBuildableRoadsForCivilization(this.currentCivilizationId);\r\n              const isBuildable = buildableRoads.some(buildableEdge => buildableEdge.equals(edge));\r\n              \r\n              if (isBuildable) {\r\n                if (!this.hoveredEdge || !this.hoveredEdge.equals(edge)) {\r\n                  this.hoveredEdge = edge;\r\n                  needsRender = true;\r\n                }\r\n                // Afficher le tooltip avec le co\u00FBt\r\n                this.updateTooltip(edge, event);\r\n              } else {\r\n                // Route non constructible, retirer la surbrillance\r\n                if (this.hoveredEdge !== null) {\r\n                  this.hoveredEdge = null;\r\n                  needsRender = true;\r\n                }\r\n                // Masquer le tooltip\r\n                this.hideTooltip();\r\n              }\r\n            } else {\r\n              // Pas d'ar\u00EAte constructible, retirer la surbrillance\r\n              if (this.hoveredEdge !== null) {\r\n                this.hoveredEdge = null;\r\n                needsRender = true;\r\n              }\r\n              // Masquer le tooltip\r\n              this.hideTooltip();\r\n            }\r\n          }\r\n        } else {\r\n          // Pas de vertex trouv\u00E9, v\u00E9rifier les routes constructibles\r\n          const edge = this.pixelToEdge(pixelX, pixelY);\r\n          \r\n          if (edge) {\r\n            const buildableRoads = this.currentGameMap.getBuildableRoadsForCivilization(this.currentCivilizationId);\r\n            const isBuildable = buildableRoads.some(buildableEdge => buildableEdge.equals(edge));\r\n            \r\n            if (isBuildable) {\r\n              if (!this.hoveredEdge || !this.hoveredEdge.equals(edge)) {\r\n                this.hoveredEdge = edge;\r\n                needsRender = true;\r\n              }\r\n              // Afficher le tooltip avec le co\u00FBt\r\n              this.updateTooltip(edge, event);\r\n            } else {\r\n              // Route non constructible, retirer la surbrillance\r\n              if (this.hoveredEdge !== null) {\r\n                this.hoveredEdge = null;\r\n                needsRender = true;\r\n              }\r\n              // Masquer le tooltip\r\n              this.hideTooltip();\r\n            }\r\n          } else {\r\n            // Pas d'ar\u00EAte constructible, retirer la surbrillance\r\n            if (this.hoveredEdge !== null) {\r\n              this.hoveredEdge = null;\r\n              needsRender = true;\r\n            }\r\n            // Masquer le tooltip\r\n            this.hideTooltip();\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Retirer la surbrillance de la ville si on ne survole plus\r\n      if (this.hoveredVertex !== null) {\r\n        this.hoveredVertex = null;\r\n        needsRender = true;\r\n      }\r\n      \r\n      // Si on n'a pas trouv\u00E9 d'avant-poste constructible, v\u00E9rifier les routes constructibles\r\n      if (this.hoveredOutpostVertex === null && this.currentCivilizationId) {\r\n        const edge = this.pixelToEdge(pixelX, pixelY);\r\n        \r\n        if (edge) {\r\n          const buildableRoads = this.currentGameMap.getBuildableRoadsForCivilization(this.currentCivilizationId);\r\n          const isBuildable = buildableRoads.some(buildableEdge => buildableEdge.equals(edge));\r\n          \r\n          if (isBuildable) {\r\n            if (!this.hoveredEdge || !this.hoveredEdge.equals(edge)) {\r\n              this.hoveredEdge = edge;\r\n              needsRender = true;\r\n            }\r\n            // Afficher le tooltip avec le co\u00FBt\r\n            this.updateTooltip(edge, event);\r\n          } else {\r\n            // Route non constructible, retirer la surbrillance\r\n            if (this.hoveredEdge !== null) {\r\n              this.hoveredEdge = null;\r\n              needsRender = true;\r\n            }\r\n            // Masquer le tooltip\r\n            this.hideTooltip();\r\n          }\r\n        } else {\r\n          // Pas d'ar\u00EAte constructible, retirer la surbrillance\r\n          if (this.hoveredEdge !== null) {\r\n            this.hoveredEdge = null;\r\n            needsRender = true;\r\n          }\r\n          // Masquer le tooltip\r\n          this.hideTooltip();\r\n        }\r\n      }\r\n\r\n      // Retirer la surbrillance de la ville et des avant-postes si on ne survole plus\r\n      if (this.hoveredVertex !== null) {\r\n        this.hoveredVertex = null;\r\n        needsRender = true;\r\n      }\r\n      if (this.hoveredOutpostVertex !== null) {\r\n        this.hoveredOutpostVertex = null;\r\n        needsRender = true;\r\n      }\r\n    }\r\n\r\n    // Re-rendre seulement si n\u00E9cessaire\r\n    if (needsRender && this.renderCallback) {\r\n      this.renderCallback();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Gestionnaire quand la souris quitte le canvas.\r\n   */\r\n  private handleMouseLeave = (): void => {\r\n    let needsRender = false;\r\n    \r\n    if (this.hoveredEdge !== null) {\r\n      this.hoveredEdge = null;\r\n      needsRender = true;\r\n    }\r\n    \r\n    if (this.hoveredVertex !== null) {\r\n      this.hoveredVertex = null;\r\n      needsRender = true;\r\n    }\r\n\r\n    if (this.hoveredOutpostVertex !== null) {\r\n      this.hoveredOutpostVertex = null;\r\n      needsRender = true;\r\n    }\r\n\r\n    // Masquer le tooltip\r\n    this.hideTooltip();\r\n\r\n    if (needsRender && this.renderCallback) {\r\n      this.renderCallback();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Gestionnaire de clic qui v\u00E9rifie d'abord les villes (priorit\u00E9 maximale), puis les edges, puis les hexagones.\r\n   */\r\n  private handleClick = (event: MouseEvent): void => {\r\n    const rect = this.canvas.getBoundingClientRect();\r\n    \r\n    // Calculer les coordonn\u00E9es en tenant compte de l'\u00E9chelle CSS si le canvas est redimensionn\u00E9\r\n    const scaleX = this.canvas.width / rect.width;\r\n    const scaleY = this.canvas.height / rect.height;\r\n    \r\n    const pixelX = (event.clientX - rect.left) * scaleX;\r\n    const pixelY = (event.clientY - rect.top) * scaleY;\r\n\r\n    // PRIORIT\u00C9 1: V\u00E9rifier d'abord si on a cliqu\u00E9 sur une ville (vertex avec ville)\r\n    const vertex = this.pixelToVertex(pixelX, pixelY);\r\n    if (vertex && this.currentGameMap && this.currentGameMap.hasCity(vertex)) {\r\n      // S\u00E9lectionner/d\u00E9s\u00E9lectionner la ville\r\n      if (this.selectedVertex && this.selectedVertex.equals(vertex)) {\r\n        // D\u00E9s\u00E9lectionner si on reclique sur la m\u00EAme ville\r\n        this.selectedVertex = null;\r\n      } else {\r\n        // S\u00E9lectionner la nouvelle ville\r\n        this.selectedVertex = vertex;\r\n      }\r\n      \r\n      // Appeler le callback si d\u00E9fini\r\n      if (this.onVertexClickCallback) {\r\n        this.onVertexClickCallback(vertex);\r\n      }\r\n      \r\n      // Re-rendre pour afficher la s\u00E9lection\r\n      if (this.renderCallback) {\r\n        this.renderCallback();\r\n      }\r\n      \r\n      return; // Ne pas v\u00E9rifier les edges ni les hexagones si on a cliqu\u00E9 sur une ville\r\n    }\r\n\r\n    // Si on a cliqu\u00E9 ailleurs que sur une ville, d\u00E9s\u00E9lectionner\r\n    if (this.selectedVertex !== null) {\r\n      this.selectedVertex = null;\r\n      if (this.renderCallback) {\r\n        this.renderCallback();\r\n      }\r\n    }\r\n\r\n    // PRIORIT\u00C9 2: V\u00E9rifier si on a cliqu\u00E9 sur un vertex constructible pour un avant-poste\r\n    if (this.onOutpostVertexClickCallback && this.currentCivilizationId) {\r\n      // Utiliser pixelToVertexAny pour trouver tous les vertices, pas seulement ceux avec une ville\r\n      // Utiliser une distance maximale de 16 pixels (2x le rayon de base de 8)\r\n      const vertex = this.pixelToVertexAny(pixelX, pixelY, 16);\r\n      if (vertex && this.currentGameMap) {\r\n        // V\u00E9rifier que ce vertex n'a pas d\u00E9j\u00E0 une ville\r\n        if (!this.currentGameMap.hasCity(vertex)) {\r\n          const buildableOutposts = this.currentGameMap.getBuildableOutpostVertices(this.currentCivilizationId);\r\n          const isBuildableOutpost = buildableOutposts.some(buildableVertex => buildableVertex.equals(vertex));\r\n          \r\n          if (isBuildableOutpost) {\r\n            this.onOutpostVertexClickCallback(vertex);\r\n            return; // Ne pas v\u00E9rifier les edges ni les hexagones si on a cliqu\u00E9 sur un avant-poste\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // PRIORIT\u00C9 3: V\u00E9rifier si on a cliqu\u00E9 sur un edge\r\n    if (this.onEdgeClickCallback) {\r\n      const edge = this.pixelToEdge(pixelX, pixelY);\r\n      if (edge) {\r\n        this.onEdgeClickCallback(edge);\r\n        return; // Ne pas v\u00E9rifier les hexagones si on a cliqu\u00E9 sur un edge\r\n      }\r\n    }\r\n\r\n    // PRIORIT\u00C9 4: V\u00E9rifier si on a cliqu\u00E9 sur un hexagone\r\n    if (this.onHexClickCallback) {\r\n      const hexCoord = this.pixelToHexCoord(pixelX, pixelY);\r\n      if (hexCoord && this.currentGameMap && this.currentCivilizationId) {\r\n        // Bloquer les clics sur les hexes automatiquement r\u00E9colt\u00E9s\r\n        if (BuildingProductionController.isHexAutoHarvested(hexCoord, this.currentCivilizationId, this.currentGameMap)) {\r\n          return; // Ne pas traiter le clic si l'hex est auto-r\u00E9colt\u00E9\r\n        }\r\n        this.onHexClickCallback(hexCoord);\r\n      }\r\n    }\r\n  };\r\n}\r\n", "import { BuildingType, getBuildingCost, getRequiredHexType } from '../model/city/BuildingType';\nimport { City } from '../model/city/City';\nimport { CityLevel } from '../model/city/CityLevel';\nimport { GameMap } from '../model/map/GameMap';\nimport { Vertex } from '../model/hex/Vertex';\nimport { PlayerResources } from '../model/game/PlayerResources';\nimport { ResourceType } from '../model/map/ResourceType';\nimport { HexType } from '../model/map/HexType';\n\n/**\n * Statut d'un b\u00E2timent constructible avec v\u00E9rification des ressources.\n */\nexport interface BuildableBuildingStatus {\n  /** Le type de b\u00E2timent */\n  buildingType: BuildingType;\n  /** true si la ville peut construire ET le joueur a les ressources */\n  canBuild: boolean;\n  /** true si le b\u00E2timent est bloqu\u00E9 uniquement par la limite de b\u00E2timents */\n  blockedByBuildingLimit: boolean;\n  /** Le co\u00FBt de construction */\n  cost: Map<ResourceType, number>;\n}\n\n/**\n * Contr\u00F4leur pour g\u00E9rer la construction de b\u00E2timents avec consommation de ressources.\n * \n * Cette classe orchestre la logique de construction de b\u00E2timents en coordonnant\n * les v\u00E9rifications m\u00E9tier (City.canBuildBuildingType) avec la consommation de ressources.\n */\nexport class BuildingController {\n  /**\n   * V\u00E9rifie si un b\u00E2timent peut \u00EAtre construit dans une ville donn\u00E9e.\n   * V\u00E9rifie \u00E0 la fois les conditions de la ville, les ressources disponibles\n   * et la pr\u00E9sence d'un hex adjacent du type requis (pour les b\u00E2timents de ressources).\n   * \n   * @param buildingType - Le type de b\u00E2timent \u00E0 construire\n   * @param city - La ville o\u00F9 construire\n   * @param map - La carte de jeu (requis pour v\u00E9rifier les hex adjacents)\n   * @param vertex - Le sommet de la ville (requis pour v\u00E9rifier les hex adjacents)\n   * @param resources - Les ressources du joueur\n   * @returns true si le b\u00E2timent peut \u00EAtre construit\n   */\n  static canBuild(\n    buildingType: BuildingType,\n    city: City,\n    map: GameMap,\n    vertex: Vertex,\n    resources: PlayerResources\n  ): boolean {\n    // V\u00E9rifier que la ville peut construire ce type de b\u00E2timent\n    if (!city.canBuildBuildingType(buildingType)) {\n      return false;\n    }\n\n    // V\u00E9rifier que le joueur a assez de ressources\n    const cost = getBuildingCost(buildingType);\n    if (!resources.canAfford(cost)) {\n      return false;\n    }\n\n    // V\u00E9rifier la pr\u00E9sence d'un hex adjacent du type requis (pour les b\u00E2timents de ressources)\n    const requiredHexType = getRequiredHexType(buildingType);\n    if (requiredHexType !== null) {\n      if (!this.hasAdjacentHexOfType(vertex, requiredHexType, map)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * V\u00E9rifie si au moins un hexagone adjacent au vertex (formant la ville) a le type requis.\n   * @param vertex - Le sommet de la ville\n   * @param hexType - Le type d'hex requis\n   * @param map - La carte de jeu\n   * @returns true si au moins un hex adjacent a le type requis\n   */\n  private static hasAdjacentHexOfType(vertex: Vertex, hexType: HexType, map: GameMap): boolean {\n    // Obtenir les 3 hexagones qui forment le vertex\n    const hexes = vertex.getHexes();\n\n    // V\u00E9rifier si au moins un de ces hexagones a le type requis\n    for (const hexCoord of hexes) {\n      // V\u00E9rifier que l'hex existe dans la grille\n      if (!map.getGrid().hasHex(hexCoord)) {\n        continue;\n      }\n\n      // V\u00E9rifier le type de l'hex\n      const hexTypeInMap = map.getHexType(hexCoord);\n      if (hexTypeInMap === hexType) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Construit un b\u00E2timent dans une ville.\n   * V\u00E9rifie les conditions de construction et consomme les ressources n\u00E9cessaires.\n   * \n   * @param buildingType - Le type de b\u00E2timent \u00E0 construire\n   * @param city - La ville o\u00F9 construire\n   * @param map - La carte de jeu\n   * @param vertex - Le sommet de la ville\n   * @param resources - Les ressources du joueur\n   * @throws Error si la construction n'est pas possible ou si les ressources sont insuffisantes\n   */\n  static buildBuilding(\n    buildingType: BuildingType,\n    city: City,\n    map: GameMap,\n    vertex: Vertex,\n    resources: PlayerResources\n  ): void {\n    // V\u00E9rifier que le b\u00E2timent peut \u00EAtre construit (inclut toutes les v\u00E9rifications)\n    if (!this.canBuild(buildingType, city, map, vertex, resources)) {\n      // Construire un message d'erreur d\u00E9taill\u00E9\n      let errorMessage = `Le b\u00E2timent ${buildingType} ne peut pas \u00EAtre construit dans cette ville. `;\n\n      if (!city.canBuildBuildingType(buildingType)) {\n        errorMessage += `La ville n'a peut-\u00EAtre pas le niveau requis ou a d\u00E9j\u00E0 atteint sa limite de b\u00E2timents.`;\n      } else {\n        const buildingCost = getBuildingCost(buildingType);\n        if (!resources.canAfford(buildingCost)) {\n          errorMessage += `Co\u00FBt requis: ${this.formatCost(buildingCost)}.`;\n        } else {\n          const requiredHexType = getRequiredHexType(buildingType);\n          if (requiredHexType !== null && !this.hasAdjacentHexOfType(vertex, requiredHexType, map)) {\n            errorMessage += `La ville doit avoir un hex adjacent de type ${requiredHexType}.`;\n          }\n        }\n      }\n\n      throw new Error(errorMessage);\n    }\n\n    // Retirer les ressources\n    const buildingCost = getBuildingCost(buildingType);\n    resources.payCost(buildingCost);\n\n    // Ajouter le b\u00E2timent \u00E0 la ville\n    city.addBuilding(buildingType);\n  }\n\n  /**\n   * Retourne la liste des b\u00E2timents constructibles avec leur statut (affordable ou non).\n   * \n   * @param city - La ville\n   * @param map - La carte de jeu (requis pour v\u00E9rifier les hex adjacents)\n   * @param vertex - Le sommet de la ville (requis pour v\u00E9rifier les hex adjacents)\n   * @param resources - Les ressources du joueur\n   * @returns Un tableau des b\u00E2timents constructibles avec leur statut\n   */\n  static getBuildableBuildingsWithStatus(\n    city: City,\n    map: GameMap,\n    vertex: Vertex,\n    resources: PlayerResources\n  ): BuildableBuildingStatus[] {\n    // Obtenir tous les types de b\u00E2timents (pas seulement ceux dans getBuildableBuildings)\n    // pour inclure ceux qui sont bloqu\u00E9s par la limite\n    const allBuildingTypes = BuildingType;\n    const allTypes = Object.values(allBuildingTypes) as BuildingType[];\n    const statusList: BuildableBuildingStatus[] = [];\n\n    for (const buildingType of allTypes) {\n      // Ne pas inclure les b\u00E2timents d\u00E9j\u00E0 construits\n      if (city.hasBuilding(buildingType)) {\n        continue;\n      }\n\n      // V\u00E9rifier si le b\u00E2timent peut \u00EAtre construit du point de vue de la ville (niveau suffisant)\n      // Note: Cette v\u00E9rification n'inclut pas la limite, qui sera v\u00E9rifi\u00E9e s\u00E9par\u00E9ment\n      const cityCanBuildType = city.canBuildBuildingType(buildingType);\n      \n      // V\u00E9rifier si le b\u00E2timent a un hex requis et si la ville en a un adjacent\n      const requiredHexType = getRequiredHexType(buildingType);\n      if (requiredHexType !== null) {\n        if (!this.hasAdjacentHexOfType(vertex, requiredHexType, map)) {\n          // Ne pas inclure ce b\u00E2timent dans la liste s'il n'a pas l'hex requis\n          continue;\n        }\n      }\n\n      // V\u00E9rifier le niveau requis s\u00E9par\u00E9ment (sans tenir compte de la limite)\n      const levelIsSufficient = this.checkBuildingLevelRequirement(buildingType, city);\n      if (!levelIsSufficient) {\n        // Niveau insuffisant, ne pas afficher\n        continue;\n      }\n\n      const cost = getBuildingCost(buildingType);\n      const canBuild = this.canBuild(buildingType, city, map, vertex, resources);\n      \n      // D\u00E9terminer si le blocage est uniquement d\u00FB \u00E0 la limite de b\u00E2timents\n      // Pour cela, v\u00E9rifier si toutes les autres conditions sont remplies\n      const cityCanBuildAny = city.canBuildBuilding();\n      const hasResources = resources.canAfford(cost);\n      const hasHex = requiredHexType === null || this.hasAdjacentHexOfType(vertex, requiredHexType, map);\n      \n      // Le b\u00E2timent est bloqu\u00E9 par la limite si :\n      // - Le niveau est suffisant (d\u00E9j\u00E0 v\u00E9rifi\u00E9 ci-dessus)\n      // - L'hex requis est pr\u00E9sent (ou pas d'hex requis)\n      // - Les ressources sont suffisantes\n      // - Mais la ville ne peut pas construire (limite atteinte)\n      const blockedByBuildingLimit = hasHex && hasResources && !cityCanBuildAny && !canBuild;\n\n      statusList.push({\n        buildingType,\n        canBuild,\n        blockedByBuildingLimit,\n        cost,\n      });\n    }\n\n    return statusList;\n  }\n\n  /**\n   * V\u00E9rifie si le niveau de la ville est suffisant pour construire un b\u00E2timent.\n   * @param buildingType - Le type de b\u00E2timent\n   * @param city - La ville\n   * @returns true si le niveau est suffisant\n   */\n  private static checkBuildingLevelRequirement(buildingType: BuildingType, city: City): boolean {\n    // V\u00E9rifier le niveau requis sans tenir compte de la limite ou du fait qu'il est d\u00E9j\u00E0 construit\n    switch (buildingType) {\n      case BuildingType.Seaport:\n        return city.level >= CityLevel.Town;\n      case BuildingType.Market:\n      case BuildingType.TownHall:\n        return city.level >= CityLevel.Outpost;\n      case BuildingType.Sawmill:\n      case BuildingType.Brickworks:\n      case BuildingType.Mill:\n      case BuildingType.Sheepfold:\n      case BuildingType.Mine:\n        return city.level >= CityLevel.Colony;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Formate un co\u00FBt en cha\u00EEne de caract\u00E8res pour l'affichage.\n   * @param cost - Le co\u00FBt \u00E0 formater\n   * @returns Une cha\u00EEne format\u00E9e (ex: \"3 Bois, 2 Brique\")\n   */\n  private static formatCost(cost: Map<ResourceType, number>): string {\n    const resourceNames: Record<ResourceType, string> = {\n      [ResourceType.Wood]: 'Bois',\n      [ResourceType.Brick]: 'Brique',\n      [ResourceType.Wheat]: 'Bl\u00E9',\n      [ResourceType.Sheep]: 'Mouton',\n      [ResourceType.Ore]: 'Minerai',\n    };\n\n    const parts: string[] = [];\n    for (const [resource, amount] of cost.entries()) {\n      parts.push(`${amount} ${resourceNames[resource]}`);\n    }\n    return parts.join(', ');\n  }\n}\n", "import { City } from '../model/city/City';\r\nimport { CityLevel } from '../model/city/CityLevel';\r\nimport { BuildingType, getBuildingTypeName, getBuildingAction, BUILDING_ACTION_NAMES, BuildingAction, getAllBuildingTypes, getBuildingCost, getRequiredHexType } from '../model/city/BuildingType';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\nimport { BuildingController } from '../controller/BuildingController';\r\nimport { HexMapRenderer } from './HexMapRenderer';\r\n\r\n/**\r\n * Callbacks pour les actions du panneau de ville.\r\n */\r\nexport interface CityPanelCallbacks {\r\n  /** Callback appel\u00E9 lorsqu'un b\u00E2timent doit \u00EAtre construit */\r\n  onBuildBuilding?: (buildingType: BuildingType, city: City, gameMap: GameMap, vertex: Vertex) => void;\r\n  /** Callback appel\u00E9 lors d'une action sur un b\u00E2timent construit */\r\n  onBuildingAction?: (action: BuildingAction, buildingType: BuildingType, city: City) => void;\r\n}\r\n\r\n/**\r\n * Vue pour le panneau d'affichage des d\u00E9tails d'une ville.\r\n * G\u00E8re l'affichage des informations de la ville, des b\u00E2timents constructibles et construits,\r\n * et des actions disponibles.\r\n */\r\nexport class CityPanelView {\r\n  private cityPanel: HTMLElement;\r\n  private cityPanelTitle: HTMLHeadingElement;\r\n  private cityBuildingsList: HTMLUListElement;\r\n  private cityBuildingsTitle: HTMLHeadingElement;\r\n  private callbacks: CityPanelCallbacks = {};\r\n  private renderer: HexMapRenderer | null = null;\r\n  \r\n  // Cache de l'\u00E9tat pr\u00E9c\u00E9dent pour \u00E9viter les rendus inutiles\r\n  private lastSelectedVertexHash: string | null = null;\r\n  private lastResourcesHash: string | null = null;\r\n  private lastCityBuildings: BuildingType[] | null = null;\r\n  private lastCityLevel: CityLevel | null = null;\r\n\r\n  constructor(cityPanelId: string = 'city-panel') {\r\n    const panel = document.getElementById(cityPanelId);\r\n    const title = document.getElementById('city-panel-title') as HTMLHeadingElement;\r\n    const buildingsList = document.getElementById('city-buildings-list') as HTMLUListElement;\r\n    const buildingsTitle = document.querySelector('#city-buildings-section h3') as HTMLHeadingElement;\r\n\r\n    if (!panel) {\r\n      throw new Error(`\u00C9l\u00E9ment avec l'id \"${cityPanelId}\" introuvable`);\r\n    }\r\n    if (!title) {\r\n      throw new Error('\u00C9l\u00E9ment avec l\\'id \"city-panel-title\" introuvable');\r\n    }\r\n    if (!buildingsList) {\r\n      throw new Error('\u00C9l\u00E9ment avec l\\'id \"city-buildings-list\" introuvable');\r\n    }\r\n    if (!buildingsTitle) {\r\n      throw new Error('Titre \"B\u00E2timents\" introuvable');\r\n    }\r\n\r\n    this.cityPanel = panel;\r\n    this.cityPanelTitle = title;\r\n    this.cityBuildingsList = buildingsList;\r\n    this.cityBuildingsTitle = buildingsTitle;\r\n\r\n    // Configurer les gestionnaires d'\u00E9v\u00E9nements\r\n    this.setupEventListeners();\r\n  }\r\n\r\n  /**\r\n   * Configure le renderer pour obtenir les sprites des villes.\r\n   */\r\n  setRenderer(renderer: HexMapRenderer): void {\r\n    this.renderer = renderer;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit les callbacks pour les actions du panneau.\r\n   */\r\n  setCallbacks(callbacks: CityPanelCallbacks): void {\r\n    this.callbacks = callbacks;\r\n  }\r\n\r\n  /**\r\n   * Traite un \u00E9v\u00E9nement de construction de b\u00E2timent.\r\n   * @param buildingType - Le type de b\u00E2timent \u00E0 construire\r\n   * @param city - La ville\r\n   * @param gameMap - La carte de jeu\r\n   * @param vertex - Le sommet de la ville\r\n   */\r\n  handleBuildBuilding(buildingType: BuildingType, city: City, gameMap: GameMap, vertex: Vertex): void {\r\n    if (this.callbacks.onBuildBuilding) {\r\n      this.callbacks.onBuildBuilding(buildingType, city, gameMap, vertex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Traite un \u00E9v\u00E9nement d'action sur un b\u00E2timent.\r\n   * @param action - L'action \u00E0 effectuer\r\n   * @param buildingType - Le type de b\u00E2timent\r\n   * @param city - La ville\r\n   */\r\n  handleBuildingAction(action: BuildingAction, buildingType: BuildingType, city: City): void {\r\n    if (this.callbacks.onBuildingAction) {\r\n      this.callbacks.onBuildingAction(action, buildingType, city);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure les gestionnaires d'\u00E9v\u00E9nements pour les boutons.\r\n   */\r\n  private setupEventListeners(): void {\r\n    // Utiliser la d\u00E9l\u00E9gation d'\u00E9v\u00E9nements pour g\u00E9rer les boutons cr\u00E9\u00E9s dynamiquement\r\n    this.cityBuildingsList.addEventListener('click', (e) => {\r\n      const target = e.target as HTMLElement;\r\n\r\n      // G\u00E9rer les boutons de construction\r\n      if (target.classList.contains('build-btn')) {\r\n        const button = target as HTMLButtonElement;\r\n        if (button.disabled) {\r\n          return;\r\n        }\r\n        const buildingType = button.dataset.buildingType as BuildingType;\r\n        if (!buildingType) {\r\n          return;\r\n        }\r\n\r\n        // \u00C9mettre un \u00E9v\u00E9nement personnalis\u00E9\r\n        const event = new CustomEvent('buildBuilding', {\r\n          detail: { buildingType },\r\n          bubbles: true,\r\n        });\r\n        this.cityPanel.dispatchEvent(event);\r\n      }\r\n\r\n      // G\u00E9rer les actions des b\u00E2timents construits (Am\u00E9liorer, Commerce)\r\n      if (target.classList.contains('building-action-btn')) {\r\n        const button = target as HTMLButtonElement;\r\n        if (button.disabled) {\r\n          return;\r\n        }\r\n\r\n        const buildingAction = button.dataset.buildingAction as BuildingAction;\r\n        const buildingType = button.dataset.buildingType as BuildingType;\r\n        if (!buildingAction || !buildingType) {\r\n          return;\r\n        }\r\n\r\n        // \u00C9mettre un \u00E9v\u00E9nement personnalis\u00E9\r\n        const event = new CustomEvent('buildingAction', {\r\n          detail: { buildingAction, buildingType },\r\n          bubbles: true,\r\n        });\r\n        this.cityPanel.dispatchEvent(event);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retourne l'\u00E9l\u00E9ment DOM du panneau pour permettre l'\u00E9coute d'\u00E9v\u00E9nements personnalis\u00E9s.\r\n   */\r\n  getPanelElement(): HTMLElement {\r\n    return this.cityPanel;\r\n  }\r\n\r\n  /**\r\n   * Met \u00E0 jour l'affichage du panneau de la ville s\u00E9lectionn\u00E9e.\r\n   * \u00C9vite le rendu si la ville s\u00E9lectionn\u00E9e et les ressources n'ont pas chang\u00E9.\r\n   */\r\n  update(\r\n    selectedVertex: Vertex | null,\r\n    gameMap: GameMap | null,\r\n    city: City | null,\r\n    playerResources: PlayerResources\r\n  ): void {\r\n    if (!selectedVertex || !gameMap || !city) {\r\n      // Masquer le panneau si aucune ville n'est s\u00E9lectionn\u00E9e\r\n      if (this.lastSelectedVertexHash !== null) {\r\n        this.cityPanel.classList.add('hidden');\r\n        // R\u00E9initialiser le cache\r\n        this.lastSelectedVertexHash = null;\r\n        this.lastResourcesHash = null;\r\n        this.lastCityBuildings = null;\r\n        this.lastCityLevel = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Calculer les hash pour comparer avec l'\u00E9tat pr\u00E9c\u00E9dent\r\n    const currentVertexHash = selectedVertex.hashCode();\r\n    const currentResourcesHash = this.getResourcesHash(playerResources);\r\n    const currentCityBuildings = [...city.getBuildings()].sort(); // Copie tri\u00E9e pour comparaison\r\n    const currentCityLevel = city.level;\r\n\r\n    // V\u00E9rifier si quelque chose a chang\u00E9\r\n    // Si le cache est null, c'est le premier affichage, donc on doit rendre\r\n    const isFirstRender = this.lastSelectedVertexHash === null;\r\n    const vertexChanged = this.lastSelectedVertexHash !== currentVertexHash;\r\n    const resourcesChanged = this.lastResourcesHash !== currentResourcesHash;\r\n    const buildingsChanged = !this.arraysEqual(this.lastCityBuildings, currentCityBuildings);\r\n    const levelChanged = this.lastCityLevel !== currentCityLevel;\r\n\r\n    const hasChanged =\r\n      isFirstRender ||\r\n      vertexChanged ||\r\n      resourcesChanged ||\r\n      buildingsChanged ||\r\n      levelChanged;\r\n\r\n    // Si rien n'a chang\u00E9, \u00E9viter le rendu\r\n    if (!hasChanged) {\r\n      return;\r\n    }\r\n\r\n    // Mettre \u00E0 jour le cache\r\n    this.lastSelectedVertexHash = currentVertexHash;\r\n    this.lastResourcesHash = currentResourcesHash;\r\n    this.lastCityBuildings = currentCityBuildings;\r\n    this.lastCityLevel = currentCityLevel;\r\n\r\n    // Afficher le panneau (l'animation CSS g\u00E8re la transition)\r\n    this.cityPanel.classList.remove('hidden');\r\n\r\n    // Noms des niveaux de ville en fran\u00E7ais\r\n    const cityLevelNames: Record<CityLevel, string> = {\r\n      [CityLevel.Outpost]: 'Avant-poste',\r\n      [CityLevel.Colony]: 'Colonie',\r\n      [CityLevel.Town]: 'Ville',\r\n      [CityLevel.Metropolis]: 'M\u00E9tropole',\r\n      [CityLevel.Capital]: 'Capitale',\r\n    };\r\n\r\n    // Mettre \u00E0 jour le titre avec le sprite\r\n    const levelName = cityLevelNames[city.level] || `Niveau ${city.level}`;\r\n\r\n    // Vider le titre\r\n    this.cityPanelTitle.innerHTML = '';\r\n\r\n    // Ajouter le sprite si disponible\r\n    if (this.renderer) {\r\n      const sprite = this.renderer.getCitySprite(city.level);\r\n      if (sprite && sprite.complete && sprite.naturalWidth > 0) {\r\n        const spriteImg = document.createElement('img');\r\n        spriteImg.src = sprite.src;\r\n        spriteImg.style.width = '32px';\r\n        spriteImg.style.height = '32px';\r\n        spriteImg.style.marginRight = '8px';\r\n        spriteImg.style.verticalAlign = 'middle';\r\n        spriteImg.style.display = 'inline-block';\r\n        spriteImg.alt = levelName;\r\n        this.cityPanelTitle.appendChild(spriteImg);\r\n      }\r\n    }\r\n\r\n    // Ajouter le nom de la ville\r\n    const nameSpan = document.createElement('span');\r\n    nameSpan.textContent = levelName;\r\n    this.cityPanelTitle.appendChild(nameSpan);\r\n\r\n    // Mettre \u00E0 jour la liste des b\u00E2timents\r\n    this.updateBuildingsList(city, gameMap, selectedVertex, playerResources);\r\n  }\r\n\r\n  /**\r\n   * Met \u00E0 jour la liste des b\u00E2timents dans le panneau.\r\n   * Affiche tous les b\u00E2timents dans un ordre fixe, sans s\u00E9parer les constructibles des construits.\r\n   */\r\n  private updateBuildingsList(city: City, gameMap: GameMap, vertex: Vertex, playerResources: PlayerResources): void {\r\n    // Mettre \u00E0 jour le titre avec le nombre de b\u00E2timents construits / maximum\r\n    const buildingCount = city.getBuildingCount();\r\n    const maxBuildings = city.getMaxBuildings();\r\n    this.cityBuildingsTitle.textContent = `B\u00E2timents ${buildingCount}/${maxBuildings}`;\r\n\r\n    this.cityBuildingsList.innerHTML = '';\r\n\r\n    // Noms des ressources en fran\u00E7ais pour l'affichage\r\n    const resourceNames: Record<ResourceType, string> = {\r\n      [ResourceType.Wood]: 'Bois',\r\n      [ResourceType.Brick]: 'Brique',\r\n      [ResourceType.Wheat]: 'Bl\u00E9',\r\n      [ResourceType.Sheep]: 'Mouton',\r\n      [ResourceType.Ore]: 'Minerai',\r\n    };\r\n\r\n    // Obtenir tous les b\u00E2timents possibles dans un ordre fixe\r\n    const allBuildingTypes = getAllBuildingTypes();\r\n    const builtBuildings = new Set(city.getBuildings());\r\n\r\n    // Obtenir les b\u00E2timents constructibles avec leur statut pour v\u00E9rifier si on peut les construire\r\n    const buildableBuildingsMap = new Map<BuildingType, { canBuild: boolean; blockedByBuildingLimit: boolean; cost: Map<ResourceType, number> }>();\r\n    const buildableBuildings = BuildingController.getBuildableBuildingsWithStatus(city, gameMap, vertex, playerResources);\r\n    for (const status of buildableBuildings) {\r\n      buildableBuildingsMap.set(status.buildingType, { canBuild: status.canBuild, blockedByBuildingLimit: status.blockedByBuildingLimit, cost: status.cost });\r\n    }\r\n\r\n    // Afficher tous les b\u00E2timents dans l'ordre fixe (seulement ceux qui sont construits ou constructibles)\r\n    for (const buildingType of allBuildingTypes) {\r\n      const isBuilt = builtBuildings.has(buildingType);\r\n      const buildableStatus = buildableBuildingsMap.get(buildingType);\r\n\r\n      // Ne pas afficher les b\u00E2timents qui ne sont ni construits ni constructibles\r\n      if (!isBuilt && !buildableStatus) {\r\n        continue;\r\n      }\r\n\r\n      const item = document.createElement('li');\r\n      item.className = isBuilt ? 'built-building' : 'buildable-building';\r\n\r\n      // Conteneur pour le nom et le co\u00FBt\r\n      const infoContainer = document.createElement('div');\r\n      infoContainer.className = 'building-info';\r\n\r\n      // Nom du b\u00E2timent\r\n      const nameSpan = document.createElement('span');\r\n      nameSpan.className = 'building-name';\r\n      nameSpan.textContent = getBuildingTypeName(buildingType);\r\n      infoContainer.appendChild(nameSpan);\r\n\r\n      // Si le b\u00E2timent n'est pas construit et est constructible, afficher le co\u00FBt\r\n      if (!isBuilt && buildableStatus) {\r\n        const costSpan = document.createElement('span');\r\n        costSpan.className = 'building-cost';\r\n        const costParts: string[] = [];\r\n        for (const [resource, amount] of buildableStatus.cost.entries()) {\r\n          costParts.push(`${amount} ${resourceNames[resource]}`);\r\n        }\r\n        costSpan.textContent = costParts.join(', ');\r\n        infoContainer.appendChild(costSpan);\r\n      }\r\n\r\n      item.appendChild(infoContainer);\r\n\r\n      // Si le b\u00E2timent est construit, afficher les boutons d'action\r\n      if (isBuilt) {\r\n        const buildingAction = getBuildingAction(buildingType);\r\n        if (buildingAction !== null) {\r\n          const actionBtn = document.createElement('button');\r\n          actionBtn.className = 'building-action-btn';\r\n          actionBtn.textContent = BUILDING_ACTION_NAMES[buildingAction];\r\n\r\n          // D\u00E9sactiver le bouton d'am\u00E9lioration si la ville ne peut pas \u00EAtre am\u00E9lior\u00E9e\r\n          if (buildingAction === BuildingAction.Upgrade) {\r\n            actionBtn.disabled = !city.canUpgrade();\r\n          } else {\r\n            // Pour l'instant, le bouton Trade est toujours activ\u00E9 (\u00E0 impl\u00E9menter plus tard)\r\n            actionBtn.disabled = false;\r\n          }\r\n\r\n          // Stocker l'action et le type de b\u00E2timent dans le bouton\r\n          actionBtn.dataset.buildingAction = buildingAction;\r\n          actionBtn.dataset.buildingType = buildingType;\r\n\r\n          item.appendChild(actionBtn);\r\n        }\r\n      } else {\r\n        // Si le b\u00E2timent n'est pas construit, afficher le bouton de construction s'il est constructible\r\n        if (buildableStatus) {\r\n          const buildBtn = document.createElement('button');\r\n          buildBtn.className = 'build-btn';\r\n          buildBtn.textContent = 'Construire';\r\n          // D\u00E9sactiver uniquement si bloqu\u00E9 par la limite de b\u00E2timents\r\n          // (les autres raisons ne doivent pas griser le bouton)\r\n          buildBtn.disabled = buildableStatus.blockedByBuildingLimit;\r\n\r\n          // Stocker le buildingType dans le bouton pour le gestionnaire d'\u00E9v\u00E9nement\r\n          buildBtn.dataset.buildingType = buildingType;\r\n\r\n          item.appendChild(buildBtn);\r\n        }\r\n      }\r\n\r\n      this.cityBuildingsList.appendChild(item);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash des ressources pour la comparaison.\r\n   */\r\n  private getResourcesHash(playerResources: PlayerResources): string {\r\n    const resources = playerResources.getAllResources();\r\n    const parts: string[] = [];\r\n    for (const [resource, amount] of resources.entries()) {\r\n      parts.push(`${resource}:${amount}`);\r\n    }\r\n    return parts.sort().join(',');\r\n  }\r\n\r\n  /**\r\n   * Compare deux tableaux pour l'\u00E9galit\u00E9.\r\n   */\r\n  private arraysEqual<T>(a: T[] | null, b: T[] | null): boolean {\r\n    if (a === null && b === null) return true;\r\n    if (a === null || b === null) return false;\r\n    if (a.length !== b.length) return false;\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (a[i] !== b[i]) return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import { GameMap } from '../model/map/GameMap';\nimport { CivilizationId } from '../model/map/CivilizationId';\nimport { PlayerResources } from '../model/game/PlayerResources';\nimport { ResourceType } from '../model/map/ResourceType';\nimport { BuildingType } from '../model/city/BuildingType';\n\n/**\n * Contr\u00F4leur pour g\u00E9rer le commerce.\n *\n * Une civilisation peut \u00E9changer des ressources contre 1 de son choix si elle poss\u00E8de\n * au moins un port maritime (Seaport, 3:1) ou un march\u00E9 (Market, 4:1) dans une de ses villes.\n */\nexport class TradeController {\n  private static readonly TRADE_RATE_SEAPORT = 3;\n  private static readonly TRADE_RATE_MARKET = 4;\n\n  /**\n   * Nombre de ressources re\u00E7ues lors d'un \u00E9change.\n   */\n  private static readonly TRADE_RECEIVED = 1;\n\n  /**\n   * V\u00E9rifie si une civilisation a acc\u00E8s au commerce (port maritime ou march\u00E9).\n   *\n   * @param civId - L'identifiant de la civilisation\n   * @param map - La carte de jeu\n   * @returns true si la civilisation a au moins un port maritime ou un march\u00E9\n   */\n  static canTrade(civId: CivilizationId, map: GameMap): boolean {\n    const cities = map.getCitiesByCivilization(civId);\n    for (const city of cities) {\n      if (city.hasBuilding(BuildingType.Seaport) || city.hasBuilding(BuildingType.Market)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * V\u00E9rifie si un \u00E9change est possible.\n   * V\u00E9rifie \u00E0 la fois l'acc\u00E8s au commerce et les ressources disponibles.\n   * \n   * @param fromResource - La ressource \u00E0 \u00E9changer (4 unit\u00E9s)\n   * @param toResource - La ressource \u00E0 recevoir (1 unit\u00E9)\n   * @param civId - L'identifiant de la civilisation\n   * @param map - La carte de jeu\n   * @param resources - Les ressources du joueur\n   * @returns true si l'\u00E9change est possible\n   */\n  static canPerformTrade(\n    fromResource: ResourceType,\n    toResource: ResourceType,\n    civId: CivilizationId,\n    map: GameMap,\n    resources: PlayerResources\n  ): boolean {\n    // V\u00E9rifier l'acc\u00E8s au commerce\n    if (!this.canTrade(civId, map)) {\n      return false;\n    }\n\n    // V\u00E9rifier que les ressources sont diff\u00E9rentes\n    if (fromResource === toResource) {\n      return false;\n    }\n\n    // V\u00E9rifier que le joueur a assez de ressources \u00E0 \u00E9changer\n    const tradeRate = this.getTradeRateForCivilization(civId, map);\n    if (!resources.hasEnough(fromResource, tradeRate)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Effectue un \u00E9change : X ressources identiques contre 1 ressource de choix (X = 3 avec port, 4 avec march\u00E9).\n   * \n   * @param fromResource - La ressource \u00E0 \u00E9changer (4 unit\u00E9s)\n   * @param toResource - La ressource \u00E0 recevoir (1 unit\u00E9)\n   * @param civId - L'identifiant de la civilisation\n   * @param map - La carte de jeu\n   * @param resources - Les ressources du joueur\n   * @throws Error si l'\u00E9change n'est pas possible\n   */\n  static performTrade(\n    fromResource: ResourceType,\n    toResource: ResourceType,\n    civId: CivilizationId,\n    map: GameMap,\n    resources: PlayerResources\n  ): void {\n    // V\u00E9rifier que l'\u00E9change est possible\n    if (!this.canPerformTrade(fromResource, toResource, civId, map, resources)) {\n      if (!this.canTrade(civId, map)) {\n        throw new Error(\n          'Le commerce n\\'est pas disponible. ' +\n          'Vous devez poss\u00E9der au moins un port maritime ou un march\u00E9 dans une de vos villes.'\n        );\n      }\n\n      if (fromResource === toResource) {\n        throw new Error('Vous ne pouvez pas \u00E9changer une ressource contre elle-m\u00EAme.');\n      }\n\n      const tradeRate = this.getTradeRateForCivilization(civId, map);\n      if (!resources.hasEnough(fromResource, tradeRate)) {\n        throw new Error(\n          `Pas assez de ${fromResource} pour effectuer l'\u00E9change. ` +\n          `Requis: ${tradeRate}, disponible: ${resources.getResource(fromResource)}.`\n        );\n      }\n    }\n\n    // Retirer les ressources \u00E9chang\u00E9es\n    const tradeRate = this.getTradeRateForCivilization(civId, map);\n    resources.removeResource(fromResource, tradeRate);\n\n    // Ajouter la ressource re\u00E7ue\n    resources.addResource(toResource, this.TRADE_RECEIVED);\n  }\n\n  /**\n   * Retourne le taux d'\u00E9change par d\u00E9faut (4:1, march\u00E9).\n   */\n  static getTradeRate(): number {\n    return this.TRADE_RATE_MARKET;\n  }\n\n  /**\n   * Retourne le nombre de ressources re\u00E7ues lors d'un \u00E9change.\n   */\n  static getTradeReceived(): number {\n    return this.TRADE_RECEIVED;\n  }\n\n  /**\n   * Retourne le taux d'\u00E9change pour une civilisation : 3 si elle a un port (Seaport), 4 si march\u00E9 (Market) uniquement.\n   * @param civId - L'identifiant de la civilisation\n   * @param map - La carte de jeu\n   * @returns Le nombre de ressources \u00E0 donner pour recevoir 1 (3 ou 4)\n   */\n  static getTradeRateForCivilization(civId: CivilizationId, map: GameMap): number {\n    const cities = map.getCitiesByCivilization(civId);\n    for (const city of cities) {\n      if (city.hasBuilding(BuildingType.Seaport)) return this.TRADE_RATE_SEAPORT;\n    }\n    for (const city of cities) {\n      if (city.hasBuilding(BuildingType.Market)) return this.TRADE_RATE_MARKET;\n    }\n    return this.TRADE_RATE_MARKET; // canTrade d\u00E9j\u00E0 v\u00E9rifi\u00E9 en amont\n  }\n\n  /**\n   * Effectue plusieurs \u00E9changes en une seule transaction.\n   * Valide que les quantit\u00E9s offertes sont des multiples du taux (3 ou 4 selon port/march\u00E9)\n   * et que les quantit\u00E9s demand\u00E9es sont des multiples de 1.\n   * \n   * @param offeredResources - Map des ressources offertes (quantit\u00E9s multiples de 4)\n   * @param requestedResources - Map des ressources demand\u00E9es (quantit\u00E9s multiples de 1)\n   * @param civId - L'identifiant de la civilisation\n   * @param map - La carte de jeu\n   * @param playerResources - Les ressources du joueur\n   * @throws Error si les quantit\u00E9s ne sont pas valides ou si l'\u00E9change n'est pas possible\n   */\n  static performBatchTrade(\n    offeredResources: Map<ResourceType, number>,\n    requestedResources: Map<ResourceType, number>,\n    civId: CivilizationId,\n    map: GameMap,\n    playerResources: PlayerResources\n  ): void {\n    // V\u00E9rifier l'acc\u00E8s au commerce\n    if (!this.canTrade(civId, map)) {\n      throw new Error(\n        'Le commerce n\\'est pas disponible. ' +\n        'Vous devez poss\u00E9der au moins un port maritime ou un march\u00E9 dans une de vos villes.'\n      );\n    }\n\n    const tradeRate = this.getTradeRateForCivilization(civId, map);\n\n    // Valider que toutes les quantit\u00E9s offertes sont des multiples du taux d'\u00E9change\n    for (const [resourceType, quantity] of offeredResources.entries()) {\n      if (quantity > 0 && quantity % tradeRate !== 0) {\n        throw new Error(\n          `La quantit\u00E9 offerte de ${resourceType} doit \u00EAtre un multiple de ${tradeRate}. ` +\n          `Quantit\u00E9 actuelle: ${quantity}`\n        );\n      }\n    }\n\n    // Valider que toutes les quantit\u00E9s demand\u00E9es sont des multiples de 1\n    for (const [resourceType, quantity] of requestedResources.entries()) {\n      if (quantity > 0 && quantity % this.TRADE_RECEIVED !== 0) {\n        throw new Error(\n          `La quantit\u00E9 demand\u00E9e de ${resourceType} doit \u00EAtre un multiple de ${this.TRADE_RECEIVED}. ` +\n          `Quantit\u00E9 actuelle: ${quantity}`\n        );\n      }\n    }\n\n    // V\u00E9rifier que le joueur a assez de ressources pour toutes les offres\n    for (const [resourceType, quantity] of offeredResources.entries()) {\n      if (quantity > 0) {\n        if (!playerResources.hasEnough(resourceType, quantity)) {\n          throw new Error(\n            `Pas assez de ${resourceType} pour effectuer l'\u00E9change. ` +\n            `Requis: ${quantity}, disponible: ${playerResources.getResource(resourceType)}.`\n          );\n        }\n      }\n    }\n\n    // V\u00E9rifier qu'au moins une ressource est offerte et une autre est demand\u00E9e\n    const hasOffered = Array.from(offeredResources.values()).some(qty => qty > 0);\n    const hasRequested = Array.from(requestedResources.values()).some(qty => qty > 0);\n\n    if (!hasOffered || !hasRequested) {\n      throw new Error('Vous devez proposer au moins une ressource et en demander au moins une autre.');\n    }\n\n    // Cr\u00E9er des copies temporaires pour le calcul\n    const remainingOffered = new Map(offeredResources);\n    const remainingRequested = new Map(requestedResources);\n\n    // Liste des \u00E9changes \u00E0 effectuer\n    const tradesToPerform: Array<{ from: ResourceType; to: ResourceType; count: number }> = [];\n\n    // Calculer tous les \u00E9changes possibles\n    // Pour chaque ressource demand\u00E9e, on cherche des ressources offertes \u00E0 \u00E9changer\n    for (const [toResource, requestedQty] of remainingRequested.entries()) {\n      if (requestedQty === 0) continue;\n\n      let remainingToReceive = requestedQty;\n\n      // Chercher des ressources offertes pour satisfaire cette demande\n      for (const [fromResource, offeredQty] of remainingOffered.entries()) {\n        if (remainingToReceive === 0) break;\n        if (offeredQty === 0) continue;\n        if (fromResource === toResource) continue; // Ne pas \u00E9changer contre la m\u00EAme ressource\n\n        // Calculer combien d'\u00E9changes on peut faire avec cette ressource offerte\n        const availableOffers = offeredQty / tradeRate;\n        const neededExchanges = remainingToReceive / this.TRADE_RECEIVED;\n        const exchangesToDo = Math.min(availableOffers, neededExchanges);\n\n        if (exchangesToDo > 0) {\n          tradesToPerform.push({\n            from: fromResource,\n            to: toResource,\n            count: exchangesToDo,\n          });\n\n          // Mettre \u00E0 jour les quantit\u00E9s restantes\n          remainingToReceive -= exchangesToDo * this.TRADE_RECEIVED;\n          const remainingOfferedQty = offeredQty - (exchangesToDo * tradeRate);\n          remainingOffered.set(fromResource, remainingOfferedQty);\n        }\n      }\n\n      // Si on n'a pas pu satisfaire toute la demande, c'est une erreur\n      if (remainingToReceive > 0) {\n        throw new Error(\n          `Impossible de satisfaire la demande de ${toResource}. ` +\n          `Manque ${remainingToReceive} unit\u00E9(s). ` +\n          `Pas assez de ressources offertes pour compl\u00E9ter l'\u00E9change.`\n        );\n      }\n    }\n\n    // Note : On permet que des ressources offertes restent non utilis\u00E9es\n    // si elles ne peuvent pas \u00EAtre \u00E9chang\u00E9es (pas assez de ressources demand\u00E9es)\n    // Cela permet plus de flexibilit\u00E9 dans la composition de l'\u00E9change\n\n    // Effectuer tous les \u00E9changes valid\u00E9s\n    for (const trade of tradesToPerform) {\n      for (let i = 0; i < trade.count; i++) {\n        this.performTrade(trade.from, trade.to, civId, map, playerResources);\n      }\n    }\n  }\n}\n", "import { ResourceType } from '../model/map/ResourceType';\nimport { PlayerResources } from '../model/game/PlayerResources';\nimport { ResourceSprites } from './ResourceSprites';\nimport { TradeController } from '../controller/TradeController';\nimport { GameMap } from '../model/map/GameMap';\nimport { CivilizationId } from '../model/map/CivilizationId';\n\n/**\n * Callbacks pour les actions du panneau de commerce.\n */\nexport interface TradePanelCallbacks {\n  /** Callback appel\u00E9 lorsqu'un \u00E9change doit \u00EAtre effectu\u00E9 */\n  onTrade?: (offered: Map<ResourceType, number>, requested: Map<ResourceType, number>) => void;\n  /** Callback appel\u00E9 lorsque l'utilisateur annule */\n  onCancel?: () => void;\n}\n\n/**\n * Vue pour le panneau de commerce.\n * Permet de composer un \u00E9change en s\u00E9lectionnant les ressources donn\u00E9es et re\u00E7ues.\n */\nexport class TradePanelView {\n  private tradePanel: HTMLElement;\n  private offeredList: HTMLUListElement;\n  private requestedList: HTMLUListElement;\n  private cancelBtn: HTMLButtonElement;\n  private confirmBtn: HTMLButtonElement;\n  private offeredTitle: HTMLElement;\n  private requestedTitle: HTMLElement;\n  \n  private offeredResources: Map<ResourceType, number> = new Map();\n  private requestedResources: Map<ResourceType, number> = new Map();\n  private playerResources: PlayerResources | null = null;\n  private resourceSprites: ResourceSprites | null = null;\n  private callbacks: TradePanelCallbacks = {};\n  private gameMap: GameMap | null = null;\n  private civId: CivilizationId | null = null;\n\n  // Noms des ressources en fran\u00E7ais\n  private readonly resourceNames: Record<ResourceType, string> = {\n    [ResourceType.Wood]: 'Bois',\n    [ResourceType.Brick]: 'Brique',\n    [ResourceType.Wheat]: 'Bl\u00E9',\n    [ResourceType.Sheep]: 'Mouton',\n    [ResourceType.Ore]: 'Minerai',\n  };\n\n  // Ordre d'affichage des ressources\n  private readonly resourceOrder: ResourceType[] = [\n    ResourceType.Wood,\n    ResourceType.Brick,\n    ResourceType.Wheat,\n    ResourceType.Sheep,\n    ResourceType.Ore,\n  ];\n\n  constructor(tradePanelId: string = 'trade-panel') {\n    const panel = document.getElementById(tradePanelId);\n    const offeredListEl = document.getElementById('trade-offered-list') as HTMLUListElement;\n    const requestedListEl = document.getElementById('trade-requested-list') as HTMLUListElement;\n    const cancelBtnEl = document.getElementById('trade-cancel-btn') as HTMLButtonElement;\n    const confirmBtnEl = document.getElementById('trade-confirm-btn') as HTMLButtonElement;\n    const offeredTitleEl = document.querySelector('.trade-column:first-child h3') as HTMLElement;\n    const requestedTitleEl = document.querySelector('.trade-column:last-child h3') as HTMLElement;\n\n    if (!panel) {\n      throw new Error(`\u00C9l\u00E9ment avec l'id \"${tradePanelId}\" introuvable`);\n    }\n    if (!offeredListEl) {\n      throw new Error('\u00C9l\u00E9ment avec l\\'id \"trade-offered-list\" introuvable');\n    }\n    if (!requestedListEl) {\n      throw new Error('\u00C9l\u00E9ment avec l\\'id \"trade-requested-list\" introuvable');\n    }\n    if (!cancelBtnEl) {\n      throw new Error('\u00C9l\u00E9ment avec l\\'id \"trade-cancel-btn\" introuvable');\n    }\n    if (!confirmBtnEl) {\n      throw new Error('\u00C9l\u00E9ment avec l\\'id \"trade-confirm-btn\" introuvable');\n    }\n    if (!offeredTitleEl) {\n      throw new Error('Titre \"Vous donnez\" introuvable');\n    }\n    if (!requestedTitleEl) {\n      throw new Error('Titre \"Vous recevez\" introuvable');\n    }\n\n    this.tradePanel = panel;\n    this.offeredList = offeredListEl;\n    this.requestedList = requestedListEl;\n    this.cancelBtn = cancelBtnEl;\n    this.confirmBtn = confirmBtnEl;\n    this.offeredTitle = offeredTitleEl;\n    this.requestedTitle = requestedTitleEl;\n\n    // Configurer les gestionnaires d'\u00E9v\u00E9nements\n    this.setupEventListeners();\n  }\n\n  /**\n   * Configure le gestionnaire de sprites de ressources.\n   */\n  setResourceSprites(resourceSprites: ResourceSprites): void {\n    this.resourceSprites = resourceSprites;\n  }\n\n  /**\n   * D\u00E9finit les callbacks pour les actions du panneau.\n   */\n  setCallbacks(callbacks: TradePanelCallbacks): void {\n    this.callbacks = callbacks;\n  }\n\n  /**\n   * Configure les gestionnaires d'\u00E9v\u00E9nements.\n   */\n  private setupEventListeners(): void {\n    // Bouton Annuler\n    this.cancelBtn.addEventListener('click', () => {\n      this.hide();\n      if (this.callbacks.onCancel) {\n        this.callbacks.onCancel();\n      }\n    });\n\n    // Bouton \u00C9changer\n    this.confirmBtn.addEventListener('click', () => {\n      if (this.callbacks.onTrade) {\n        this.callbacks.onTrade(\n          new Map(this.offeredResources),\n          new Map(this.requestedResources)\n        );\n      }\n    });\n  }\n\n  /**\n   * Configure la carte de jeu et la civilisation pour v\u00E9rifier l'acc\u00E8s au commerce.\n   */\n  setGameContext(gameMap: GameMap, civId: CivilizationId): void {\n    this.gameMap = gameMap;\n    this.civId = civId;\n  }\n\n  /**\n   * Affiche le panneau de commerce et initialise les listes.\n   */\n  show(playerResources: PlayerResources): void {\n    this.playerResources = playerResources;\n    this.offeredResources.clear();\n    this.requestedResources.clear();\n    \n    // Initialiser toutes les ressources \u00E0 0\n    for (const resourceType of this.resourceOrder) {\n      this.offeredResources.set(resourceType, 0);\n      this.requestedResources.set(resourceType, 0);\n    }\n\n    this.update();\n    this.tradePanel.classList.remove('hidden');\n  }\n\n  /**\n   * Cache le panneau de commerce.\n   */\n  hide(): void {\n    this.tradePanel.classList.add('hidden');\n    this.offeredResources.clear();\n    this.requestedResources.clear();\n  }\n\n  /**\n   * Met \u00E0 jour l'affichage des listes et du bouton \u00C9changer.\n   */\n  private update(): void {\n    if (!this.playerResources) {\n      return;\n    }\n\n    // Mettre \u00E0 jour la liste des ressources offertes (gauche)\n    this.updateResourceList(this.offeredList, this.offeredResources, true);\n\n    // Mettre \u00E0 jour la liste des ressources demand\u00E9es (droite)\n    this.updateResourceList(this.requestedList, this.requestedResources, false);\n\n    // Mettre \u00E0 jour les titres avec le nombre de batches\n    this.updateTitles();\n\n    // Mettre \u00E0 jour le bouton \u00C9changer\n    this.updateConfirmButton();\n  }\n\n  /**\n   * Met \u00E0 jour une liste de ressources.\n   */\n  private updateResourceList(\n    listElement: HTMLUListElement,\n    resourceMap: Map<ResourceType, number>,\n    isOffered: boolean\n  ): void {\n    listElement.innerHTML = '';\n\n    const rate = (this.civId && this.gameMap)\n      ? TradeController.getTradeRateForCivilization(this.civId, this.gameMap)\n      : 4;\n\n    for (const resourceType of this.resourceOrder) {\n      const quantity = resourceMap.get(resourceType) || 0;\n      const available = this.playerResources?.getResource(resourceType) || 0;\n\n      const item = document.createElement('li');\n      item.className = 'trade-resource-item';\n      \n      // Pour la liste offerte, d\u00E9sactiver visuellement si on n'a pas assez pour un \u00E9change minimum\n      if (isOffered && available < rate) {\n        item.classList.add('disabled');\n      }\n\n      // Conteneur pour le sprite et le nom\n      const resourceInfo = document.createElement('div');\n      resourceInfo.className = 'trade-resource-info';\n\n      // Sprite de ressource\n      if (this.resourceSprites) {\n        const sprite = this.resourceSprites.getSprite(resourceType);\n        const spriteReady = this.resourceSprites.isSpriteReady(resourceType);\n        \n        if (spriteReady && sprite) {\n          const spriteImg = document.createElement('img');\n          spriteImg.src = sprite.src;\n          spriteImg.className = 'trade-resource-sprite';\n          spriteImg.alt = this.resourceNames[resourceType];\n          spriteImg.style.width = '32px';\n          spriteImg.style.height = '32px';\n          spriteImg.style.objectFit = 'contain';\n          resourceInfo.appendChild(spriteImg);\n        } else {\n          // Fallback : carr\u00E9 de couleur\n          const color = document.createElement('div');\n          color.className = 'trade-resource-color';\n          const resourceColors: Record<ResourceType, string> = {\n            [ResourceType.Wood]: '#8B4513',\n            [ResourceType.Brick]: '#CD5C5C',\n            [ResourceType.Wheat]: '#FFD700',\n            [ResourceType.Sheep]: '#90EE90',\n            [ResourceType.Ore]: '#708090',\n          };\n          color.style.backgroundColor = resourceColors[resourceType];\n          resourceInfo.appendChild(color);\n        }\n      }\n\n      // Nom de la ressource\n      const nameSpan = document.createElement('span');\n      nameSpan.className = 'trade-resource-name';\n      nameSpan.textContent = this.resourceNames[resourceType];\n      resourceInfo.appendChild(nameSpan);\n\n      item.appendChild(resourceInfo);\n\n      // Quantit\u00E9\n      const quantitySpan = document.createElement('span');\n      quantitySpan.className = 'trade-resource-quantity';\n      quantitySpan.textContent = quantity > 0 ? `\u00D7${quantity}` : '';\n      item.appendChild(quantitySpan);\n\n      // Gestionnaires de clic (gauche et droit)\n      if (!item.classList.contains('disabled')) {\n        if (isOffered) {\n          // Clic gauche : ajouter un batch\n          item.addEventListener('click', () => {\n            this.handleOfferedClick(resourceType);\n          });\n          // Clic droit : retirer un batch\n          item.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n            this.handleOfferedRightClick(resourceType);\n          });\n        } else {\n          // Clic gauche : ajouter une ressource\n          item.addEventListener('click', () => {\n            this.handleRequestedClick(resourceType);\n          });\n          // Clic droit : retirer une ressource\n          item.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n            this.handleRequestedRightClick(resourceType);\n          });\n        }\n      }\n\n      listElement.appendChild(item);\n    }\n  }\n\n  /**\n   * G\u00E8re le clic sur une ressource dans la liste des ressources offertes.\n   */\n  private handleOfferedClick(resourceType: ResourceType): void {\n    if (!this.playerResources) {\n      return;\n    }\n\n    const rate = (this.civId && this.gameMap)\n      ? TradeController.getTradeRateForCivilization(this.civId, this.gameMap)\n      : 4;\n    const current = this.offeredResources.get(resourceType) || 0;\n    const available = this.playerResources.getResource(resourceType);\n    const newQuantity = current + rate;\n\n    // V\u00E9rifier qu'on ne d\u00E9passe pas les ressources disponibles\n    if (newQuantity <= available) {\n      this.offeredResources.set(resourceType, newQuantity);\n      this.update();\n    }\n  }\n\n  /**\n   * G\u00E8re le clic sur une ressource dans la liste des ressources demand\u00E9es.\n   */\n  private handleRequestedClick(resourceType: ResourceType): void {\n    const current = this.requestedResources.get(resourceType) || 0;\n    this.requestedResources.set(resourceType, current + 1);\n    this.update();\n  }\n\n  /**\n   * G\u00E8re le clic droit sur une ressource dans la liste des ressources offertes (retire un batch).\n   */\n  private handleOfferedRightClick(resourceType: ResourceType): void {\n    const current = this.offeredResources.get(resourceType) || 0;\n    if (current > 0) {\n      const rate = (this.civId && this.gameMap)\n        ? TradeController.getTradeRateForCivilization(this.civId, this.gameMap)\n        : 4;\n      const newQuantity = Math.max(0, current - rate);\n      this.offeredResources.set(resourceType, newQuantity);\n      this.update();\n    }\n  }\n\n  /**\n   * G\u00E8re le clic droit sur une ressource dans la liste des ressources demand\u00E9es (retire une unit\u00E9).\n   */\n  private handleRequestedRightClick(resourceType: ResourceType): void {\n    const current = this.requestedResources.get(resourceType) || 0;\n    if (current > 0) {\n      this.requestedResources.set(resourceType, current - 1);\n      this.update();\n    }\n  }\n\n  /**\n   * Calcule le nombre total de batches offerts.\n   */\n  private getOfferedBatches(): number {\n    const rate = (this.civId && this.gameMap)\n      ? TradeController.getTradeRateForCivilization(this.civId, this.gameMap)\n      : 4;\n    let totalBatches = 0;\n    for (const [, quantity] of this.offeredResources.entries()) {\n      if (quantity > 0) {\n        totalBatches += quantity / rate;\n      }\n    }\n    return totalBatches;\n  }\n\n  /**\n   * Calcule le nombre total de batches demand\u00E9s (1 ressource = 1 batch).\n   */\n  private getRequestedBatches(): number {\n    let totalBatches = 0;\n    for (const quantity of this.requestedResources.values()) {\n      totalBatches += quantity;\n    }\n    return totalBatches;\n  }\n\n  /**\n   * Met \u00E0 jour les titres avec le nombre de batches.\n   */\n  private updateTitles(): void {\n    const offeredBatches = this.getOfferedBatches();\n    const requestedBatches = this.getRequestedBatches();\n\n    this.offeredTitle.textContent = offeredBatches > 0 \n      ? `Vous donnez (${offeredBatches})`\n      : 'Vous donnez';\n    \n    this.requestedTitle.textContent = requestedBatches > 0\n      ? `Vous recevez (${requestedBatches})`\n      : 'Vous recevez';\n  }\n\n  /**\n   * Met \u00E0 jour l'\u00E9tat du bouton \u00C9changer.\n   */\n  private updateConfirmButton(): void {\n    // Calculer le nombre de batches des deux c\u00F4t\u00E9s\n    const offeredBatches = this.getOfferedBatches();\n    const requestedBatches = this.getRequestedBatches();\n\n    // V\u00E9rifier que le nombre de batches est \u00E9gal des deux c\u00F4t\u00E9s\n    const batchesMatch = offeredBatches > 0 && requestedBatches > 0 && offeredBatches === requestedBatches;\n\n    // V\u00E9rifier l'acc\u00E8s au commerce\n    let canTrade = true;\n    if (this.gameMap && this.civId) {\n      canTrade = TradeController.canTrade(this.civId, this.gameMap);\n    }\n\n    // V\u00E9rifier que le joueur a assez de ressources pour toutes les offres\n    let hasEnoughResources = true;\n    if (this.playerResources) {\n      for (const [resourceType, quantity] of this.offeredResources.entries()) {\n        if (quantity > 0 && !this.playerResources.hasEnough(resourceType, quantity)) {\n          hasEnoughResources = false;\n          break;\n        }\n      }\n    }\n\n    // Le bouton est d\u00E9sactiv\u00E9 si les batches ne correspondent pas, si le commerce n'est pas disponible,\n    // ou si le joueur n'a pas assez de ressources\n    this.confirmBtn.disabled = !batchesMatch || !canTrade || !hasEnoughResources;\n  }\n}\n", "import { ResourceType } from '../model/map/ResourceType';\r\n\r\n/**\r\n * Gestionnaire pour charger et stocker les sprites de ressources.\r\n */\r\nexport class ResourceSprites {\r\n  private resourceSprites: Map<ResourceType, HTMLImageElement> = new Map();\r\n  private loadedCount: number = 0;\r\n  private totalSprites: number = 5; // Nombre de types de ressources\r\n  private onAllLoadedCallback: (() => void) | null = null;\r\n\r\n  /**\r\n   * Charge tous les sprites de ressources.\r\n   */\r\n  load(): void {\r\n    const spriteFiles: Record<ResourceType, string> = {\r\n      [ResourceType.Wood]: 'resource-wood.svg',\r\n      [ResourceType.Brick]: 'resource-brick.svg',\r\n      [ResourceType.Wheat]: 'resource-wheat.svg',\r\n      [ResourceType.Sheep]: 'resource-sheep.svg',\r\n      [ResourceType.Ore]: 'resource-ore.svg',\r\n    };\r\n\r\n    const checkAllLoaded = (): void => {\r\n      this.loadedCount++;\r\n      if (this.loadedCount === this.totalSprites) {\r\n        if (this.onAllLoadedCallback) {\r\n          this.onAllLoadedCallback();\r\n        }\r\n      }\r\n    };\r\n\r\n    for (const [resourceType, filename] of Object.entries(spriteFiles)) {\r\n      const type = resourceType as ResourceType;\r\n      const img = new Image();\r\n      const fullPath = `assets/sprites/${filename}`;\r\n\r\n      img.onload = () => {\r\n        this.resourceSprites.set(type, img);\r\n        checkAllLoaded();\r\n      };\r\n\r\n      img.onerror = () => {\r\n        console.warn(`\u00C9chec du chargement du sprite de ressource ${fullPath}`);\r\n        checkAllLoaded();\r\n      };\r\n\r\n      img.src = fullPath;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne le sprite d'une ressource, ou null s'il n'est pas encore charg\u00E9.\r\n   */\r\n  getSprite(resourceType: ResourceType): HTMLImageElement | null {\r\n    return this.resourceSprites.get(resourceType) || null;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un sprite est charg\u00E9 et pr\u00EAt \u00E0 \u00EAtre utilis\u00E9.\r\n   */\r\n  isSpriteReady(resourceType: ResourceType): boolean {\r\n    const sprite = this.resourceSprites.get(resourceType);\r\n    return sprite !== undefined && sprite.complete && sprite.naturalWidth > 0;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit un callback appel\u00E9 lorsque tous les sprites sont charg\u00E9s.\r\n   */\r\n  onAllLoaded(callback: () => void): void {\r\n    this.onAllLoadedCallback = callback;\r\n  }\r\n}\r\n", "import { Edge } from '../model/hex/Edge';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { ResourceType } from '../model/map/ResourceType';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\nimport { RoadConstruction } from '../model/game/RoadConstruction';\r\n\r\n/**\r\n * Contr\u00F4leur pour g\u00E9rer la construction de routes avec consommation de ressources.\r\n * \r\n * Cette classe orchestre la logique de construction de routes en coordonnant\r\n * les v\u00E9rifications m\u00E9tier (RoadConstruction) avec la consommation de ressources.\r\n */\r\nexport class RoadController {\r\n  /**\r\n   * Construit une route sur un edge pour une civilisation donn\u00E9e.\r\n   * V\u00E9rifie les conditions de construction et consomme les ressources n\u00E9cessaires.\r\n   * \r\n   * @param edge - L'ar\u00EAte o\u00F9 construire la route\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @param map - La carte de jeu\r\n   * @param resources - Les ressources du joueur\r\n   * @throws Error si la construction n'est pas possible ou si les ressources sont insuffisantes\r\n   */\r\n  static buildRoad(\r\n    edge: Edge,\r\n    civId: CivilizationId,\r\n    map: GameMap,\r\n    resources: PlayerResources\r\n  ): void {\r\n    // V\u00E9rifier que la construction est possible\r\n    if (!RoadConstruction.canBuildRoad(edge, civId, map)) {\r\n      throw new Error(\r\n        `La route ne peut pas \u00EAtre construite sur l'ar\u00EAte ${edge.toString()}. ` +\r\n        `L'ar\u00EAte doit toucher une ville ou une autre route de la m\u00EAme civilisation.`\r\n      );\r\n    }\r\n\r\n    // Calculer la distance \u00E0 la ville la plus proche pour cette route constructible\r\n    const distance = map.calculateBuildableRoadDistance(edge, civId);\r\n    if (distance === undefined) {\r\n      throw new Error(\r\n        `Impossible de calculer la distance pour la route sur l'ar\u00EAte ${edge.toString()}.`\r\n      );\r\n    }\r\n\r\n    // V\u00E9rifier que le joueur a assez de ressources (avec le co\u00FBt multipli\u00E9 par distance + 1)\r\n    if (!RoadConstruction.canAfford(resources, distance)) {\r\n      const cost = RoadConstruction.getCost(distance);\r\n      const brickCost = cost.get(ResourceType.Brick) || 0;\r\n      const woodCost = cost.get(ResourceType.Wood) || 0;\r\n      throw new Error(\r\n        `Pas assez de ressources pour construire une route. ` +\r\n        `Requis: ${brickCost} ${ResourceType.Brick} et ${woodCost} ${ResourceType.Wood} (distance: ${distance}).`\r\n      );\r\n    }\r\n\r\n    // Retirer les ressources (co\u00FBt multipli\u00E9 par distance + 1)\r\n    const cost = RoadConstruction.getCost(distance);\r\n    resources.payCost(cost);\r\n\r\n    // Ajouter la route sur la carte\r\n    map.addRoad(edge, civId);\r\n  }\r\n}\r\n", "/**\r\n * Version de l'application Colons of Idlestan.\r\n */\r\nexport const APP_VERSION = '0.0.1 alpha';\r\n\r\n/**\r\n * Nom de l'application.\r\n */\r\nexport const APP_NAME = 'Colons of Idlestan';\r\n", "import { MainGame } from './application/MainGame';\r\nimport { HexMapRenderer } from './view/HexMapRenderer';\r\nimport { CityPanelView } from './view/CityPanelView';\r\nimport { TradePanelView } from './view/TradePanelView';\r\nimport { ResourceSprites } from './view/ResourceSprites';\r\nimport { ResourceHarvest } from './model/game/ResourceHarvest';\r\nimport { RoadConstruction } from './model/game/RoadConstruction';\r\nimport { RoadController } from './controller/RoadController';\r\nimport { OutpostController } from './controller/OutpostController';\r\nimport { ResourceHarvestController } from './controller/ResourceHarvestController';\r\nimport { BuildingController } from './controller/BuildingController';\r\nimport { TradeController } from './controller/TradeController';\r\nimport { BuildingProductionController } from './controller/BuildingProductionController';\r\nimport { ResourceType } from './model/map/ResourceType';\r\nimport { HexCoord } from './model/hex/HexCoord';\r\nimport { Edge } from './model/hex/Edge';\r\nimport { Vertex } from './model/hex/Vertex';\r\nimport { BuildingType, BuildingAction, getResourceProductionBuildings } from './model/city/BuildingType';\r\nimport { City } from './model/city/City';\r\nimport { GameMap } from './model/map/GameMap';\r\nimport { APP_VERSION, APP_NAME } from './config/version';\r\n\r\n/**\r\n * Point d'entr\u00E9e principal de l'application web.\r\n */\r\nfunction main(): void {\r\n  // Mettre \u00E0 jour le titre de la page avec la version\r\n  document.title = `${APP_NAME} v${APP_VERSION}`;\r\n  \r\n  // Mettre \u00E0 jour le titre dans le header\r\n  const headerTitle = document.querySelector('.app-title');\r\n  if (headerTitle) {\r\n    headerTitle.textContent = `${APP_NAME} v${APP_VERSION}`;\r\n  }\r\n\r\n  // R\u00E9cup\u00E9rer les \u00E9l\u00E9ments DOM\r\n  const canvas = document.getElementById('map-canvas') as HTMLCanvasElement;\r\n  const settingsBtn = document.getElementById('settings-btn') as HTMLButtonElement;\r\n  const settingsMenu = document.getElementById('settings-menu') as HTMLElement;\r\n  const regenerateBtn = document.getElementById('regenerate-btn') as HTMLButtonElement;\r\n  const cheatBtn = document.getElementById('cheat-btn') as HTMLButtonElement;\r\n  const resourcesList = document.getElementById('resources-list') as HTMLDivElement;\r\n  // Cr\u00E9er la vue du panneau de ville\r\n  const cityPanelView = new CityPanelView('city-panel');\r\n\r\n  // Cr\u00E9er la vue du panneau de commerce\r\n  const tradePanelView = new TradePanelView('trade-panel');\r\n\r\n  if (!canvas) {\r\n    throw new Error('Canvas introuvable');\r\n  }\r\n\r\n  if (!settingsBtn) {\r\n    throw new Error('Bouton de param\u00E8tres introuvable');\r\n  }\r\n\r\n  if (!settingsMenu) {\r\n    throw new Error('Menu de param\u00E8tres introuvable');\r\n  }\r\n\r\n  if (!regenerateBtn) {\r\n    throw new Error('Bouton de r\u00E9g\u00E9n\u00E9ration introuvable');\r\n  }\r\n\r\n  if (!cheatBtn) {\r\n    throw new Error('Bouton cheat introuvable');\r\n  }\r\n\r\n  if (!resourcesList) {\r\n    throw new Error('Panneau de ressources introuvable');\r\n  }\r\n\r\n  // Cr\u00E9er le jeu principal\r\n  const game = new MainGame();\r\n\r\n  // Cr\u00E9er le renderer\r\n  const renderer = new HexMapRenderer(canvas);\r\n  \r\n  // Configurer le renderer pour le panneau de ville\r\n  cityPanelView.setRenderer(renderer);\r\n  \r\n  // Charger les sprites de ressources\r\n  const resourceSprites = new ResourceSprites();\r\n  resourceSprites.onAllLoaded(() => {\r\n    // Mettre \u00E0 jour l'affichage des ressources une fois les sprites charg\u00E9s\r\n    updateResourcesDisplay();\r\n  });\r\n  resourceSprites.load();\r\n\r\n  // Configurer les sprites de ressources pour le panneau de commerce\r\n  tradePanelView.setResourceSprites(resourceSprites);\r\n  \r\n  // Redimensionner le canvas au chargement et au redimensionnement\r\n  renderer.resize();\r\n  window.addEventListener('resize', () => {\r\n    renderer.resize();\r\n    const gameMap = game.getGameMap();\r\n    if (gameMap) {\r\n      const civId = game.getPlayerCivilizationId();\r\n      renderer.render(gameMap, civId);\r\n    }\r\n  });\r\n  \r\n  /**\r\n   * Met \u00E0 jour l'affichage des ressources du joueur.\r\n   */\r\n  function updateResourcesDisplay(): void {\r\n    if (!resourcesList) return;\r\n\r\n    const playerResources = game.getPlayerResources();\r\n    \r\n    // Noms des ressources en fran\u00E7ais\r\n    const resourceNames: Record<ResourceType, string> = {\r\n      [ResourceType.Wood]: 'Bois',\r\n      [ResourceType.Brick]: 'Brique',\r\n      [ResourceType.Wheat]: 'Bl\u00E9',\r\n      [ResourceType.Sheep]: 'Mouton',\r\n      [ResourceType.Ore]: 'Minerai',\r\n    };\r\n\r\n    // Ordre d'affichage des ressources\r\n    const resourceOrder: ResourceType[] = [\r\n      ResourceType.Wood,\r\n      ResourceType.Brick,\r\n      ResourceType.Wheat,\r\n      ResourceType.Sheep,\r\n      ResourceType.Ore,\r\n    ];\r\n\r\n    // Vider la liste\r\n    resourcesList.innerHTML = '';\r\n\r\n    // Ajouter toutes les ressources (m\u00EAme \u00E0 0)\r\n    for (const resourceType of resourceOrder) {\r\n      const count = playerResources.getResource(resourceType);\r\n      \r\n      const item = document.createElement('div');\r\n      item.className = 'resource-item';\r\n\r\n      // Utiliser le sprite si disponible, sinon fallback sur la couleur\r\n      const sprite = resourceSprites.getSprite(resourceType);\r\n      const spriteReady = resourceSprites.isSpriteReady(resourceType);\r\n      \r\n      if (spriteReady && sprite) {\r\n        const spriteImg = document.createElement('img');\r\n        spriteImg.src = sprite.src;\r\n        spriteImg.className = 'resource-sprite';\r\n        spriteImg.alt = resourceNames[resourceType];\r\n        spriteImg.style.width = '24px';\r\n        spriteImg.style.height = '24px';\r\n        spriteImg.style.objectFit = 'contain';\r\n        item.appendChild(spriteImg);\r\n      } else {\r\n        // Fallback : carr\u00E9 de couleur si le sprite n'est pas encore charg\u00E9\r\n        const color = document.createElement('div');\r\n        color.className = 'resource-color';\r\n        // Couleurs de fallback\r\n        const resourceColors: Record<ResourceType, string> = {\r\n          [ResourceType.Wood]: '#8B4513',\r\n          [ResourceType.Brick]: '#CD5C5C',\r\n          [ResourceType.Wheat]: '#FFD700',\r\n          [ResourceType.Sheep]: '#90EE90',\r\n          [ResourceType.Ore]: '#708090',\r\n        };\r\n        color.style.backgroundColor = resourceColors[resourceType];\r\n        item.appendChild(color);\r\n      }\r\n\r\n      const name = document.createElement('span');\r\n      name.className = 'resource-name';\r\n      name.textContent = resourceNames[resourceType];\r\n\r\n      const countEl = document.createElement('span');\r\n      countEl.className = 'resource-count';\r\n      countEl.textContent = count.toString();\r\n      \r\n      item.appendChild(name);\r\n      item.appendChild(countEl);\r\n      resourcesList.appendChild(item);\r\n    }\r\n  }\r\n\r\n  // Initialiser et afficher la premi\u00E8re carte\r\n  game.newGame();\r\n  const gameMap = game.getGameMap();\r\n  if (gameMap) {\r\n    const civId = game.getPlayerCivilizationId();\r\n    renderer.render(gameMap, civId);\r\n  }\r\n\r\n  /**\r\n   * Met \u00E0 jour l'affichage du panneau de la ville s\u00E9lectionn\u00E9e.\r\n   */\r\n  function updateCityPanel(): void {\r\n    const selectedVertex = renderer.getSelectedVertex();\r\n    const currentGameMap = game.getGameMap();\r\n    const city = selectedVertex && currentGameMap && currentGameMap.hasCity(selectedVertex)\r\n      ? currentGameMap.getCity(selectedVertex) || null\r\n      : null;\r\n    const playerResources = game.getPlayerResources();\r\n\r\n    cityPanelView.update(selectedVertex, currentGameMap, city, playerResources);\r\n  }\r\n\r\n  // Configurer les callbacks du panneau de ville\r\n  cityPanelView.setCallbacks({\r\n    onBuildBuilding: (buildingType: BuildingType, city: City, gameMap: GameMap, vertex: Vertex) => {\r\n      const playerResources = game.getPlayerResources();\r\n      const gameClock = game.getGameClock();\r\n      try {\r\n        BuildingController.buildBuilding(buildingType, city, gameMap, vertex, playerResources);\r\n        \r\n        // Si c'est un b\u00E2timent de ressource, initialiser son temps de production\r\n        const resourceBuildings = getResourceProductionBuildings();\r\n        if (resourceBuildings.includes(buildingType)) {\r\n          const currentTime = gameClock.getCurrentTime();\r\n          city.setBuildingProductionTime(buildingType, currentTime);\r\n        }\r\n        \r\n        updateResourcesDisplay();\r\n        updateCityPanel();\r\n        const civId = game.getPlayerCivilizationId();\r\n        renderer.render(gameMap, civId);\r\n      } catch (error) {\r\n        console.error('Erreur lors de la construction du b\u00E2timent:', error);\r\n      }\r\n    },\r\n    onBuildingAction: (action: BuildingAction, buildingType: BuildingType, city: City) => {\r\n      try {\r\n        if (action === BuildingAction.Upgrade) {\r\n          if (!city.canUpgrade()) {\r\n            return;\r\n          }\r\n          city.upgrade();\r\n        } else if (action === BuildingAction.Trade) {\r\n          // Mettre \u00E0 jour le contexte de jeu pour le panneau de commerce\r\n          const currentGameMap = game.getGameMap();\r\n          if (currentGameMap) {\r\n            const civId = game.getPlayerCivilizationId();\r\n            tradePanelView.setGameContext(currentGameMap, civId);\r\n          }\r\n          \r\n          // Ouvrir le panneau de commerce\r\n          const playerResources = game.getPlayerResources();\r\n          tradePanelView.show(playerResources);\r\n          return; // Ne pas mettre \u00E0 jour le panneau de ville ni re-rendre\r\n        }\r\n        updateCityPanel();\r\n        const currentGameMap = game.getGameMap();\r\n        if (currentGameMap) {\r\n          const civId = game.getPlayerCivilizationId();\r\n          renderer.render(currentGameMap, civId);\r\n        }\r\n      } catch (error) {\r\n        console.error(`Erreur lors de l'action ${action}:`, error);\r\n      }\r\n    },\r\n  });\r\n\r\n  // Configurer les callbacks du panneau de commerce\r\n  tradePanelView.setCallbacks({\r\n    onTrade: (offered: Map<ResourceType, number>, requested: Map<ResourceType, number>) => {\r\n      const currentGameMap = game.getGameMap();\r\n      if (!currentGameMap) {\r\n        return;\r\n      }\r\n\r\n      const civId = game.getPlayerCivilizationId();\r\n      const playerResources = game.getPlayerResources();\r\n\r\n      try {\r\n        // Effectuer l'\u00E9change batch via le contr\u00F4leur\r\n        TradeController.performBatchTrade(offered, requested, civId, currentGameMap, playerResources);\r\n\r\n        // Mettre \u00E0 jour l'affichage des ressources\r\n        updateResourcesDisplay();\r\n\r\n        // Fermer le panneau de commerce\r\n        tradePanelView.hide();\r\n      } catch (error) {\r\n        console.error('Erreur lors de l\\'\u00E9change:', error);\r\n        // On pourrait afficher un message \u00E0 l'utilisateur si n\u00E9cessaire\r\n        // Pour l'instant, on garde le panneau ouvert pour que l'utilisateur puisse corriger\r\n      }\r\n    },\r\n    onCancel: () => {\r\n      tradePanelView.hide();\r\n    },\r\n  });\r\n\r\n  // G\u00E9rer les \u00E9v\u00E9nements personnalis\u00E9s du panneau de ville\r\n  const panelElement = cityPanelView.getPanelElement();\r\n  \r\n  panelElement.addEventListener('buildBuilding', ((e: CustomEvent) => {\r\n    const selectedVertex = renderer.getSelectedVertex();\r\n    const currentGameMap = game.getGameMap();\r\n    if (!selectedVertex || !currentGameMap || !currentGameMap.hasCity(selectedVertex)) {\r\n      return;\r\n    }\r\n    const city = currentGameMap.getCity(selectedVertex);\r\n    if (!city) {\r\n      return;\r\n    }\r\n    cityPanelView.handleBuildBuilding(e.detail.buildingType, city, currentGameMap, selectedVertex);\r\n  }) as EventListener);\r\n\r\n  panelElement.addEventListener('buildingAction', ((e: CustomEvent) => {\r\n    const selectedVertex = renderer.getSelectedVertex();\r\n    const currentGameMap = game.getGameMap();\r\n    if (!selectedVertex || !currentGameMap || !currentGameMap.hasCity(selectedVertex)) {\r\n      return;\r\n    }\r\n    const city = currentGameMap.getCity(selectedVertex);\r\n    if (!city) {\r\n      return;\r\n    }\r\n    cityPanelView.handleBuildingAction(e.detail.buildingAction, e.detail.buildingType, city);\r\n  }) as EventListener);\r\n\r\n  // Configurer le callback de rendu pour la surbrillance au survol et la mise \u00E0 jour du panneau\r\n  renderer.setRenderCallback(() => {\r\n    const currentGameMap = game.getGameMap();\r\n    if (currentGameMap) {\r\n      const civId = game.getPlayerCivilizationId();\r\n      renderer.render(currentGameMap, civId);\r\n      updateCityPanel();\r\n    }\r\n  });\r\n\r\n  // Mettre \u00E0 jour l'affichage des ressources\r\n  updateResourcesDisplay();\r\n\r\n  // G\u00E9rer le clic sur les vertices constructibles pour construire des avant-postes\r\n  renderer.setOnOutpostVertexClick((vertex: Vertex) => {\r\n    const currentGameMap = game.getGameMap();\r\n    if (!currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    const civId = game.getPlayerCivilizationId();\r\n    const playerResources = game.getPlayerResources();\r\n\r\n    try {\r\n      // Construire l'avant-poste (le contr\u00F4leur v\u00E9rifie les conditions et consomme les ressources)\r\n      OutpostController.buildOutpost(vertex, civId, currentGameMap, playerResources);\r\n      \r\n      // Mettre \u00E0 jour l'affichage des ressources\r\n      updateResourcesDisplay();\r\n      \r\n      // Re-rendre la carte pour afficher la nouvelle ville\r\n      renderer.render(currentGameMap, civId);\r\n      \r\n      // Mettre \u00E0 jour le panneau de ville si une ville \u00E9tait s\u00E9lectionn\u00E9e\r\n      updateCityPanel();\r\n    } catch (error) {\r\n      // Ignorer silencieusement les erreurs de construction\r\n      // On pourrait afficher un message \u00E0 l'utilisateur si n\u00E9cessaire\r\n    }\r\n  });\r\n\r\n  // G\u00E9rer le clic sur les routes (edges) pour les construire\r\n  renderer.setOnEdgeClick((edge: Edge) => {\r\n    const currentGameMap = game.getGameMap();\r\n    if (!currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    const civId = game.getPlayerCivilizationId();\r\n    const playerResources = game.getPlayerResources();\r\n\r\n    try {\r\n      // Construire la route (le contr\u00F4leur v\u00E9rifie les conditions et consomme les ressources)\r\n      RoadController.buildRoad(edge, civId, currentGameMap, playerResources);\r\n      \r\n      // Mettre \u00E0 jour l'affichage des ressources\r\n      updateResourcesDisplay();\r\n      \r\n      // Re-rendre la carte pour afficher la nouvelle route\r\n      renderer.render(currentGameMap, civId);\r\n    } catch (error) {\r\n      // Ignorer silencieusement les erreurs de construction\r\n      // On pourrait afficher un message \u00E0 l'utilisateur si n\u00E9cessaire\r\n    }\r\n  });\r\n\r\n  // G\u00E9rer le clic sur les hexagones pour r\u00E9colter les ressources\r\n  renderer.setOnHexClick((hexCoord: HexCoord) => {\r\n    const currentGameMap = game.getGameMap();\r\n    if (!currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    const civId = game.getPlayerCivilizationId();\r\n    const playerResources = game.getPlayerResources();\r\n\r\n    // R\u00E9colter la ressource via le contr\u00F4leur (qui g\u00E8re la limitation de taux)\r\n    const result = ResourceHarvestController.harvest(hexCoord, civId, currentGameMap, playerResources);\r\n    \r\n    if (result.success && result.cityVertex) {\r\n      // D\u00E9clencher l'effet visuel de r\u00E9colte (manuel, donc avec effet de r\u00E9duction)\r\n      renderer.triggerHarvestEffect(hexCoord, false);\r\n      \r\n      // Obtenir le type de ressource r\u00E9colt\u00E9e pour l'animation\r\n      const hexType = currentGameMap.getHexType(hexCoord);\r\n      if (hexType) {\r\n        const resourceType = ResourceHarvest.hexTypeToResourceType(hexType);\r\n        if (resourceType) {\r\n          // D\u00E9clencher l'animation de la particule de ressource vers la ville\r\n          renderer.triggerResourceHarvestAnimation(hexCoord, resourceType, result.cityVertex);\r\n        }\r\n      }\r\n      \r\n      // Mettre \u00E0 jour l'affichage des ressources\r\n      updateResourcesDisplay();\r\n    }\r\n    // Si result.success est false, la r\u00E9colte a \u00E9chou\u00E9 (limitation de taux ou autre raison)\r\n    // On pourrait afficher un message \u00E0 l'utilisateur avec result.remainingTimeMs si n\u00E9cessaire\r\n  });\r\n\r\n  // G\u00E9rer le bouton d'engrenage pour ouvrir/fermer le menu\r\n  settingsBtn.addEventListener('click', (e) => {\r\n    e.stopPropagation(); // Emp\u00EAcher la fermeture imm\u00E9diate\r\n    settingsMenu.classList.toggle('hidden');\r\n  });\r\n\r\n  // Fermer le menu si on clique ailleurs\r\n  document.addEventListener('click', (e) => {\r\n    if (!settingsMenu.contains(e.target as Node) && !settingsBtn.contains(e.target as Node)) {\r\n      settingsMenu.classList.add('hidden');\r\n    }\r\n  });\r\n\r\n  // G\u00E9rer le bouton de r\u00E9g\u00E9n\u00E9ration dans le menu\r\n  regenerateBtn.addEventListener('click', () => {\r\n    game.newGame();\r\n    // R\u00E9initialiser le temps de r\u00E9f\u00E9rence pour la boucle d'animation\r\n    gameStartTime = null;\r\n    \r\n    const newGameMap = game.getGameMap();\r\n    if (newGameMap) {\r\n      const civId = game.getPlayerCivilizationId();\r\n      renderer.render(newGameMap, civId);\r\n      updateResourcesDisplay(); // R\u00E9initialiser l'affichage des ressources\r\n      updateCityPanel(); // Masquer le panneau de la ville\r\n    }\r\n    // Fermer le menu apr\u00E8s l'action\r\n    settingsMenu.classList.add('hidden');\r\n  });\r\n\r\n  // G\u00E9rer le bouton cheat dans le menu\r\n  cheatBtn.addEventListener('click', () => {\r\n    const playerResources = game.getPlayerResources();\r\n    \r\n    // Ajouter 100 ressources de chaque type\r\n    playerResources.addResource(ResourceType.Wood, 100);\r\n    playerResources.addResource(ResourceType.Brick, 100);\r\n    playerResources.addResource(ResourceType.Wheat, 100);\r\n    playerResources.addResource(ResourceType.Sheep, 100);\r\n    playerResources.addResource(ResourceType.Ore, 100);\r\n    \r\n    // Mettre \u00E0 jour l'affichage des ressources\r\n    updateResourcesDisplay();\r\n    \r\n    // Fermer le menu apr\u00E8s l'action\r\n    settingsMenu.classList.add('hidden');\r\n  });\r\n\r\n\r\n  // Initialiser le panneau (masqu\u00E9 par d\u00E9faut)\r\n  updateCityPanel();\r\n\r\n  /**\r\n   * Traite la production automatique des b\u00E2timents et d\u00E9clenche les animations.\r\n   */\r\n  function processAutomaticBuildingProduction(): void {\r\n    const currentGameMap = game.getGameMap();\r\n    if (!currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    const civId = game.getPlayerCivilizationId();\r\n    const playerResources = game.getPlayerResources();\r\n    const gameClock = game.getGameClock();\r\n\r\n    // Traiter la production automatique via le contr\u00F4leur\r\n    const productionResults = BuildingProductionController.processAutomaticProduction(\r\n      civId,\r\n      currentGameMap,\r\n      playerResources,\r\n      gameClock\r\n    );\r\n\r\n    // Si des productions ont eu lieu, d\u00E9clencher les animations et mettre \u00E0 jour l'affichage\r\n    if (productionResults.length > 0) {\r\n      // D\u00E9clencher les animations pour chaque production\r\n      for (const result of productionResults) {\r\n        // Effet visuel sur l'hex r\u00E9colt\u00E9 (automatique, donc sans effet de r\u00E9duction)\r\n        renderer.triggerHarvestEffect(result.hexCoord, true);\r\n        \r\n        // Animation de la particule de ressource vers la ville ayant d\u00E9clench\u00E9 le harvest\r\n        renderer.triggerResourceHarvestAnimation(\r\n          result.hexCoord,\r\n          result.resourceType,\r\n          result.cityVertex\r\n        );\r\n      }\r\n\r\n      // Mettre \u00E0 jour l'affichage des ressources\r\n      updateResourcesDisplay();\r\n    }\r\n  }\r\n\r\n  // Boucle principale d'animation pour g\u00E9rer le temps et la production automatique\r\n  let lastAnimationFrame: number | null = null;\r\n  let gameStartTime: number | null = null;\r\n\r\n  /**\r\n   * Boucle d'animation principale qui g\u00E8re le temps et la production automatique.\r\n   */\r\n  function gameLoop(timestamp: number): void {\r\n    // Initialiser le temps de r\u00E9f\u00E9rence au premier appel\r\n    if (gameStartTime === null) {\r\n      gameStartTime = timestamp;\r\n    }\r\n\r\n    // Calculer le temps \u00E9coul\u00E9 depuis le d\u00E9but en secondes\r\n    const timeSeconds = (timestamp - gameStartTime) / 1000;\r\n\r\n    // Mettre \u00E0 jour l'horloge de jeu\r\n    game.updateGameTime(timeSeconds);\r\n\r\n    // Traiter la production automatique\r\n    processAutomaticBuildingProduction();\r\n\r\n    // Continuer la boucle\r\n    lastAnimationFrame = requestAnimationFrame(gameLoop);\r\n  }\r\n\r\n  // D\u00E9marrer la boucle d'animation\r\n  lastAnimationFrame = requestAnimationFrame(gameLoop);\r\n}\r\n\r\n// Lancer l'application quand le DOM est pr\u00EAt\r\nif (document.readyState === 'loading') {\r\n  document.addEventListener('DOMContentLoaded', main);\r\n} else {\r\n  main();\r\n}\r\n"],
  "mappings": "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",
  "names": ["ResourceType", "BuildingType", "vertex", "main", "buildingCost", "tradeRate", "cost", "gameMap", "currentGameMap"]
}
