{
  "version": 3,
  "sources": ["src/model/hex/Edge.ts", "src/model/hex/Vertex.ts", "src/model/hex/HexDirection.ts", "src/model/hex/HexGrid.ts", "src/model/hex/Hex.ts", "src/model/hex/HexCoord.ts", "src/model/map/GameMap.ts", "src/controller/util/SeededRNG.ts", "src/controller/MapGenerator.ts", "src/model/map/CivilizationId.ts", "src/model/game/PlayerResources.ts", "src/application/MainGame.ts", "src/view/HexMapRenderer.ts", "src/model/game/ResourceHarvest.ts", "src/main.ts"],
  "sourcesContent": ["import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente une ar\u00EAte (edge) entre deux hexagones adjacents.\r\n *\r\n * Cette entit\u00E9 est purement g\u00E9om\u00E9trique et mod\u00E9lise une connexion\r\n * entre deux cellules voisines, quelle que soit la couche m\u00E9tier\r\n * (carte, arbre de technologies, etc.).\r\n *\r\n * Une ar\u00EAte est identifi\u00E9e de mani\u00E8re unique par deux hexagones adjacents.\r\n * L'ordre des hexagones est normalis\u00E9 pour garantir l'unicit\u00E9.\r\n */\r\nexport class Edge {\r\n  private constructor(\r\n    public readonly hex1: HexCoord,\r\n    public readonly hex2: HexCoord\r\n  ) {\r\n    // Validation: les hexagones doivent \u00EAtre adjacents\r\n    const distance = hex1.distanceTo(hex2);\r\n    if (distance !== 1) {\r\n      throw new Error(\r\n        `Les hexagones doivent \u00EAtre adjacents pour former une ar\u00EAte. Distance: ${distance}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e une ar\u00EAte entre deux hexagones adjacents.\r\n   * Normalise l'ordre pour garantir l'unicit\u00E9.\r\n   */\r\n  static create(hex1: HexCoord, hex2: HexCoord): Edge {\r\n    // Normaliser l'ordre pour garantir l'unicit\u00E9\r\n    const normalized = Edge.normalize(hex1, hex2);\r\n    return new Edge(normalized[0], normalized[1]);\r\n  }\r\n\r\n  /**\r\n   * Normalise l'ordre de deux coordonn\u00E9es pour garantir l'unicit\u00E9.\r\n   * Ordre: q d'abord, puis r si \u00E9galit\u00E9.\r\n   */\r\n  private static normalize(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord\r\n  ): [HexCoord, HexCoord] {\r\n    if (\r\n      hex1.q < hex2.q ||\r\n      (hex1.q === hex2.q && hex1.r < hex2.r)\r\n    ) {\r\n      return [hex1, hex2];\r\n    }\r\n    return [hex2, hex1];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cette ar\u00EAte est \u00E9gale \u00E0 une autre.\r\n   */\r\n  equals(other: Edge): boolean {\r\n    return (\r\n      (this.hex1.equals(other.hex1) && this.hex2.equals(other.hex2)) ||\r\n      (this.hex1.equals(other.hex2) && this.hex2.equals(other.hex1))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne les deux hexagones de cette ar\u00EAte.\r\n   */\r\n  getHexes(): [HexCoord, HexCoord] {\r\n    return [this.hex1, this.hex2];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cette ar\u00EAte est adjacente \u00E0 un hexagone donn\u00E9.\r\n   */\r\n  isAdjacentTo(hex: HexCoord): boolean {\r\n    return this.hex1.equals(hex) || this.hex2.equals(hex);\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Edge(${this.hex1.toString()} - ${this.hex2.toString()})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    const normalized = Edge.normalize(this.hex1, this.hex2);\r\n    return `${normalized[0].hashCode()}-${normalized[1].hashCode()}`;\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente un sommet (vertex) partag\u00E9 par plusieurs hexagones.\r\n *\r\n * Un sommet est un point d'intersection g\u00E9om\u00E9trique entre trois cellules\r\n * hexagonales mutuellement adjacentes. Cette abstraction est ind\u00E9pendante\r\n * de tout usage m\u00E9tier (b\u00E2timents, n\u0153uds de technologies, etc.).\r\n *\r\n * Un sommet est identifi\u00E9 de mani\u00E8re unique par trois hexagones adjacents\r\n * qui se rencontrent \u00E0 ce point. L'ordre des hexagones est normalis\u00E9 pour\r\n * garantir l'unicit\u00E9.\r\n */\r\nexport class Vertex {\r\n  private constructor(\r\n    public readonly hex1: HexCoord,\r\n    public readonly hex2: HexCoord,\r\n    public readonly hex3: HexCoord\r\n  ) {\r\n    // Validation: les hexagones doivent former un triangle valide\r\n    if (!Vertex.isValidTriangle(hex1, hex2, hex3)) {\r\n      throw new Error(\r\n        'Les trois hexagones doivent former un triangle valide pour cr\u00E9er un sommet.'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e un sommet \u00E0 partir de trois hexagones adjacents.\r\n   * Normalise l'ordre pour garantir l'unicit\u00E9.\r\n   */\r\n  static create(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): Vertex {\r\n    const normalized = Vertex.normalize(hex1, hex2, hex3);\r\n    return new Vertex(normalized[0], normalized[1], normalized[2]);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si trois hexagones forment un triangle valide (se rencontrent \u00E0 un sommet).\r\n   * Dans une grille hexagonale, trois hexagones se rencontrent \u00E0 un sommet si et seulement si\r\n   * ils sont tous mutuellement adjacents (distance 1 entre chaque paire).\r\n   */\r\n  private static isValidTriangle(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): boolean {\r\n    const d12 = hex1.distanceTo(hex2);\r\n    const d13 = hex1.distanceTo(hex3);\r\n    const d23 = hex2.distanceTo(hex3);\r\n\r\n    // Les trois hexagones doivent \u00EAtre mutuellement adjacents\r\n    return d12 === 1 && d13 === 1 && d23 === 1;\r\n  }\r\n\r\n  /**\r\n   * Normalise l'ordre de trois coordonn\u00E9es pour garantir l'unicit\u00E9.\r\n   * Trie par q puis r.\r\n   */\r\n  private static normalize(\r\n    hex1: HexCoord,\r\n    hex2: HexCoord,\r\n    hex3: HexCoord\r\n  ): [HexCoord, HexCoord, HexCoord] {\r\n    const hexes = [hex1, hex2, hex3];\r\n    hexes.sort((a, b) => {\r\n      if (a.q !== b.q) return a.q - b.q;\r\n      return a.r - b.r;\r\n    });\r\n    return [hexes[0], hexes[1], hexes[2]];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si ce sommet est \u00E9gal \u00E0 un autre.\r\n   */\r\n  equals(other: Vertex): boolean {\r\n    const thisHexes = Vertex.normalize(this.hex1, this.hex2, this.hex3);\r\n    const otherHexes = Vertex.normalize(other.hex1, other.hex2, other.hex3);\r\n\r\n    return (\r\n      thisHexes[0].equals(otherHexes[0]) &&\r\n      thisHexes[1].equals(otherHexes[1]) &&\r\n      thisHexes[2].equals(otherHexes[2])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne les trois hexagones de ce sommet.\r\n   */\r\n  getHexes(): [HexCoord, HexCoord, HexCoord] {\r\n    return [this.hex1, this.hex2, this.hex3];\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si ce sommet est adjacent \u00E0 un hexagone donn\u00E9.\r\n   */\r\n  isAdjacentTo(hex: HexCoord): boolean {\r\n    return (\r\n      this.hex1.equals(hex) ||\r\n      this.hex2.equals(hex) ||\r\n      this.hex3.equals(hex)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Vertex(${this.hex1.toString()}, ${this.hex2.toString()}, ${this.hex3.toString()})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    const normalized = Vertex.normalize(this.hex1, this.hex2, this.hex3);\r\n    return `${normalized[0].hashCode()}-${normalized[1].hashCode()}-${normalized[2].hashCode()}`;\r\n  }\r\n}\r\n", "/**\r\n * Repr\u00E9sente les six directions possibles dans une grille hexagonale.\r\n * Utilise le syst\u00E8me de coordonn\u00E9es axiales o\u00F9 chaque direction\r\n * correspond \u00E0 un d\u00E9placement dans le plan hexagonal.\r\n */\r\nexport enum HexDirection {\r\n  /** Nord */\r\n  N = 0,\r\n  /** Nord-Est */\r\n  NE = 1,\r\n  /** Sud-Est */\r\n  SE = 2,\r\n  /** Sud */\r\n  S = 3,\r\n  /** Sud-Ouest */\r\n  SW = 4,\r\n  /** Nord-Ouest */\r\n  NW = 5,\r\n}\r\n\r\n/**\r\n * Tableau de toutes les directions dans l'ordre.\r\n */\r\nexport const ALL_DIRECTIONS: readonly HexDirection[] = [\r\n  HexDirection.N,\r\n  HexDirection.NE,\r\n  HexDirection.SE,\r\n  HexDirection.S,\r\n  HexDirection.SW,\r\n  HexDirection.NW,\r\n] as const;\r\n", "import { HexCoord } from './HexCoord';\r\nimport { Hex } from './Hex';\r\nimport { Edge } from './Edge';\r\nimport { Vertex } from './Vertex';\r\nimport { HexDirection, ALL_DIRECTIONS } from './HexDirection';\r\n\r\n/**\r\n * Grille hexagonale g\u00E9n\u00E9rique bas\u00E9e sur des coordonn\u00E9es axiales.\r\n *\r\n * Cette grille ne conna\u00EEt que la topologie hexagonale (cellules, ar\u00EAtes,\r\n * sommets, voisinage). Elle peut \u00EAtre utilis\u00E9e aussi bien pour une carte\r\n * de jeu que pour un graphe abstrait (par exemple un arbre de technologies)\r\n * d\u00E8s lors que ces structures reposent sur une g\u00E9om\u00E9trie hexagonale.\r\n *\r\n * Dans ce syst\u00E8me, chaque hexagone est identifi\u00E9 par deux coordonn\u00E9es (q, r):\r\n * - q: coordonn\u00E9e colonne (axe horizontal)\r\n * - r: coordonn\u00E9e ligne (axe diagonal)\r\n *\r\n * Les voisins d'un hexagone sont obtenus en ajoutant des d\u00E9placements pr\u00E9d\u00E9finis\r\n * selon la direction choisie. Ce syst\u00E8me est plus simple que les coordonn\u00E9es\r\n * cubiques (q, r, s) car la troisi\u00E8me coordonn\u00E9e peut \u00EAtre d\u00E9riv\u00E9e: s = -q - r\r\n *\r\n *\r\n * Les ar\u00EAtes (edges) et sommets (vertices) sont calcul\u00E9s automatiquement\r\n * et partag\u00E9s entre les hexagones adjacents pour garantir l'unicit\u00E9.\r\n */\r\nexport class HexGrid {\r\n  private readonly hexMap: Map<string, Hex>;\r\n  private readonly edgeCache: Map<string, Edge>;\r\n  private readonly vertexCache: Map<string, Vertex>;\r\n\r\n  /**\r\n   * Cr\u00E9e une nouvelle grille hexagonale.\r\n   * @param hexes - Tableau d'hexagones \u00E0 ajouter \u00E0 la grille\r\n   */\r\n  constructor(hexes: Hex[] = []) {\r\n    this.hexMap = new Map();\r\n    this.edgeCache = new Map();\r\n    this.vertexCache = new Map();\r\n\r\n    // Ajouter tous les hexagones\r\n    for (const hex of hexes) {\r\n      this.hexMap.set(hex.coord.hashCode(), hex);\r\n    }\r\n\r\n    // Pr\u00E9-calculer les ar\u00EAtes et sommets pour tous les hexagones\r\n    this.precomputeEdgesAndVertices();\r\n  }\r\n\r\n  /**\r\n   * Retourne l'hexagone \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e, ou undefined s'il n'existe pas.\r\n   */\r\n  getHex(coord: HexCoord): Hex | undefined {\r\n    return this.hexMap.get(coord.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les hexagones de la grille.\r\n   */\r\n  getAllHexes(): Hex[] {\r\n    return Array.from(this.hexMap.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne les hexagones voisins de l'hexagone \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e.\r\n   * Ne retourne que les voisins qui existent dans la grille.\r\n   */\r\n  getNeighbors(coord: HexCoord): Hex[] {\r\n    const neighbors: Hex[] = [];\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const neighbor = this.getHex(neighborCoord);\r\n      if (neighbor) {\r\n        neighbors.push(neighbor);\r\n      }\r\n    }\r\n    return neighbors;\r\n  }\r\n\r\n  /**\r\n   * Retourne les coordonn\u00E9es des voisins (m\u00EAme s'ils n'existent pas dans la grille).\r\n   */\r\n  getNeighborCoords(coord: HexCoord): HexCoord[] {\r\n    return coord.neighbors();\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes adjacentes \u00E0 un hexagone donn\u00E9.\r\n   * Une ar\u00EAte est adjacente si elle connecte cet hexagone \u00E0 un voisin.\r\n   */\r\n  getEdges(coord: HexCoord): Edge[] {\r\n    const edges: Edge[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return edges;\r\n    }\r\n\r\n    // Pour chaque direction, cr\u00E9er une ar\u00EAte avec le voisin (s'il existe)\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const neighbor = this.getHex(neighborCoord);\r\n      if (neighbor) {\r\n        const edge = Edge.create(coord, neighborCoord);\r\n        edges.push(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes de la grille.\r\n   */\r\n  getAllEdges(): Edge[] {\r\n    return Array.from(this.edgeCache.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ar\u00EAtes adjacentes \u00E0 un hexagone donn\u00E9.\r\n   * Inclut toutes les ar\u00EAtes qui touchent cet hexagone, m\u00EAme celles\r\n   * qui ne connectent pas \u00E0 un autre hexagone de la grille.\r\n   */\r\n  getEdgesForHex(coord: HexCoord): Edge[] {\r\n    const edges: Edge[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return edges;\r\n    }\r\n\r\n    // Pour chaque direction, cr\u00E9er une ar\u00EAte avec le voisin\r\n    // M\u00EAme si le voisin n'existe pas dans la grille, l'ar\u00EAte existe\r\n    for (const direction of ALL_DIRECTIONS) {\r\n      const neighborCoord = coord.neighbor(direction);\r\n      const edge = Edge.create(coord, neighborCoord);\r\n      const edgeKey = edge.hashCode();\r\n      \r\n      // Utiliser le cache pour \u00E9viter les doublons\r\n      if (!this.edgeCache.has(edgeKey)) {\r\n        this.edgeCache.set(edgeKey, edge);\r\n      }\r\n      edges.push(this.edgeCache.get(edgeKey)!);\r\n    }\r\n\r\n    return edges;\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets adjacents \u00E0 un hexagone donn\u00E9.\r\n   * Un sommet est adjacent s'il est form\u00E9 par cet hexagone et deux de ses voisins.\r\n   */\r\n  getVertices(coord: HexCoord): Vertex[] {\r\n    const vertices: Vertex[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return vertices;\r\n    }\r\n\r\n    // Pour chaque paire de directions cons\u00E9cutives, cr\u00E9er un sommet\r\n    // Un sommet est form\u00E9 par trois hexagones qui se rencontrent\r\n    const directions = ALL_DIRECTIONS;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      const dir1 = directions[i];\r\n      const dir2 = directions[(i + 1) % directions.length];\r\n      \r\n      const neighbor1 = coord.neighbor(dir1);\r\n      const neighbor2 = coord.neighbor(dir2);\r\n      \r\n      // V\u00E9rifier si les deux voisins existent dans la grille\r\n      const hex1 = this.getHex(neighbor1);\r\n      const hex2 = this.getHex(neighbor2);\r\n      \r\n      if (hex1 && hex2) {\r\n        // Les trois hexagones forment un sommet\r\n        try {\r\n          const vertex = Vertex.create(coord, neighbor1, neighbor2);\r\n          const vertexKey = vertex.hashCode();\r\n          \r\n          if (!this.vertexCache.has(vertexKey)) {\r\n            this.vertexCache.set(vertexKey, vertex);\r\n          }\r\n          vertices.push(this.vertexCache.get(vertexKey)!);\r\n        } catch (e) {\r\n          // Ignorer si le sommet n'est pas valide\r\n        }\r\n      }\r\n    }\r\n\r\n    return vertices;\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets de la grille.\r\n   */\r\n  getAllVertices(): Vertex[] {\r\n    return Array.from(this.vertexCache.values());\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les sommets qui touchent un hexagone donn\u00E9.\r\n   * Inclut les sommets m\u00EAme si certains voisins n'existent pas dans la grille.\r\n   */\r\n  getVerticesForHex(coord: HexCoord): Vertex[] {\r\n    const vertices: Vertex[] = [];\r\n    const hex = this.getHex(coord);\r\n    if (!hex) {\r\n      return vertices;\r\n    }\r\n\r\n    // Pour chaque paire de directions cons\u00E9cutives, cr\u00E9er un sommet\r\n    const directions = ALL_DIRECTIONS;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      const dir1 = directions[i];\r\n      const dir2 = directions[(i + 1) % directions.length];\r\n      \r\n      const neighbor1 = coord.neighbor(dir1);\r\n      const neighbor2 = coord.neighbor(dir2);\r\n      \r\n      // Cr\u00E9er le sommet m\u00EAme si les voisins n'existent pas dans la grille\r\n      try {\r\n        const vertex = Vertex.create(coord, neighbor1, neighbor2);\r\n        const vertexKey = vertex.hashCode();\r\n        \r\n        if (!this.vertexCache.has(vertexKey)) {\r\n          this.vertexCache.set(vertexKey, vertex);\r\n        }\r\n        vertices.push(this.vertexCache.get(vertexKey)!);\r\n      } catch (e) {\r\n        // Ignorer si le sommet n'est pas valide\r\n      }\r\n    }\r\n\r\n    return vertices;\r\n  }\r\n\r\n  /**\r\n   * Pr\u00E9-calcule toutes les ar\u00EAtes et sommets pour optimiser les recherches.\r\n   */\r\n  private precomputeEdgesAndVertices(): void {\r\n    // Calculer toutes les ar\u00EAtes\r\n    for (const hex of this.hexMap.values()) {\r\n      this.getEdgesForHex(hex.coord);\r\n    }\r\n\r\n    // Calculer tous les sommets\r\n    for (const hex of this.hexMap.values()) {\r\n      this.getVerticesForHex(hex.coord);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne le nombre d'hexagones dans la grille.\r\n   */\r\n  size(): number {\r\n    return this.hexMap.size;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone existe \u00E0 la coordonn\u00E9e sp\u00E9cifi\u00E9e.\r\n   */\r\n  hasHex(coord: HexCoord): boolean {\r\n    return this.hexMap.has(coord.hashCode());\r\n  }\r\n}\r\n", "import { HexCoord } from './HexCoord';\r\n\r\n/**\r\n * Repr\u00E9sente une cellule hexagonale dans une grille.\r\n *\r\n * Cette classe est volontairement g\u00E9n\u00E9rique et ne contient que des\r\n * informations g\u00E9om\u00E9triques (la coordonn\u00E9e). Toute donn\u00E9e m\u00E9tier\r\n * (ressource, technologie, biome, etc.) doit \u00EAtre port\u00E9e par des\r\n * structures de niveau sup\u00E9rieur qui r\u00E9f\u00E9rencent cette cellule.\r\n */\r\nexport class Hex {\r\n  constructor(public readonly coord: HexCoord) {}\r\n\r\n  /**\r\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec un autre Hex (\u00E9galit\u00E9 structurelle sur la coordonn\u00E9e).\r\n   */\r\n  equals(other: Hex): boolean {\r\n    return this.coord.equals(other.coord);\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `Hex(${this.coord.toString()})`;\r\n  }\r\n}\r\n", "import { HexDirection, ALL_DIRECTIONS } from './HexDirection';\r\n\r\n/**\r\n * Syst\u00E8me de coordonn\u00E9es axiales pour les grilles hexagonales.\r\n * \r\n * Dans ce syst\u00E8me, chaque hexagone est identifi\u00E9 par deux coordonn\u00E9es (q, r):\r\n * - q: coordonn\u00E9e colonne (axe horizontal)\r\n * - r: coordonn\u00E9e ligne (axe diagonal)\r\n * \r\n * Les voisins d'un hexagone sont obtenus en ajoutant des d\u00E9placements pr\u00E9d\u00E9finis\r\n * selon la direction choisie. Ce syst\u00E8me est plus simple que les coordonn\u00E9es\r\n * cubiques (q, r, s) car la troisi\u00E8me coordonn\u00E9e peut \u00EAtre d\u00E9riv\u00E9e: s = -q - r\r\n *\r\n */\r\nexport class HexCoord {\r\n  constructor(\r\n    public readonly q: number,\r\n    public readonly r: number\r\n  ) {}\r\n\r\n  /**\r\n   * Retourne la coordonn\u00E9e s (d\u00E9riv\u00E9e) pour compatibilit\u00E9 avec syst\u00E8me cubique.\r\n   * Dans le syst\u00E8me axial, s = -q - r\r\n   */\r\n  get s(): number {\r\n    return -this.q - this.r;\r\n  }\r\n\r\n  /**\r\n   * Retourne les coordonn\u00E9es du voisin dans la direction sp\u00E9cifi\u00E9e.\r\n   * Les d\u00E9placements sont d\u00E9finis pour le syst\u00E8me de coordonn\u00E9es axiales.\r\n   */\r\n  neighbor(direction: HexDirection): HexCoord {\r\n    const deltas: Record<HexDirection, [number, number]> = {\r\n      [HexDirection.N]: [0, -1],\r\n      [HexDirection.NE]: [1, -1],\r\n      [HexDirection.SE]: [1, 0],\r\n      [HexDirection.S]: [0, 1],\r\n      [HexDirection.SW]: [-1, 1],\r\n      [HexDirection.NW]: [-1, 0],\r\n    };\r\n\r\n    const [dq, dr] = deltas[direction];\r\n    return new HexCoord(this.q + dq, this.r + dr);\r\n  }\r\n\r\n  /**\r\n   * Retourne tous les voisins de cet hexagone.\r\n   */\r\n  neighbors(): HexCoord[] {\r\n    return ALL_DIRECTIONS.map((dir) => this.neighbor(dir));\r\n  }\r\n\r\n  /**\r\n   * Calcule la distance entre deux hexagones.\r\n   */\r\n  distanceTo(other: HexCoord): number {\r\n    return (\r\n      (Math.abs(this.q - other.q) +\r\n        Math.abs(this.q + this.r - other.q - other.r) +\r\n        Math.abs(this.r - other.r)) /\r\n      2\r\n    );\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie l'\u00E9galit\u00E9 avec un autre HexCoord.\r\n   */\r\n  equals(other: HexCoord): boolean {\r\n    return this.q === other.q && this.r === other.r;\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `(${this.q}, ${this.r})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    return `${this.q},${this.r}`;\r\n  }\r\n}\r\n", "import { HexGrid } from '../hex/HexGrid';\r\nimport { Hex } from '../hex/Hex';\r\nimport { HexCoord } from '../hex/HexCoord';\r\nimport { Edge } from '../hex/Edge';\r\nimport { Vertex } from '../hex/Vertex';\r\nimport { HexType } from './HexType';\r\nimport { CivilizationId } from './CivilizationId';\r\n\r\n/**\r\n * Carte de jeu construite sur une grille hexagonale.\r\n * \r\n * G\u00E8re les types d'hexagones, les villes sur les sommets,\r\n * et les routes sur les ar\u00EAtes. D\u00E9termine la visibilit\u00E9 des hexagones\r\n * en fonction de la pr\u00E9sence de routes adjacentes.\r\n * \r\n * G\u00E8re \u00E9galement la propri\u00E9t\u00E9 des villes et routes par diff\u00E9rentes civilisations.\r\n */\r\nexport class GameMap {\r\n  private readonly hexTypeMap: Map<string, HexType>;\r\n  private readonly cities: Set<string>;\r\n  private readonly roads: Set<string>;\r\n  private readonly registeredCivilizations: Set<string>;\r\n  private readonly cityOwner: Map<string, CivilizationId>;\r\n  private readonly roadOwner: Map<string, CivilizationId>;\r\n\r\n  /**\r\n   * Cr\u00E9e une nouvelle carte de jeu \u00E0 partir d'une grille hexagonale.\r\n   * @param grid - La grille hexagonale sous-jacente\r\n   */\r\n  constructor(private readonly grid: HexGrid) {\r\n    this.hexTypeMap = new Map();\r\n    this.cities = new Set();\r\n    this.roads = new Set();\r\n    this.registeredCivilizations = new Set();\r\n    this.cityOwner = new Map();\r\n    this.roadOwner = new Map();\r\n\r\n    // Initialiser tous les hexagones \u00E0 Desert par d\u00E9faut\r\n    for (const hex of grid.getAllHexes()) {\r\n      this.hexTypeMap.set(hex.coord.hashCode(), HexType.Desert);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne la grille hexagonale sous-jacente.\r\n   */\r\n  getGrid(): HexGrid {\r\n    return this.grid;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit le type d'hexagone pour un hexagone.\r\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\r\n   * @param hexType - Le type d'hexagone\r\n   * @throws Error si l'hexagone n'existe pas dans la grille\r\n   */\r\n  setHexType(hex: Hex | HexCoord, hexType: HexType): void {\r\n    const coord = hex instanceof Hex ? hex.coord : hex;\r\n    if (!this.grid.hasHex(coord)) {\r\n      throw new Error(`L'hexagone \u00E0 la coordonn\u00E9e ${coord.toString()} n'existe pas dans la grille.`);\r\n    }\r\n    this.hexTypeMap.set(coord.hashCode(), hexType);\r\n  }\r\n\r\n  /**\r\n   * Retourne le type d'hexagone d'un hexagone.\r\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\r\n   * @returns Le type d'hexagone, ou undefined si l'hexagone n'existe pas\r\n   */\r\n  getHexType(hex: Hex | HexCoord): HexType | undefined {\r\n    const coord = hex instanceof Hex ? hex.coord : hex;\r\n    if (!this.grid.hasHex(coord)) {\r\n      return undefined;\r\n    }\r\n    return this.hexTypeMap.get(coord.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Enregistre une civilisation dans la carte.\r\n   * @param civId - L'identifiant de la civilisation\r\n   */\r\n  registerCivilization(civId: CivilizationId): void {\r\n    this.registeredCivilizations.add(civId.hashCode());\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une civilisation est enregistr\u00E9e.\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @returns true si la civilisation est enregistr\u00E9e\r\n   */\r\n  isCivilizationRegistered(civId: CivilizationId): boolean {\r\n    return this.registeredCivilizations.has(civId.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Ajoute une ville sur un sommet pour une civilisation donn\u00E9e.\r\n   * @param vertex - Le sommet o\u00F9 placer la ville\r\n   * @param civId - L'identifiant de la civilisation propri\u00E9taire\r\n   * @throws Error si le sommet n'est pas valide dans la grille\r\n   * @throws Error si une ville existe d\u00E9j\u00E0 sur ce sommet\r\n   * @throws Error si la civilisation n'est pas enregistr\u00E9e\r\n   */\r\n  addCity(vertex: Vertex, civId: CivilizationId): void {\r\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\r\n    if (!this.isCivilizationRegistered(civId)) {\r\n      throw new Error(`La civilisation ${civId.toString()} n'est pas enregistr\u00E9e.`);\r\n    }\r\n\r\n    const vertexKey = vertex.hashCode();\r\n\r\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une ville sur ce sommet\r\n    if (this.cities.has(vertexKey)) {\r\n      throw new Error(`Une ville existe d\u00E9j\u00E0 sur le sommet ${vertex.toString()}.`);\r\n    }\r\n\r\n    // V\u00E9rifier que le sommet est valide (au moins un hexagone doit exister)\r\n    const hexes = vertex.getHexes();\r\n    const hasValidHex = hexes.some(coord => this.grid.hasHex(coord));\r\n    \r\n    if (!hasValidHex) {\r\n      throw new Error(`Le sommet ${vertex.toString()} n'est pas valide dans la grille.`);\r\n    }\r\n    \r\n    this.cities.add(vertexKey);\r\n    this.cityOwner.set(vertexKey, civId);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une ville existe sur un sommet.\r\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\r\n   * @returns true si une ville existe sur ce sommet\r\n   */\r\n  hasCity(vertex: Vertex): boolean {\r\n    return this.cities.has(vertex.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Ajoute une route sur une ar\u00EAte pour une civilisation donn\u00E9e.\r\n   * @param edge - L'ar\u00EAte o\u00F9 placer la route\r\n   * @param civId - L'identifiant de la civilisation propri\u00E9taire\r\n   * @throws Error si l'ar\u00EAte n'est pas valide dans la grille\r\n   * @throws Error si une route existe d\u00E9j\u00E0 sur cette ar\u00EAte\r\n   * @throws Error si la civilisation n'est pas enregistr\u00E9e\r\n   */\r\n  addRoad(edge: Edge, civId: CivilizationId): void {\r\n    // V\u00E9rifier que la civilisation est enregistr\u00E9e\r\n    if (!this.isCivilizationRegistered(civId)) {\r\n      throw new Error(`La civilisation ${civId.toString()} n'est pas enregistr\u00E9e.`);\r\n    }\r\n\r\n    const edgeKey = edge.hashCode();\r\n\r\n    // V\u00E9rifier qu'il n'y a pas d\u00E9j\u00E0 une route sur cette ar\u00EAte\r\n    if (this.roads.has(edgeKey)) {\r\n      throw new Error(`Une route existe d\u00E9j\u00E0 sur l'ar\u00EAte ${edge.toString()}.`);\r\n    }\r\n\r\n    // V\u00E9rifier que l'ar\u00EAte est valide (au moins un hexagone doit exister)\r\n    const [hex1, hex2] = edge.getHexes();\r\n    const hasValidHex = this.grid.hasHex(hex1) || this.grid.hasHex(hex2);\r\n    \r\n    if (!hasValidHex) {\r\n      throw new Error(`L'ar\u00EAte ${edge.toString()} n'est pas valide dans la grille.`);\r\n    }\r\n    \r\n    this.roads.add(edgeKey);\r\n    this.roadOwner.set(edgeKey, civId);\r\n  }\r\n\r\n  /**\r\n   * Retourne le propri\u00E9taire d'une ville sur un sommet.\r\n   * @param vertex - Le sommet \u00E0 v\u00E9rifier\r\n   * @returns L'identifiant de la civilisation propri\u00E9taire, ou undefined s'il n'y a pas de ville\r\n   */\r\n  getCityOwner(vertex: Vertex): CivilizationId | undefined {\r\n    return this.cityOwner.get(vertex.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne le propri\u00E9taire d'une route sur une ar\u00EAte.\r\n   * @param edge - L'ar\u00EAte \u00E0 v\u00E9rifier\r\n   * @returns L'identifiant de la civilisation propri\u00E9taire, ou undefined s'il n'y a pas de route\r\n   */\r\n  getRoadOwner(edge: Edge): CivilizationId | undefined {\r\n    return this.roadOwner.get(edge.hashCode());\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les villes appartenant \u00E0 une civilisation donn\u00E9e.\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @returns Un tableau des sommets contenant des villes de cette civilisation\r\n   */\r\n  getCitiesForCivilization(civId: CivilizationId): Vertex[] {\r\n    const cities: Vertex[] = [];\r\n    const civKey = civId.hashCode();\r\n\r\n    // Parcourir tous les sommets de la grille pour trouver ceux poss\u00E9d\u00E9s par cette civilisation\r\n    for (const vertex of this.grid.getAllVertices()) {\r\n      const owner = this.cityOwner.get(vertex.hashCode());\r\n      if (owner && owner.hashCode() === civKey) {\r\n        cities.push(vertex);\r\n      }\r\n    }\r\n\r\n    return cities;\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les routes appartenant \u00E0 une civilisation donn\u00E9e.\r\n   * @param civId - L'identifiant de la civilisation\r\n   * @returns Un tableau des ar\u00EAtes contenant des routes de cette civilisation\r\n   */\r\n  getRoadsForCivilization(civId: CivilizationId): Edge[] {\r\n    const roads: Edge[] = [];\r\n    const civKey = civId.hashCode();\r\n\r\n    // Parcourir tous les hexagones pour obtenir leurs ar\u00EAtes\r\n    for (const hex of this.grid.getAllHexes()) {\r\n      const edges = this.grid.getEdgesForHex(hex.coord);\r\n      for (const edge of edges) {\r\n        const owner = this.roadOwner.get(edge.hashCode());\r\n        if (owner && owner.hashCode() === civKey && !roads.some(e => e.equals(edge))) {\r\n          roads.push(edge);\r\n        }\r\n      }\r\n    }\r\n\r\n    return roads;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une route existe sur une ar\u00EAte.\r\n   * @param edge - L'ar\u00EAte \u00E0 v\u00E9rifier\r\n   * @returns true si une route existe sur cette ar\u00EAte\r\n   */\r\n  hasRoad(edge: Edge): boolean {\r\n    return this.roads.has(edge.hashCode());\r\n  }\r\n\r\n  /**\r\n   * D\u00E9termine si un hexagone est visible.\r\n   * \r\n   * Un hexagone est visible si au moins un de ses sommets a une ville ou une route connect\u00E9e.\r\n   * Un hexagone sans ville ni route adjacente n'est pas visible.\r\n   * \r\n   * @param hex - L'hexagone ou sa coordonn\u00E9e\r\n   * @returns true si l'hexagone est visible, false sinon\r\n   */\r\n  isHexVisible(hex: Hex | HexCoord): boolean {\r\n    const coord = hex instanceof Hex ? hex.coord : hex;\r\n    \r\n    // Si l'hexagone n'existe pas, il n'est pas visible\r\n    if (!this.grid.hasHex(coord)) {\r\n      return false;\r\n    }\r\n\r\n    // Obtenir tous les sommets de cet hexagone\r\n    const vertices = this.grid.getVerticesForHex(coord);\r\n    \r\n    // V\u00E9rifier si au moins un sommet a une ville ou une route connect\u00E9e\r\n    for (const vertex of vertices) {\r\n      // V\u00E9rifier si ce vertex a une ville\r\n      if (this.hasCity(vertex)) {\r\n        return true;\r\n      }\r\n      \r\n      // V\u00E9rifier si ce vertex a une route connect\u00E9e\r\n      // Un sommet est form\u00E9 par 3 hexagones, donc il y a 3 ar\u00EAtes qui se rencontrent \u00E0 ce sommet\r\n      const hexes = vertex.getHexes();\r\n      \r\n      // V\u00E9rifier chaque paire d'hexagones pour former une ar\u00EAte\r\n      // Les 3 ar\u00EAtes possibles: (hex1,hex2), (hex2,hex3), (hex1,hex3)\r\n      for (let i = 0; i < hexes.length; i++) {\r\n        for (let j = i + 1; j < hexes.length; j++) {\r\n          try {\r\n            const edge = Edge.create(hexes[i], hexes[j]);\r\n            if (this.hasRoad(edge)) {\r\n              return true;\r\n            }\r\n          } catch (e) {\r\n            // Ignorer les ar\u00EAtes invalides (non adjacentes)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n}", "/**\r\n * G\u00E9n\u00E9rateur de nombres al\u00E9atoires seed\u00E9 simple.\r\n * \r\n * Impl\u00E9mentation d'un Linear Congruential Generator (LCG)\r\n * pour une g\u00E9n\u00E9ration al\u00E9atoire d\u00E9terministe et reproductible.\r\n * \r\n * Formule: next = (a * current + c) mod m\r\n * Param\u00E8tres: a = 1664525, c = 1013904223, m = 2^32\r\n */\r\nexport class SeededRNG {\r\n  private state: number;\r\n\r\n  /**\r\n   * Cr\u00E9e un nouveau g\u00E9n\u00E9rateur avec une seed initiale.\r\n   * @param seed - La seed initiale\r\n   */\r\n  constructor(seed: number) {\r\n    // Convertir en entier non sign\u00E9 32 bits\r\n    this.state = seed >>> 0;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re le prochain nombre al\u00E9atoire entre 0 (inclus) et 1 (exclus).\r\n   * @returns Un nombre al\u00E9atoire entre 0 et 1\r\n   */\r\n  next(): number {\r\n    // LCG: (a * state + c) mod m\r\n    // Param\u00E8tres de Borland C/C++ (utilis\u00E9s pour leur simplicit\u00E9 et qualit\u00E9)\r\n    this.state = (this.state * 1664525 + 1013904223) >>> 0;\r\n    // Normaliser \u00E0 [0, 1)\r\n    return (this.state >>> 0) / 0x100000000;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un nombre entier al\u00E9atoire entre min (inclus) et max (exclus).\r\n   * @param min - Borne inf\u00E9rieure (inclus)\r\n   * @param max - Borne sup\u00E9rieure (exclus)\r\n   * @returns Un entier al\u00E9atoire dans l'intervalle [min, max)\r\n   */\r\n  nextInt(min: number, max: number): number {\r\n    if (min >= max) {\r\n      throw new Error(`min (${min}) doit \u00EAtre strictement inf\u00E9rieur \u00E0 max (${max})`);\r\n    }\r\n    const range = max - min;\r\n    return min + Math.floor(this.next() * range);\r\n  }\r\n\r\n  /**\r\n   * S\u00E9lectionne un \u00E9l\u00E9ment al\u00E9atoire dans un tableau.\r\n   * @param array - Le tableau source\r\n   * @returns Un \u00E9l\u00E9ment du tableau, ou undefined si le tableau est vide\r\n   */\r\n  pick<T>(array: T[]): T | undefined {\r\n    if (array.length === 0) {\r\n      return undefined;\r\n    }\r\n    const index = this.nextInt(0, array.length);\r\n    return array[index];\r\n  }\r\n\r\n  /**\r\n   * M\u00E9lange un tableau de mani\u00E8re al\u00E9atoire (algorithme de Fisher-Yates).\r\n   * Modifie le tableau en place.\r\n   * @param array - Le tableau \u00E0 m\u00E9langer\r\n   */\r\n  shuffle<T>(array: T[]): void {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = this.nextInt(0, i + 1);\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne l'\u00E9tat actuel du g\u00E9n\u00E9rateur (utile pour les tests).\r\n   */\r\n  getState(): number {\r\n    return this.state;\r\n  }\r\n}\r\n", "import { HexGrid } from '../model/hex/HexGrid';\r\nimport { Hex } from '../model/hex/Hex';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { HexDirection, ALL_DIRECTIONS } from '../model/hex/HexDirection';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { HexType } from '../model/map/HexType';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { SeededRNG } from './util/SeededRNG';\r\n\r\n/**\r\n * Configuration pour la g\u00E9n\u00E9ration d'une carte.\r\n */\r\nexport interface MapGeneratorConfig {\r\n  /** Distribution des hexagones : nombre d'hexagones par type d'hexagone */\r\n  resourceDistribution: Map<HexType, number>;\r\n  /** Liste des civilisations (au moins une requise) */\r\n  civilizations: CivilizationId[];\r\n  /** Seed pour la g\u00E9n\u00E9ration d\u00E9terministe */\r\n  seed: number;\r\n}\r\n\r\n/**\r\n * G\u00E9n\u00E8re une GameMap selon des r\u00E8gles configurables.\r\n * \r\n * Cette classe appartient \u00E0 la couche Controller et agit comme une factory\r\n * pour cr\u00E9er des GameMap avec une structure et des ressources pr\u00E9d\u00E9termin\u00E9es.\r\n */\r\nexport class MapGenerator {\r\n  /**\r\n   * G\u00E9n\u00E8re une nouvelle GameMap selon la configuration fournie.\r\n   * \r\n   * @param config - Configuration de g\u00E9n\u00E9ration\r\n   * @returns Une GameMap compl\u00E8tement initialis\u00E9e avec ressources assign\u00E9es\r\n   * @throws Error si la configuration est invalide\r\n   */\r\n  generate(config: MapGeneratorConfig): GameMap {\r\n    this.validateConfig(config);\r\n\r\n    const rng = new SeededRNG(config.seed);\r\n    \r\n    // G\u00E9n\u00E9rer d'abord les hexagones terrestres (avec identification de Bois et Argile)\r\n    const { hexes: terrestrialHexes, woodCoord, brickCoord } = this.generateTerrestrialHexes(config, rng);\r\n    \r\n    // Ajouter la couche d'eau autour des hexagones terrestres\r\n    const allHexes = this.addWaterLayer(terrestrialHexes);\r\n    \r\n    // Cr\u00E9er la grille compl\u00E8te avec tous les hexagones (terrestres + eau)\r\n    const hexGrid = new HexGrid(allHexes);\r\n    const gameMap = new GameMap(hexGrid);\r\n\r\n    // Enregistrer les civilisations\r\n    for (const civId of config.civilizations) {\r\n      gameMap.registerCivilization(civId);\r\n    }\r\n\r\n    // Assigner les ressources aux hexagones terrestres\r\n    // Les deux premiers (Bois et Argile) doivent \u00EAtre assign\u00E9s en premier\r\n    this.assignResources(gameMap, terrestrialHexes, config, rng, woodCoord, brickCoord);\r\n\r\n    // Assigner Water \u00E0 tous les hexagones d'eau\r\n    this.assignWaterResources(gameMap, terrestrialHexes);\r\n\r\n    // Ajouter la ville initiale sur le vertex bois-argile-eau pour la premi\u00E8re civilisation\r\n    if (config.civilizations.length > 0) {\r\n      this.addInitialCity(gameMap, woodCoord, brickCoord, config.civilizations[0]);\r\n    }\r\n\r\n    return gameMap;\r\n  }\r\n\r\n  /**\r\n   * Valide la configuration de g\u00E9n\u00E9ration.\r\n   * @throws Error si la configuration est invalide\r\n   */\r\n  private validateConfig(config: MapGeneratorConfig): void {\r\n    if (!config.civilizations || config.civilizations.length === 0) {\r\n      throw new Error('Au moins une civilisation est requise.');\r\n    }\r\n\r\n    // Calculer le nombre total d'hexagones requis\r\n    let totalHexes = 0;\r\n    for (const count of config.resourceDistribution.values()) {\r\n      if (count < 0) {\r\n        throw new Error('La distribution de ressources ne peut pas contenir de valeurs n\u00E9gatives.');\r\n      }\r\n      totalHexes += count;\r\n    }\r\n\r\n    if (totalHexes === 0) {\r\n      throw new Error('Au moins un hexagone est requis (distribution de ressources vide).');\r\n    }\r\n\r\n    // V\u00E9rifier que le seed est valide (n'importe quel nombre est valide)\r\n    if (typeof config.seed !== 'number' || !isFinite(config.seed)) {\r\n      throw new Error('Le seed doit \u00EAtre un nombre fini.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re uniquement les hexagones terrestres selon les r\u00E8gles de placement.\r\n   * - Les 2 premiers hexagones sont plac\u00E9s adjacents\r\n   * - Chaque hexagone suivant doit \u00EAtre adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n   * - Apr\u00E8s g\u00E9n\u00E9ration, trouve un vertex au bord (2 hexagones + 1 emplacement eau) pour Bois et Argile\r\n   */\r\n  private generateTerrestrialHexes(config: MapGeneratorConfig, rng: SeededRNG): { hexes: Hex[], woodCoord: HexCoord, brickCoord: HexCoord } {\r\n    const totalHexes = this.calculateTotalHexes(config.resourceDistribution);\r\n    const placedCoords = new Set<string>();\r\n    const hexes: Hex[] = [];\r\n\r\n    // \u00C9tape 1: Placer les 2 premiers hexagones adjacents\r\n    const firstCoord = new HexCoord(0, 0);\r\n    const secondCoord = firstCoord.neighbor(HexDirection.N);\r\n\r\n    hexes.push(new Hex(firstCoord));\r\n    hexes.push(new Hex(secondCoord));\r\n    placedCoords.add(firstCoord.hashCode());\r\n    placedCoords.add(secondCoord.hashCode());\r\n\r\n    // \u00C9tape 2: Placer les hexagones restants\r\n    while (hexes.length < totalHexes) {\r\n      const candidateCoord = this.findValidPlacement(placedCoords, rng);\r\n\r\n      if (!candidateCoord) {\r\n        // Si aucun placement valide n'est trouv\u00E9, cela peut arriver si la distribution\r\n        // demande plus d'hexagones que possible avec les r\u00E8gles donn\u00E9es\r\n        throw new Error(\r\n          `Impossible de placer tous les hexagones requis. ` +\r\n          `Plac\u00E9s: ${hexes.length}/${totalHexes}. ` +\r\n          `V\u00E9rifiez que la distribution de ressources est raisonnable.`\r\n        );\r\n      }\r\n\r\n      hexes.push(new Hex(candidateCoord));\r\n      placedCoords.add(candidateCoord.hashCode());\r\n    }\r\n\r\n    // \u00C9tape 3: Trouver un vertex au bord pour placer Bois et Argile\r\n    // Un vertex au bord = 2 hexagones terrestres adjacents qui ont un voisin commun\r\n    // qui n'est pas encore dans les hexagones terrestres (sera l'eau)\r\n    const borderVertex = this.findBorderVertex(placedCoords, rng);\r\n    if (!borderVertex) {\r\n      throw new Error('Impossible de trouver un vertex au bord pour placer Bois et Argile.');\r\n    }\r\n\r\n    const { woodCoord, brickCoord } = borderVertex;\r\n\r\n    return { hexes, woodCoord, brickCoord };\r\n  }\r\n\r\n  /**\r\n   * Trouve un vertex au bord de la carte terrestre.\r\n   * Un vertex au bord est form\u00E9 par 2 hexagones terrestres adjacents\r\n   * qui ont un voisin commun qui n'est pas terrestre (sera l'eau).\r\n   */\r\n  private findBorderVertex(terrestrialCoords: Set<string>, rng: SeededRNG): { woodCoord: HexCoord, brickCoord: HexCoord } | null {\r\n    const borderCandidates: Array<{ woodCoord: HexCoord, brickCoord: HexCoord }> = [];\r\n\r\n    // Parcourir tous les hexagones terrestres\r\n    for (const coordHash of terrestrialCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const coord1 = new HexCoord(q, r);\r\n\r\n      // V\u00E9rifier tous les voisins de ce hexagone\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const coord2 = coord1.neighbor(direction);\r\n        \r\n        // Si le voisin est aussi terrestre, on a une paire adjacente\r\n        if (terrestrialCoords.has(coord2.hashCode())) {\r\n          // V\u00E9rifier si cette paire a un voisin commun qui n'est pas terrestre\r\n          const neighbors1 = coord1.neighbors();\r\n          const neighbors2 = coord2.neighbors();\r\n          \r\n          // Trouver les voisins communs\r\n          for (const n1 of neighbors1) {\r\n            if (neighbors2.some(n2 => n2.equals(n1))) {\r\n              // Ce voisin commun existe pour les deux hexagones\r\n              // Si ce voisin n'est pas terrestre, c'est un vertex au bord\r\n              if (!terrestrialCoords.has(n1.hashCode())) {\r\n                // On a trouv\u00E9 un vertex au bord : coord1, coord2, et n1 (qui sera l'eau)\r\n                borderCandidates.push({\r\n                  woodCoord: coord1,\r\n                  brickCoord: coord2,\r\n                });\r\n                break; // Pas besoin de continuer pour cette paire\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Choisir un candidat al\u00E9atoire\r\n    if (borderCandidates.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    return rng.pick(borderCandidates) || null;\r\n  }\r\n\r\n  /**\r\n   * Trouve une coordonn\u00E9e valide pour le prochain hexagone.\r\n   * Un placement est valide si le nouvel hexagone est adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s.\r\n   */\r\n  private findValidPlacement(placedCoords: Set<string>, rng: SeededRNG): HexCoord | null {\r\n    // Collecter tous les candidats (voisins des hexagones plac\u00E9s)\r\n    const candidateMap = new Map<string, HexCoord>();\r\n\r\n    // Pour chaque hexagone d\u00E9j\u00E0 plac\u00E9, examiner ses voisins\r\n    for (const coordHash of placedCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const coord = new HexCoord(q, r);\r\n\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const neighbor = coord.neighbor(direction);\r\n        const neighborHash = neighbor.hashCode();\r\n\r\n        // Si ce voisin n'est pas d\u00E9j\u00E0 plac\u00E9, l'ajouter aux candidats\r\n        if (!placedCoords.has(neighborHash)) {\r\n          candidateMap.set(neighborHash, neighbor);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Filtrer les candidats qui sont adjacents \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n    const validCandidates: HexCoord[] = [];\r\n    for (const candidate of candidateMap.values()) {\r\n      // Compter combien de voisins de ce candidat sont d\u00E9j\u00E0 plac\u00E9s\r\n      let adjacentCount = 0;\r\n      for (const dir of ALL_DIRECTIONS) {\r\n        const neighbor = candidate.neighbor(dir);\r\n        if (placedCoords.has(neighbor.hashCode())) {\r\n          adjacentCount++;\r\n        }\r\n      }\r\n\r\n      // Un hexagone doit \u00EAtre adjacent \u00E0 au moins 2 hexagones d\u00E9j\u00E0 plac\u00E9s\r\n      if (adjacentCount >= 2) {\r\n        validCandidates.push(candidate);\r\n      }\r\n    }\r\n\r\n    // Choisir un candidat al\u00E9atoire\r\n    return rng.pick(validCandidates) || null;\r\n  }\r\n\r\n  /**\r\n   * Calcule le nombre total d'hexagones requis.\r\n   */\r\n  private calculateTotalHexes(resourceDistribution: Map<HexType, number>): number {\r\n    let total = 0;\r\n    for (const count of resourceDistribution.values()) {\r\n      total += count;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Ajoute une couche d'hexagones d'eau autour des hexagones terrestres.\r\n   * Retourne tous les hexagones (terrestres + eau).\r\n   */\r\n  private addWaterLayer(terrestrialHexes: Hex[]): Hex[] {\r\n    const terrestrialCoords = new Set<string>();\r\n    const waterCoords = new Set<string>();\r\n\r\n    // Marquer tous les hexagones terrestres\r\n    for (const hex of terrestrialHexes) {\r\n      terrestrialCoords.add(hex.coord.hashCode());\r\n    }\r\n\r\n    // Trouver tous les hexagones d'eau n\u00E9cessaires (voisins des hexagones terrestres)\r\n    for (const hex of terrestrialHexes) {\r\n      for (const direction of ALL_DIRECTIONS) {\r\n        const neighborCoord = hex.coord.neighbor(direction);\r\n        const neighborHash = neighborCoord.hashCode();\r\n\r\n        // Si ce voisin n'est pas terrestre, c'est un hexagone d'eau\r\n        if (!terrestrialCoords.has(neighborHash) && !waterCoords.has(neighborHash)) {\r\n          waterCoords.add(neighborHash);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Cr\u00E9er tous les hexagones (terrestres + eau)\r\n    const allHexes: Hex[] = [...terrestrialHexes];\r\n\r\n    // Ajouter tous les hexagones d'eau\r\n    for (const coordHash of waterCoords) {\r\n      const [q, r] = coordHash.split(',').map(Number);\r\n      const waterCoord = new HexCoord(q, r);\r\n      allHexes.push(new Hex(waterCoord));\r\n    }\r\n\r\n    return allHexes;\r\n  }\r\n\r\n  /**\r\n   * Assign\u00EB les ressources aux hexagones terrestres selon la distribution.\r\n   * Exclut les hexagones d'eau.\r\n   * Les deux premiers hexagones (Bois et Argile) sont assign\u00E9s en premier.\r\n   */\r\n  private assignResources(\r\n    gameMap: GameMap,\r\n    terrestrialHexes: Hex[],\r\n    config: MapGeneratorConfig,\r\n    rng: SeededRNG,\r\n    woodCoord: HexCoord,\r\n    brickCoord: HexCoord\r\n  ): void {\r\n    // Cr\u00E9er une liste de tous les types d'hexagones \u00E0 assigner (sans l'eau)\r\n    const hexTypesToAssign: HexType[] = [];\r\n    for (const [hexType, count] of config.resourceDistribution.entries()) {\r\n      // Ignorer l'eau dans la distribution (elle sera ajout\u00E9e s\u00E9par\u00E9ment)\r\n      if (hexType === HexType.Water) {\r\n        continue;\r\n      }\r\n      for (let i = 0; i < count; i++) {\r\n        hexTypesToAssign.push(hexType);\r\n      }\r\n    }\r\n\r\n    // S\u00E9parer les hexagones Bois et Argile pour les placer en premier\r\n    const woodIndex = hexTypesToAssign.indexOf(HexType.Wood);\r\n    const brickIndex = hexTypesToAssign.indexOf(HexType.Brick);\r\n    \r\n    // Retirer Bois et Argile de la liste (un exemplaire de chaque)\r\n    if (woodIndex !== -1) {\r\n      hexTypesToAssign.splice(woodIndex, 1);\r\n    }\r\n    if (brickIndex !== -1 && brickIndex !== woodIndex) {\r\n      // Ajuster l'index si Wood a \u00E9t\u00E9 retir\u00E9 avant\r\n      const adjustedBrickIndex = hexTypesToAssign.indexOf(HexType.Brick);\r\n      if (adjustedBrickIndex !== -1) {\r\n        hexTypesToAssign.splice(adjustedBrickIndex, 1);\r\n      }\r\n    }\r\n\r\n    // M\u00E9langer la liste pour un placement al\u00E9atoire\r\n    rng.shuffle(hexTypesToAssign);\r\n\r\n    // Assigner Bois et Argile aux deux premiers hexagones\r\n    gameMap.setHexType(woodCoord, HexType.Wood);\r\n    gameMap.setHexType(brickCoord, HexType.Brick);\r\n\r\n    // Filtrer les hexagones terrestres (exclure Bois et Argile)\r\n    const remainingHexes = terrestrialHexes.filter(\r\n      hex => !hex.coord.equals(woodCoord) && !hex.coord.equals(brickCoord)\r\n    );\r\n\r\n    // M\u00E9langer les hexagones restants\r\n    const shuffledHexes = [...remainingHexes];\r\n    rng.shuffle(shuffledHexes);\r\n\r\n    // Assigner chaque type d'hexagone restant \u00E0 un hexagone\r\n    for (let i = 0; i < hexTypesToAssign.length && i < shuffledHexes.length; i++) {\r\n      const hex = shuffledHexes[i];\r\n      const hexType = hexTypesToAssign[i];\r\n      gameMap.setHexType(hex.coord, hexType);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign\u00EB Water \u00E0 tous les hexagones d'eau de la carte.\r\n   */\r\n  private assignWaterResources(gameMap: GameMap, terrestrialHexes: Hex[]): void {\r\n    const grid = gameMap.getGrid();\r\n    const terrestrialCoords = new Set<string>();\r\n\r\n    // Marquer tous les hexagones terrestres\r\n    for (const hex of terrestrialHexes) {\r\n      terrestrialCoords.add(hex.coord.hashCode());\r\n    }\r\n\r\n    // Parcourir tous les hexagones de la grille et assigner Water \u00E0 ceux qui ne sont pas terrestres\r\n    for (const hex of grid.getAllHexes()) {\r\n      if (!terrestrialCoords.has(hex.coord.hashCode())) {\r\n        gameMap.setHexType(hex.coord, HexType.Water);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ajoute la ville initiale sur le vertex bois-argile-eau.\r\n   */\r\n  private addInitialCity(\r\n    gameMap: GameMap,\r\n    woodCoord: HexCoord,\r\n    brickCoord: HexCoord,\r\n    civId: CivilizationId\r\n  ): void {\r\n    const grid = gameMap.getGrid();\r\n\r\n    // Trouver l'hexagone d'eau qui forme un vertex avec Bois et Argile\r\n    // Un vertex est form\u00E9 par trois hexagones mutuellement adjacents\r\n    // Nous devons trouver un hexagone d'eau adjacent \u00E0 la fois \u00E0 Bois et Argile\r\n    \r\n    // Les deux hexagones sont adjacents (brickCoord est en N de woodCoord)\r\n    // Pour former un vertex, il faut un troisi\u00E8me hexagone adjacent aux deux\r\n    \r\n    // M\u00E9thode 1: Chercher parmi tous les vertices du hexagone Bois\r\n    // Cela garantit que le vertex retourn\u00E9 correspond \u00E0 celui utilis\u00E9 dans la grille\r\n    const woodVertices = grid.getVerticesForHex(woodCoord);\r\n    for (const vertex of woodVertices) {\r\n      const hexes = vertex.getHexes();\r\n      // V\u00E9rifier si ce vertex contient woodCoord, brickCoord et un hexagone d'eau\r\n      const hasWood = hexes.some(h => h.equals(woodCoord));\r\n      const hasBrick = hexes.some(h => h.equals(brickCoord));\r\n      \r\n      if (hasWood && hasBrick) {\r\n        // Trouver l'hexagone qui n'est ni wood ni brick (c'est l'eau)\r\n        const waterHex = hexes.find(h => !h.equals(woodCoord) && !h.equals(brickCoord));\r\n        if (waterHex) {\r\n          const hexType = gameMap.getHexType(waterHex);\r\n          if (hexType === HexType.Water) {\r\n            // Ajouter la ville sur ce vertex (utiliser le vertex retourn\u00E9 par la grille)\r\n            try {\r\n              gameMap.addCity(vertex, civId);\r\n              const hexList = hexes.map(h => `(${h.q},${h.r})`).join(', ');\r\n              console.log(`[MapGenerator] \u2713 Ville cr\u00E9\u00E9e avec succ\u00E8s sur le vertex: [${hexList}]`);\r\n              return;\r\n            } catch (e) {\r\n              // Ignorer les erreurs (ville d\u00E9j\u00E0 pr\u00E9sente ou civilisation non enregistr\u00E9e)\r\n              // mais continuer la recherche\r\n              console.warn(`[MapGenerator] \u00C9chec lors de l'ajout de la ville (m\u00E9thode 1): ${e}`);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // M\u00E9thode 2: Si la m\u00E9thode 1 \u00E9choue, chercher les voisins communs\r\n    // Trouver tous les voisins communs de woodCoord et brickCoord\r\n    const woodNeighbors = woodCoord.neighbors();\r\n    const brickNeighbors = brickCoord.neighbors();\r\n    \r\n    for (const neighborCoord of woodNeighbors) {\r\n      // V\u00E9rifier si ce voisin est aussi voisin de brickCoord\r\n      const isNeighborOfBrick = brickNeighbors.some(n => n.equals(neighborCoord));\r\n      \r\n      if (isNeighborOfBrick) {\r\n        // V\u00E9rifier si cet hexagone existe dans la grille et est de l'eau\r\n        const neighborHex = grid.getHex(neighborCoord);\r\n        if (neighborHex) {\r\n          const hexType = gameMap.getHexType(neighborCoord);\r\n          if (hexType === HexType.Water) {\r\n            // Trouver le vertex correspondant dans la grille (pour utiliser le m\u00EAme instance)\r\n            const vertices = grid.getVerticesForHex(woodCoord);\r\n            for (const vertex of vertices) {\r\n              const hexes = vertex.getHexes();\r\n              if (hexes.some(h => h.equals(woodCoord)) &&\r\n                  hexes.some(h => h.equals(brickCoord)) &&\r\n                  hexes.some(h => h.equals(neighborCoord))) {\r\n                try {\r\n                  gameMap.addCity(vertex, civId);\r\n                  const hexList = hexes.map(h => `(${h.q},${h.r})`).join(', ');\r\n                  console.log(`[MapGenerator] \u2713 Ville cr\u00E9\u00E9e avec succ\u00E8s sur le vertex: [${hexList}]`);\r\n                  return;\r\n                } catch (e) {\r\n                  console.warn(`[MapGenerator] \u00C9chec lors de l'ajout de la ville (m\u00E9thode 2): ${e}`);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Si on arrive ici, la ville n'a pas pu \u00EAtre cr\u00E9\u00E9e\r\n    console.error(`[MapGenerator] \u2717 \u00C9CHEC: Impossible de cr\u00E9er la ville initiale sur le vertex Bois(${woodCoord.q},${woodCoord.r})-Argile(${brickCoord.q},${brickCoord.r})-Eau`);\r\n  }\r\n}\r\n", "/**\r\n * Identifiant unique d'une civilisation.\r\n * \r\n * Value object immuable qui garantit l'unicit\u00E9 d'une civilisation.\r\n */\r\nexport class CivilizationId {\r\n  private constructor(private readonly value: string) {\r\n    if (!value || value.trim().length === 0) {\r\n      throw new Error('L\\'identifiant de civilisation ne peut pas \u00EAtre vide.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cr\u00E9e un identifiant de civilisation.\r\n   * @param value - La valeur unique de l'identifiant\r\n   */\r\n  static create(value: string): CivilizationId {\r\n    return new CivilizationId(value.trim());\r\n  }\r\n\r\n  /**\r\n   * Retourne la valeur de l'identifiant.\r\n   */\r\n  getValue(): string {\r\n    return this.value;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si cet identifiant est \u00E9gal \u00E0 un autre.\r\n   */\r\n  equals(other: CivilizationId): boolean {\r\n    return this.value === other.value;\r\n  }\r\n\r\n  /**\r\n   * Retourne une repr\u00E9sentation en cha\u00EEne pour le d\u00E9bogage.\r\n   */\r\n  toString(): string {\r\n    return `CivilizationId(${this.value})`;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re un hash pour utiliser comme cl\u00E9 dans des Maps/Sets.\r\n   */\r\n  hashCode(): string {\r\n    return this.value;\r\n  }\r\n}\r\n", "import { ResourceType } from '../map/ResourceType';\r\n\r\n/**\r\n * G\u00E8re l'inventaire des ressources du joueur.\r\n * \r\n * Les ressources r\u00E9coltables sont : Wood, Brick, Wheat, Sheep, Ore.\r\n * Les ressources non r\u00E9coltables (Desert, Water) ne sont pas g\u00E9r\u00E9es ici.\r\n */\r\nexport class PlayerResources {\r\n  private resources: Map<ResourceType, number>;\r\n\r\n  /**\r\n   * Cr\u00E9e un inventaire vide.\r\n   */\r\n  constructor() {\r\n    this.resources = new Map();\r\n    // Initialiser toutes les ressources r\u00E9coltables \u00E0 0\r\n    this.resources.set(ResourceType.Wood, 0);\r\n    this.resources.set(ResourceType.Brick, 0);\r\n    this.resources.set(ResourceType.Wheat, 0);\r\n    this.resources.set(ResourceType.Sheep, 0);\r\n    this.resources.set(ResourceType.Ore, 0);\r\n  }\r\n\r\n  /**\r\n   * Ajoute une quantit\u00E9 de ressource \u00E0 l'inventaire.\r\n   * @param resource - Le type de ressource\r\n   * @param amount - La quantit\u00E9 \u00E0 ajouter (doit \u00EAtre positive)\r\n   * @throws Error si la ressource n'est pas r\u00E9coltable\r\n   * @throws Error si la quantit\u00E9 est n\u00E9gative\r\n   */\r\n  addResource(resource: ResourceType, amount: number): void {\r\n    if (!this.isHarvestable(resource)) {\r\n      throw new Error(`La ressource ${resource} n'est pas r\u00E9coltable.`);\r\n    }\r\n    if (amount < 0) {\r\n      throw new Error('La quantit\u00E9 \u00E0 ajouter doit \u00EAtre positive.');\r\n    }\r\n\r\n    const current = this.resources.get(resource) || 0;\r\n    this.resources.set(resource, current + amount);\r\n  }\r\n\r\n  /**\r\n   * Retire une quantit\u00E9 de ressource de l'inventaire.\r\n   * @param resource - Le type de ressource\r\n   * @param amount - La quantit\u00E9 \u00E0 retirer (doit \u00EAtre positive)\r\n   * @throws Error si la ressource n'est pas r\u00E9coltable\r\n   * @throws Error si la quantit\u00E9 est n\u00E9gative\r\n   * @throws Error si l'inventaire n'a pas assez de ressources\r\n   */\r\n  removeResource(resource: ResourceType, amount: number): void {\r\n    if (!this.isHarvestable(resource)) {\r\n      throw new Error(`La ressource ${resource} n'est pas r\u00E9coltable.`);\r\n    }\r\n    if (amount < 0) {\r\n      throw new Error('La quantit\u00E9 \u00E0 retirer doit \u00EAtre positive.');\r\n    }\r\n\r\n    const current = this.resources.get(resource) || 0;\r\n    if (current < amount) {\r\n      throw new Error(\r\n        `Pas assez de ${resource}. Disponible: ${current}, requis: ${amount}.`\r\n      );\r\n    }\r\n\r\n    this.resources.set(resource, current - amount);\r\n  }\r\n\r\n  /**\r\n   * Retourne la quantit\u00E9 d'une ressource dans l'inventaire.\r\n   * @param resource - Le type de ressource\r\n   * @returns La quantit\u00E9 disponible (0 si la ressource n'est pas r\u00E9coltable)\r\n   */\r\n  getResource(resource: ResourceType): number {\r\n    if (!this.isHarvestable(resource)) {\r\n      return 0;\r\n    }\r\n    return this.resources.get(resource) || 0;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si le joueur a assez d'une ressource donn\u00E9e.\r\n   * @param resource - Le type de ressource\r\n   * @param amount - La quantit\u00E9 requise\r\n   * @returns true si l'inventaire contient au moins la quantit\u00E9 requise\r\n   */\r\n  hasEnough(resource: ResourceType, amount: number): boolean {\r\n    if (!this.isHarvestable(resource)) {\r\n      return false;\r\n    }\r\n    return this.getResource(resource) >= amount;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si le joueur peut se permettre un co\u00FBt donn\u00E9.\r\n   * Un co\u00FBt est un objet avec des ressources et leurs quantit\u00E9s requises.\r\n   * @param cost - Un objet Map ou Record avec les ressources et quantit\u00E9s requises\r\n   * @returns true si toutes les ressources requises sont disponibles en quantit\u00E9 suffisante\r\n   */\r\n  canAfford(cost: Map<ResourceType, number> | Record<string, number>): boolean {\r\n    // Convertir Record en Map si n\u00E9cessaire\r\n    const costMap = cost instanceof Map\r\n      ? cost\r\n      : new Map(\r\n          Object.entries(cost).map(([key, value]) => [\r\n            key as ResourceType,\r\n            value as number,\r\n          ])\r\n        );\r\n\r\n    // V\u00E9rifier chaque ressource du co\u00FBt\r\n    for (const [resource, requiredAmount] of costMap.entries()) {\r\n      if (!this.hasEnough(resource, requiredAmount)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Retire les ressources correspondant \u00E0 un co\u00FBt de l'inventaire.\r\n   * @param cost - Un objet Map ou Record avec les ressources et quantit\u00E9s requises\r\n   * @throws Error si le joueur ne peut pas se permettre le co\u00FBt\r\n   */\r\n  payCost(cost: Map<ResourceType, number> | Record<string, number>): void {\r\n    if (!this.canAfford(cost)) {\r\n      throw new Error('Le joueur ne peut pas se permettre ce co\u00FBt.');\r\n    }\r\n\r\n    // Convertir Record en Map si n\u00E9cessaire\r\n    const costMap = cost instanceof Map\r\n      ? cost\r\n      : new Map(\r\n          Object.entries(cost).map(([key, value]) => [\r\n            key as ResourceType,\r\n            value as number,\r\n          ])\r\n        );\r\n\r\n    // Retirer chaque ressource\r\n    for (const [resource, amount] of costMap.entries()) {\r\n      this.removeResource(resource, amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retourne toutes les ressources de l'inventaire.\r\n   * @returns Un Map avec toutes les ressources et leurs quantit\u00E9s\r\n   */\r\n  getAllResources(): Map<ResourceType, number> {\r\n    return new Map(this.resources);\r\n  }\r\n\r\n  /**\r\n   * R\u00E9initialise toutes les ressources \u00E0 0.\r\n   */\r\n  clear(): void {\r\n    this.resources.set(ResourceType.Wood, 0);\r\n    this.resources.set(ResourceType.Brick, 0);\r\n    this.resources.set(ResourceType.Wheat, 0);\r\n    this.resources.set(ResourceType.Sheep, 0);\r\n    this.resources.set(ResourceType.Ore, 0);\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si une ressource est r\u00E9coltable.\r\n   * @param resource - Le type de ressource\r\n   * @returns true si la ressource peut \u00EAtre r\u00E9colt\u00E9e (Wood, Brick, Wheat, Sheep, Ore)\r\n   */\r\n  private isHarvestable(resource: ResourceType): boolean {\r\n    return (\r\n      resource === ResourceType.Wood ||\r\n      resource === ResourceType.Brick ||\r\n      resource === ResourceType.Wheat ||\r\n      resource === ResourceType.Sheep ||\r\n      resource === ResourceType.Ore\r\n    );\r\n  }\r\n}\r\n", "import { MapGenerator, MapGeneratorConfig } from '../controller/MapGenerator';\r\nimport { GameMap } from '../model/map/GameMap';\r\nimport { HexType } from '../model/map/HexType';\r\nimport { CivilizationId } from '../model/map/CivilizationId';\r\nimport { PlayerResources } from '../model/game/PlayerResources';\r\n\r\n/**\r\n * Classe principale de l'application de jeu.\r\n * \r\n * Orchestre la g\u00E9n\u00E9ration de la carte et la gestion du jeu.\r\n * Cette classe se situe au-dessus de la couche MVC.\r\n */\r\nexport class MainGame {\r\n  private gameMap: GameMap | null = null;\r\n  private readonly mapGenerator: MapGenerator;\r\n  private readonly playerResources: PlayerResources;\r\n  private readonly playerCivilizationId: CivilizationId;\r\n\r\n  constructor() {\r\n    this.mapGenerator = new MapGenerator();\r\n    this.playerResources = new PlayerResources();\r\n    this.playerCivilizationId = CivilizationId.create('player1');\r\n  }\r\n\r\n  /**\r\n   * Initialise une nouvelle partie en g\u00E9n\u00E9rant une carte.\r\n   * @param seed - Seed optionnel pour la g\u00E9n\u00E9ration (par d\u00E9faut: timestamp)\r\n   */\r\n  initialize(seed?: number): void {\r\n    const actualSeed = seed ?? Date.now();\r\n\r\n    // Configuration : 5 hexagones de chaque type (sauf Water qui est g\u00E9n\u00E9r\u00E9 automatiquement)\r\n    const resourceDistribution = new Map<HexType, number>([\r\n      [HexType.Wood, 5],\r\n      [HexType.Brick, 5],\r\n      [HexType.Wheat, 5],\r\n      [HexType.Sheep, 5],\r\n      [HexType.Ore, 5],\r\n      [HexType.Desert, 1],\r\n    ]);\r\n\r\n    // Cr\u00E9er une civilisation par d\u00E9faut\r\n    const civilizations = [CivilizationId.create('player1')];\r\n\r\n    const config: MapGeneratorConfig = {\r\n      resourceDistribution,\r\n      civilizations,\r\n      seed: actualSeed,\r\n    };\r\n\r\n    this.gameMap = this.mapGenerator.generate(config);\r\n    \r\n    // R\u00E9initialiser l'inventaire du joueur \u00E0 chaque nouvelle partie\r\n    this.playerResources.clear();\r\n  }\r\n\r\n  /**\r\n   * Retourne la carte de jeu actuelle.\r\n   * @returns La GameMap, ou null si non initialis\u00E9e\r\n   */\r\n  getGameMap(): GameMap | null {\r\n    return this.gameMap;\r\n  }\r\n\r\n  /**\r\n   * Retourne l'inventaire du joueur.\r\n   * @returns L'inventaire du joueur\r\n   */\r\n  getPlayerResources(): PlayerResources {\r\n    return this.playerResources;\r\n  }\r\n\r\n  /**\r\n   * Retourne l'identifiant de la civilisation du joueur.\r\n   * @returns L'identifiant de la civilisation\r\n   */\r\n  getPlayerCivilizationId(): CivilizationId {\r\n    return this.playerCivilizationId;\r\n  }\r\n\r\n  /**\r\n   * G\u00E9n\u00E8re une nouvelle carte avec un nouveau seed.\r\n   */\r\n  regenerate(): void {\r\n    this.initialize();\r\n  }\r\n}\r\n", "import { GameMap } from '../model/map/GameMap';\r\nimport { Hex } from '../model/hex/Hex';\r\nimport { HexCoord } from '../model/hex/HexCoord';\r\nimport { Vertex } from '../model/hex/Vertex';\r\nimport { HexType } from '../model/map/HexType';\r\n\r\n/**\r\n * Configuration pour le rendu des hexagones.\r\n */\r\ninterface RenderConfig {\r\n  /** Taille d'un hexagone (rayon) en pixels */\r\n  hexSize: number;\r\n  /** Offset X pour centrer la carte */\r\n  offsetX: number;\r\n  /** Offset Y pour centrer la carte */\r\n  offsetY: number;\r\n}\r\n\r\n/**\r\n * Couleur associ\u00E9e \u00E0 chaque type d'hexagone.\r\n */\r\nconst HEX_TYPE_COLORS: Record<HexType, string> = {\r\n  [HexType.Wood]: '#8B4513',      // Marron (bois)\r\n  [HexType.Brick]: '#CD5C5C',     // Rouge brique\r\n  [HexType.Wheat]: '#FFD700',     // Or (bl\u00E9)\r\n  [HexType.Sheep]: '#90EE90',     // Vert clair (mouton)\r\n  [HexType.Ore]: '#708090',       // Gris ardoise (minerai)\r\n  [HexType.Desert]: '#F4A460',   // Sable (d\u00E9sert)\r\n  [HexType.Water]: '#4169E1',     // Bleu royal (eau)\r\n};\r\n\r\n/**\r\n * Renderer pour afficher une GameMap sur un canvas HTML5.\r\n */\r\nexport class HexMapRenderer {\r\n  private canvas: HTMLCanvasElement;\r\n  private ctx: CanvasRenderingContext2D;\r\n  private showCoordinates: boolean = false;\r\n  private currentConfig: RenderConfig | null = null;\r\n  private currentGameMap: GameMap | null = null;\r\n\r\n  constructor(canvas: HTMLCanvasElement) {\r\n    this.canvas = canvas;\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new Error('Impossible d\\'obtenir le contexte 2D du canvas');\r\n    }\r\n    this.ctx = context;\r\n  }\r\n\r\n  /**\r\n   * Active ou d\u00E9sactive l'affichage des coordonn\u00E9es.\r\n   */\r\n  setShowCoordinates(show: boolean): void {\r\n    this.showCoordinates = show;\r\n  }\r\n\r\n  /**\r\n   * Dessine la carte compl\u00E8te sur le canvas.\r\n   * @param gameMap - La carte \u00E0 dessiner\r\n   */\r\n  render(gameMap: GameMap): void {\r\n    // Effacer le canvas\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    // Calculer les dimensions de la carte\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n\r\n    if (allHexes.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Filtrer uniquement les hexagones visibles\r\n    const visibleHexes = allHexes.filter(hex => gameMap.isHexVisible(hex.coord));\r\n\r\n    if (visibleHexes.length === 0) {\r\n      // Si aucun hexagone n'est visible, ne rien dessiner\r\n      return;\r\n    }\r\n\r\n    // Trouver les limites de la carte (uniquement pour les hexagones visibles)\r\n    let minQ = Infinity;\r\n    let maxQ = -Infinity;\r\n    let minR = Infinity;\r\n    let maxR = -Infinity;\r\n\r\n    for (const hex of visibleHexes) {\r\n      minQ = Math.min(minQ, hex.coord.q);\r\n      maxQ = Math.max(maxQ, hex.coord.q);\r\n      minR = Math.min(minR, hex.coord.r);\r\n      maxR = Math.max(maxR, hex.coord.r);\r\n    }\r\n\r\n    // Calculer la taille des hexagones pour que la carte tienne dans le canvas\r\n    const hexSize = this.calculateHexSize(minQ, maxQ, minR, maxR);\r\n    \r\n    // Calculer le centre de la carte en coordonn\u00E9es hexagonales\r\n    const centerQ = (minQ + maxQ) / 2;\r\n    const centerR = (minR + maxR) / 2;\r\n    \r\n    // Calculer les offsets pour centrer la carte\r\n    const offsetX = this.canvas.width / 2 - Math.sqrt(3) * (centerQ + centerR / 2) * hexSize;\r\n    const offsetY = this.canvas.height / 2 - (3 / 2) * centerR * hexSize;\r\n\r\n    const config: RenderConfig = {\r\n      hexSize,\r\n      offsetX,\r\n      offsetY,\r\n    };\r\n\r\n    // Stocker la configuration et la carte pour la d\u00E9tection de clic\r\n    this.currentConfig = config;\r\n    this.currentGameMap = gameMap;\r\n\r\n    // Dessiner uniquement les hexagones visibles\r\n    for (const hex of visibleHexes) {\r\n      this.drawHex(hex, gameMap, config);\r\n    }\r\n\r\n    // Dessiner les coordonn\u00E9es si activ\u00E9 (uniquement pour les hexagones visibles)\r\n    if (this.showCoordinates) {\r\n      for (const hex of visibleHexes) {\r\n        this.drawCoordinates(hex, config);\r\n      }\r\n    }\r\n\r\n    // Dessiner les villes sur leurs sommets\r\n    this.drawCities(gameMap, config);\r\n  }\r\n\r\n  /**\r\n   * Calcule la taille optimale des hexagones pour que la carte tienne dans le canvas.\r\n   */\r\n  private calculateHexSize(minQ: number, maxQ: number, minR: number, maxR: number): number {\r\n    const width = maxQ - minQ + 1;\r\n    const height = maxR - minR + 1;\r\n\r\n    // Dimensions approximatives d'un hexagone en coordonn\u00E9es axiales\r\n    // Largeur: sqrt(3) * size, Hauteur: 2 * size\r\n    const hexWidth = Math.sqrt(3);\r\n    const hexHeight = 2;\r\n\r\n    // Calculer la taille maximale possible\r\n    const maxWidth = (this.canvas.width * 0.9) / (width * hexWidth);\r\n    const maxHeight = (this.canvas.height * 0.9) / (height * hexHeight);\r\n\r\n    return Math.min(maxWidth, maxHeight, 40); // Limiter \u00E0 40px max\r\n  }\r\n\r\n  /**\r\n   * Dessine un hexagone sur le canvas.\r\n   */\r\n  private drawHex(hex: Hex, gameMap: GameMap, config: RenderConfig): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const coord = hex.coord;\r\n\r\n    // Convertir les coordonn\u00E9es axiales en coordonn\u00E9es pixel\r\n    // Formule: x = sqrt(3) * (q + r/2) * size\r\n    //          y = 3/2 * r * size\r\n    const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n    const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n\r\n    // Obtenir le type d'hexagone\r\n    const hexType = gameMap.getHexType(coord) || HexType.Desert;\r\n    const color = HEX_TYPE_COLORS[hexType] || '#CCCCCC';\r\n\r\n    // Dessiner l'hexagone avec une rotation de 30\u00B0 (pointy-top)\r\n    // Rotation de 30\u00B0 = \u03C0/6 radians pour passer de flat-top \u00E0 pointy-top\r\n    this.ctx.beginPath();\r\n    for (let i = 0; i < 6; i++) {\r\n      const angle = (Math.PI / 3) * i + Math.PI / 6;\r\n      const hx = x + hexSize * Math.cos(angle) * 0.9;\r\n      const hy = y + hexSize * Math.sin(angle) * 0.9;\r\n      if (i === 0) {\r\n        this.ctx.moveTo(hx, hy);\r\n      } else {\r\n        this.ctx.lineTo(hx, hy);\r\n      }\r\n    }\r\n    this.ctx.closePath();\r\n\r\n    // Remplir avec la couleur de la ressource\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.fill();\r\n\r\n    // Dessiner le contour\r\n    this.ctx.strokeStyle = '#000000';\r\n    this.ctx.lineWidth = 1;\r\n    this.ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Dessine les coordonn\u00E9es (q, r) au centre d'un hexagone.\r\n   */\r\n  private drawCoordinates(hex: Hex, config: RenderConfig): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const coord = hex.coord;\r\n\r\n    // Convertir les coordonn\u00E9es axiales en coordonn\u00E9es pixel (centre de l'hexagone)\r\n    const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n    const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n\r\n    // Dessiner le texte des coordonn\u00E9es\r\n    const text = `(${coord.q},${coord.r})`;\r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.font = `${Math.max(8, hexSize / 4)}px Arial`;\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.textBaseline = 'middle';\r\n    \r\n    // Dessiner un fond semi-transparent pour am\u00E9liorer la lisibilit\u00E9\r\n    const metrics = this.ctx.measureText(text);\r\n    const textWidth = metrics.width;\r\n    const textHeight = parseInt(this.ctx.font) || 12;\r\n    \r\n    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\r\n    this.ctx.fillRect(\r\n      x - textWidth / 2 - 2,\r\n      y - textHeight / 2 - 2,\r\n      textWidth + 4,\r\n      textHeight + 4\r\n    );\r\n    \r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.fillText(text, x, y);\r\n  }\r\n\r\n  /**\r\n   * Dessine les villes sur leurs sommets.\r\n   */\r\n  private drawCities(gameMap: GameMap, config: RenderConfig): void {\r\n    const grid = gameMap.getGrid();\r\n    const allHexes = grid.getAllHexes();\r\n\r\n    // Parcourir tous les hexagones pour trouver leurs vertices\r\n    // Utiliser un Set pour \u00E9viter les doublons\r\n    const processedVertices = new Set<string>();\r\n\r\n    for (const hex of allHexes) {\r\n      const vertices = grid.getVerticesForHex(hex.coord);\r\n      for (const vertex of vertices) {\r\n        const vertexKey = vertex.hashCode();\r\n        if (!processedVertices.has(vertexKey)) {\r\n          processedVertices.add(vertexKey);\r\n          \r\n          // V\u00E9rifier si ce vertex a une ville en utilisant le m\u00EAme vertex retourn\u00E9 par la grille\r\n          // Cela garantit que le hashCode correspond\r\n          if (gameMap.hasCity(vertex)) {\r\n            this.drawCity(vertex, config);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Debug: V\u00E9rifier tous les vertices pour s'assurer qu'on ne manque rien\r\n    // Cela peut aider \u00E0 identifier les villes non trouv\u00E9es\r\n    const allVertices = grid.getAllVertices();\r\n    for (const vertex of allVertices) {\r\n      const vertexKey = vertex.hashCode();\r\n      if (gameMap.hasCity(vertex)) {\r\n        // Si on trouve une ville dans getAllVertices mais pas dans drawCities,\r\n        // on la dessine quand m\u00EAme\r\n        if (!processedVertices.has(vertexKey)) {\r\n          this.drawCity(vertex, config);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dessine une ville sur un sommet (petit carr\u00E9 noir).\r\n   */\r\n  private drawCity(vertex: Vertex, config: RenderConfig): void {\r\n    const { hexSize, offsetX, offsetY } = config;\r\n    const hexes = vertex.getHexes();\r\n\r\n    // Calculer la position du sommet (centre du triangle form\u00E9 par les 3 hexagones)\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n\r\n    for (const coord of hexes) {\r\n      const x = offsetX + Math.sqrt(3) * (coord.q + coord.r / 2) * hexSize;\r\n      const y = offsetY + (3 / 2) * coord.r * hexSize;\r\n      sumX += x;\r\n      sumY += y;\r\n    }\r\n\r\n    const centerX = sumX / 3;\r\n    const centerY = sumY / 3;\r\n\r\n    // Dessiner un petit carr\u00E9 noir (taille 6x6 pixels)\r\n    const citySize = 6;\r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.fillRect(\r\n      centerX - citySize / 2,\r\n      centerY - citySize / 2,\r\n      citySize,\r\n      citySize\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Redimensionne le canvas pour qu'il s'adapte \u00E0 la fen\u00EAtre.\r\n   */\r\n  resize(): void {\r\n    // Ajuster la taille du canvas en tenant compte du header, footer et panneau de ressources\r\n    const header = document.querySelector('header');\r\n    const footer = document.querySelector('footer');\r\n    const resourcesPanel = document.getElementById('resources-panel');\r\n    const headerHeight = header ? header.offsetHeight : 0;\r\n    const footerHeight = footer ? footer.offsetHeight : 0;\r\n    const resourcesPanelWidth = resourcesPanel ? resourcesPanel.offsetWidth + 32 : 0; // +32 pour le gap et padding\r\n    \r\n    this.canvas.width = window.innerWidth - resourcesPanelWidth;\r\n    this.canvas.height = window.innerHeight - headerHeight - footerHeight;\r\n  }\r\n\r\n  /**\r\n   * Convertit les coordonn\u00E9es pixel (x, y) en coordonn\u00E9es hexagonales (q, r).\r\n   * @param pixelX - Coordonn\u00E9e X du pixel\r\n   * @param pixelY - Coordonn\u00E9e Y du pixel\r\n   * @returns Les coordonn\u00E9es hexagonales correspondantes, ou null si hors carte\r\n   */\r\n  pixelToHexCoord(pixelX: number, pixelY: number): HexCoord | null {\r\n    if (!this.currentConfig || !this.currentGameMap) {\r\n      return null;\r\n    }\r\n\r\n    const { hexSize, offsetX, offsetY } = this.currentConfig;\r\n    const grid = this.currentGameMap.getGrid();\r\n\r\n    // Convertir les coordonn\u00E9es pixel en coordonn\u00E9es hexagonales\r\n    // Formule inverse: \r\n    // q = (sqrt(3)/3 * x - 1/3 * y) / size - r/2\r\n    // r = (2/3 * y) / size\r\n    // On utilise une approche it\u00E9rative pour trouver le bon hexagone\r\n    \r\n    // Convertir pixel -> coordonn\u00E9es hexagonales approximatives\r\n    const x = pixelX - offsetX;\r\n    const y = pixelY - offsetY;\r\n    \r\n    const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / hexSize;\r\n    const r = (2 / 3 * y) / hexSize;\r\n\r\n    // Arrondir pour obtenir les coordonn\u00E9es hexagonales les plus proches\r\n    const hexQ = Math.round(q);\r\n    const hexR = Math.round(r);\r\n    \r\n    // V\u00E9rifier les 3 hexagones les plus proches (arrondi peut donner des erreurs)\r\n    const candidates = [\r\n      new HexCoord(hexQ, hexR),\r\n      new HexCoord(hexQ + 1, hexR),\r\n      new HexCoord(hexQ, hexR + 1),\r\n      new HexCoord(hexQ - 1, hexR),\r\n      new HexCoord(hexQ, hexR - 1),\r\n      new HexCoord(hexQ + 1, hexR - 1),\r\n      new HexCoord(hexQ - 1, hexR + 1),\r\n    ];\r\n\r\n    // Trouver le candidat le plus proche du point cliqu\u00E9 et qui existe dans la grille\r\n    let closestHex: HexCoord | null = null;\r\n    let minDistance = Infinity;\r\n\r\n    for (const candidate of candidates) {\r\n      if (!grid.hasHex(candidate)) {\r\n        continue;\r\n      }\r\n\r\n      // Calculer la position du centre de l'hexagone\r\n      const hexX = offsetX + Math.sqrt(3) * (candidate.q + candidate.r / 2) * hexSize;\r\n      const hexY = offsetY + (3 / 2) * candidate.r * hexSize;\r\n\r\n      // Calculer la distance depuis le point cliqu\u00E9\r\n      const dx = pixelX - hexX;\r\n      const dy = pixelY - hexY;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      // Si la distance est inf\u00E9rieure au rayon de l'hexagone (\u00E0 peu pr\u00E8s)\r\n      // L'hexagone a un rayon de hexSize\r\n      if (distance < hexSize * 0.9 && distance < minDistance) {\r\n        minDistance = distance;\r\n        closestHex = candidate;\r\n      }\r\n    }\r\n\r\n    return closestHex;\r\n  }\r\n\r\n  /**\r\n   * D\u00E9finit le callback \u00E0 appeler lorsqu'un hexagone est cliqu\u00E9.\r\n   * @param callback - Fonction appel\u00E9e avec les coordonn\u00E9es hexagonales du clic\r\n   */\r\n  setOnHexClick(callback: (hexCoord: HexCoord) => void): void {\r\n    this.canvas.addEventListener('click', (event) => {\r\n      const rect = this.canvas.getBoundingClientRect();\r\n      const pixelX = event.clientX - rect.left;\r\n      const pixelY = event.clientY - rect.top;\r\n\r\n      const hexCoord = this.pixelToHexCoord(pixelX, pixelY);\r\n      if (hexCoord) {\r\n        callback(hexCoord);\r\n      }\r\n    });\r\n  }\r\n}\r\n", "import { HexCoord } from '../hex/HexCoord';\r\nimport { Vertex } from '../hex/Vertex';\r\nimport { ResourceType } from '../map/ResourceType';\r\nimport { HexType } from '../map/HexType';\r\nimport { GameMap } from '../map/GameMap';\r\nimport { CivilizationId } from '../map/CivilizationId';\r\nimport { PlayerResources } from './PlayerResources';\r\n\r\n/**\r\n * G\u00E8re la logique de r\u00E9colte de ressources par clic sur les hexagones.\r\n * \r\n * Un hexagone est r\u00E9coltable si :\r\n * - Il est adjacent \u00E0 une ville du joueur (la ville est sur un vertex qui contient cet hexagone)\r\n * - Il est visible (d\u00E9termin\u00E9 par GameMap.isHexVisible)\r\n * - Il contient une ressource r\u00E9coltable (pas Desert ni Water)\r\n */\r\nexport class ResourceHarvest {\r\n  /**\r\n   * Convertit un HexType en ResourceType si c'est une ressource r\u00E9coltable.\r\n   * @param hexType - Le type d'hexagone\r\n   * @returns Le ResourceType correspondant, ou null si non r\u00E9coltable\r\n   */\r\n  static hexTypeToResourceType(hexType: HexType): ResourceType | null {\r\n    switch (hexType) {\r\n      case HexType.Wood:\r\n        return ResourceType.Wood;\r\n      case HexType.Brick:\r\n        return ResourceType.Brick;\r\n      case HexType.Wheat:\r\n        return ResourceType.Wheat;\r\n      case HexType.Sheep:\r\n        return ResourceType.Sheep;\r\n      case HexType.Ore:\r\n        return ResourceType.Ore;\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calcule le gain de ressource pour un hexagone donn\u00E9.\r\n   * Le gain de base est de 1 par hexagone, mais peut \u00EAtre modifi\u00E9 par des bonus futurs.\r\n   * @param hexType - Le type d'hexagone\r\n   * @returns La quantit\u00E9 de ressource gagn\u00E9e (0 si non r\u00E9coltable)\r\n   */\r\n  static calculateGain(hexType: HexType): number {\r\n    // Pour l'instant, gain de base de 1 par hexagone\r\n    // Peut \u00EAtre \u00E9tendu avec des bonus de b\u00E2timents plus tard\r\n    return this.hexTypeToResourceType(hexType) !== null ? 1 : 0;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone est adjacent \u00E0 une ville du joueur.\r\n   * Un hexagone est adjacent \u00E0 une ville si la ville est sur un vertex qui contient cet hexagone.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @returns true si l'hexagone est adjacent \u00E0 au moins une ville du joueur\r\n   */\r\n  static isAdjacentToPlayerCity(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId\r\n  ): boolean {\r\n    const grid = gameMap.getGrid();\r\n    \r\n    // Obtenir tous les vertices qui touchent cet hexagone\r\n    const vertices = grid.getVerticesForHex(hexCoord);\r\n    \r\n    // V\u00E9rifier si au moins un vertex a une ville appartenant au joueur\r\n    for (const vertex of vertices) {\r\n      if (gameMap.hasCity(vertex)) {\r\n        const owner = gameMap.getCityOwner(vertex);\r\n        if (owner && owner.equals(civId)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * V\u00E9rifie si un hexagone peut \u00EAtre r\u00E9colt\u00E9 par le joueur.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @returns true si l'hexagone est r\u00E9coltable\r\n   */\r\n  static canHarvest(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId\r\n  ): boolean {\r\n    // V\u00E9rifier que l'hexagone existe dans la grille\r\n    const grid = gameMap.getGrid();\r\n    if (!grid.hasHex(hexCoord)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que l'hexagone est visible\r\n    if (!gameMap.isHexVisible(hexCoord)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que l'hexagone est adjacent \u00E0 une ville du joueur\r\n    if (!this.isAdjacentToPlayerCity(hexCoord, gameMap, civId)) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier que l'hexagone contient une ressource r\u00E9coltable\r\n    const hexType = gameMap.getHexType(hexCoord);\r\n    if (!hexType) {\r\n      return false;\r\n    }\r\n\r\n    // V\u00E9rifier si le type d'hexagone est une ressource r\u00E9coltable\r\n    return this.hexTypeToResourceType(hexType) !== null;\r\n  }\r\n\r\n  /**\r\n   * R\u00E9colte les ressources d'un hexagone et les ajoute \u00E0 l'inventaire du joueur.\r\n   * @param hexCoord - La coordonn\u00E9e de l'hexagone \u00E0 r\u00E9colter\r\n   * @param gameMap - La carte de jeu\r\n   * @param civId - L'identifiant de la civilisation du joueur\r\n   * @param playerResources - L'inventaire du joueur\r\n   * @returns La quantit\u00E9 de ressource r\u00E9colt\u00E9e (0 si la r\u00E9colte a \u00E9chou\u00E9)\r\n   * @throws Error si l'hexagone ne peut pas \u00EAtre r\u00E9colt\u00E9\r\n   */\r\n  static harvest(\r\n    hexCoord: HexCoord,\r\n    gameMap: GameMap,\r\n    civId: CivilizationId,\r\n    playerResources: PlayerResources\r\n  ): number {\r\n    // V\u00E9rifier que la r\u00E9colte est possible\r\n    if (!this.canHarvest(hexCoord, gameMap, civId)) {\r\n      throw new Error(\r\n        `L'hexagone \u00E0 ${hexCoord.toString()} ne peut pas \u00EAtre r\u00E9colt\u00E9.`\r\n      );\r\n    }\r\n\r\n    // Obtenir le type d'hexagone\r\n    const hexType = gameMap.getHexType(hexCoord);\r\n    if (!hexType) {\r\n      throw new Error(\r\n        `Aucun type d'hexagone trouv\u00E9 sur l'hexagone \u00E0 ${hexCoord.toString()}.`\r\n      );\r\n    }\r\n\r\n    // Convertir en ResourceType\r\n    const resourceType = this.hexTypeToResourceType(hexType);\r\n    if (!resourceType) {\r\n      throw new Error(\r\n        `L'hexagone \u00E0 ${hexCoord.toString()} ne contient pas de ressource r\u00E9coltable.`\r\n      );\r\n    }\r\n\r\n    // Calculer le gain\r\n    const gain = this.calculateGain(hexType);\r\n    \r\n    if (gain > 0) {\r\n      // Ajouter la ressource \u00E0 l'inventaire\r\n      playerResources.addResource(resourceType, gain);\r\n    }\r\n\r\n    return gain;\r\n  }\r\n}\r\n", "import { MainGame } from './application/MainGame';\r\nimport { HexMapRenderer } from './view/HexMapRenderer';\r\nimport { ResourceHarvest } from './model/game/ResourceHarvest';\r\nimport { ResourceType } from './model/map/ResourceType';\r\nimport { HexCoord } from './model/hex/HexCoord';\r\n\r\n/**\r\n * Point d'entr\u00E9e principal de l'application web.\r\n */\r\nfunction main(): void {\r\n  // R\u00E9cup\u00E9rer les \u00E9l\u00E9ments DOM\r\n  const canvas = document.getElementById('map-canvas') as HTMLCanvasElement;\r\n  const regenerateBtn = document.getElementById('regenerate-btn') as HTMLButtonElement;\r\n  const resourcesList = document.getElementById('resources-list') as HTMLDivElement;\r\n\r\n  if (!canvas) {\r\n    throw new Error('Canvas introuvable');\r\n  }\r\n\r\n  if (!regenerateBtn) {\r\n    throw new Error('Bouton de r\u00E9g\u00E9n\u00E9ration introuvable');\r\n  }\r\n\r\n  if (!resourcesList) {\r\n    throw new Error('Panneau de ressources introuvable');\r\n  }\r\n\r\n  // Cr\u00E9er le jeu principal\r\n  const game = new MainGame();\r\n\r\n  // Cr\u00E9er le renderer\r\n  const renderer = new HexMapRenderer(canvas);\r\n  \r\n  // Redimensionner le canvas au chargement et au redimensionnement\r\n  renderer.resize();\r\n  window.addEventListener('resize', () => {\r\n    renderer.resize();\r\n    const gameMap = game.getGameMap();\r\n    if (gameMap) {\r\n      renderer.render(gameMap);\r\n    }\r\n  });\r\n  \r\n  /**\r\n   * Met \u00E0 jour l'affichage des ressources du joueur.\r\n   */\r\n  function updateResourcesDisplay(): void {\r\n    if (!resourcesList) return;\r\n\r\n    const playerResources = game.getPlayerResources();\r\n    \r\n    // Noms des ressources en fran\u00E7ais\r\n    const resourceNames: Record<ResourceType, string> = {\r\n      [ResourceType.Wood]: 'Bois',\r\n      [ResourceType.Brick]: 'Brique',\r\n      [ResourceType.Wheat]: 'Bl\u00E9',\r\n      [ResourceType.Sheep]: 'Mouton',\r\n      [ResourceType.Ore]: 'Minerai',\r\n    };\r\n\r\n    // Couleurs des ressources\r\n    const resourceColors: Record<ResourceType, string> = {\r\n      [ResourceType.Wood]: '#8B4513',\r\n      [ResourceType.Brick]: '#CD5C5C',\r\n      [ResourceType.Wheat]: '#FFD700',\r\n      [ResourceType.Sheep]: '#90EE90',\r\n      [ResourceType.Ore]: '#708090',\r\n    };\r\n\r\n    // Ordre d'affichage des ressources\r\n    const resourceOrder: ResourceType[] = [\r\n      ResourceType.Wood,\r\n      ResourceType.Brick,\r\n      ResourceType.Wheat,\r\n      ResourceType.Sheep,\r\n      ResourceType.Ore,\r\n    ];\r\n\r\n    // Vider la liste\r\n    resourcesList.innerHTML = '';\r\n\r\n    // Ajouter toutes les ressources (m\u00EAme \u00E0 0)\r\n    for (const resourceType of resourceOrder) {\r\n      const count = playerResources.getResource(resourceType);\r\n      \r\n      const item = document.createElement('div');\r\n      item.className = 'resource-item';\r\n      item.style.borderLeftColor = resourceColors[resourceType];\r\n\r\n      const color = document.createElement('div');\r\n      color.className = 'resource-color';\r\n      color.style.backgroundColor = resourceColors[resourceType];\r\n\r\n      const name = document.createElement('span');\r\n      name.className = 'resource-name';\r\n      name.textContent = resourceNames[resourceType];\r\n\r\n      const countEl = document.createElement('span');\r\n      countEl.className = 'resource-count';\r\n      countEl.textContent = count.toString();\r\n\r\n      item.appendChild(color);\r\n      item.appendChild(name);\r\n      item.appendChild(countEl);\r\n      resourcesList.appendChild(item);\r\n    }\r\n  }\r\n\r\n  // Initialiser et afficher la premi\u00E8re carte\r\n  game.initialize();\r\n  const gameMap = game.getGameMap();\r\n  if (gameMap) {\r\n    renderer.render(gameMap);\r\n  }\r\n\r\n  // Mettre \u00E0 jour l'affichage des ressources\r\n  updateResourcesDisplay();\r\n\r\n  // G\u00E9rer le clic sur les hexagones pour r\u00E9colter les ressources\r\n  renderer.setOnHexClick((hexCoord: HexCoord) => {\r\n    const currentGameMap = game.getGameMap();\r\n    if (!currentGameMap) {\r\n      return;\r\n    }\r\n\r\n    const civId = game.getPlayerCivilizationId();\r\n    const playerResources = game.getPlayerResources();\r\n\r\n    try {\r\n      // V\u00E9rifier si on peut r\u00E9colter\r\n      if (ResourceHarvest.canHarvest(hexCoord, currentGameMap, civId)) {\r\n        // R\u00E9colter la ressource\r\n        ResourceHarvest.harvest(hexCoord, currentGameMap, civId, playerResources);\r\n        \r\n        // Mettre \u00E0 jour l'affichage des ressources\r\n        updateResourcesDisplay();\r\n        \r\n        // Optionnel: Re-rendre la carte pour un feedback visuel\r\n        renderer.render(currentGameMap);\r\n      }\r\n    } catch (error) {\r\n      // Ignorer silencieusement les erreurs de r\u00E9colte (hexagone non r\u00E9coltable)\r\n      // On pourrait afficher un message \u00E0 l'utilisateur si n\u00E9cessaire\r\n      console.debug('R\u00E9colte impossible:', error);\r\n    }\r\n  });\r\n\r\n  // G\u00E9rer le bouton de r\u00E9g\u00E9n\u00E9ration\r\n  regenerateBtn.addEventListener('click', () => {\r\n    game.regenerate();\r\n    const newGameMap = game.getGameMap();\r\n    if (newGameMap) {\r\n      renderer.render(newGameMap);\r\n      updateResourcesDisplay(); // R\u00E9initialiser l'affichage des ressources\r\n    }\r\n  });\r\n}\r\n\r\n// Lancer l'application quand le DOM est pr\u00EAt\r\nif (document.readyState === 'loading') {\r\n  document.addEventListener('DOMContentLoaded', main);\r\n} else {\r\n  main();\r\n}\r\n"],
  "mappings": "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",
  "names": ["gameMap"]
}
